const Un="300 es";class si{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const i=this._listeners;i[e]===void 0&&(i[e]=[]),i[e].indexOf(t)===-1&&i[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const i=this._listeners;return i[e]!==void 0&&i[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const n=this._listeners[e];if(n!==void 0){const r=n.indexOf(t);r!==-1&&n.splice(r,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const i=this._listeners[e.type];if(i!==void 0){e.target=this;const n=i.slice(0);for(let r=0,s=n.length;r<s;r++)n[r].call(this,e);e.target=null}}}const Yi=Math.PI/180,Gn=180/Math.PI,Be=[];for(let a=0;a<256;a++)Be[a]=(a<16?"0":"")+a.toString(16);const Zr=typeof crypto!="undefined"&&"randomUUID"in crypto;function yi(){if(Zr)return crypto.randomUUID().toUpperCase();const a=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,i=Math.random()*4294967295|0;return(Be[a&255]+Be[a>>8&255]+Be[a>>16&255]+Be[a>>24&255]+"-"+Be[e&255]+Be[e>>8&255]+"-"+Be[e>>16&15|64]+Be[e>>24&255]+"-"+Be[t&63|128]+Be[t>>8&255]+"-"+Be[t>>16&255]+Be[t>>24&255]+Be[i&255]+Be[i>>8&255]+Be[i>>16&255]+Be[i>>24&255]).toUpperCase()}function st(a,e,t){return Math.max(e,Math.min(t,a))}function jr(a,e){return(a%e+e)%e}function Zi(a,e,t){return(1-t)*a+t*e}function Jr(a){return a*(.5-Math.random())}function On(a){return(a&a-1)===0&&a!==0}function $r(a){return Math.pow(2,Math.floor(Math.log(a)/Math.LN2))}class Re{constructor(e=0,t=0){this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this)}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this)}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,i=this.y,n=e.elements;return this.x=n[0]*t+n[3]*i+n[6],this.y=n[1]*t+n[4]*i+n[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(e,Math.min(t,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,i=this.y-e.y;return t*t+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t,i){return i!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const i=Math.cos(t),n=Math.sin(t),r=this.x-e.x,s=this.y-e.y;return this.x=r*i-s*n+e.x,this.y=r*n+s*i+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}Re.prototype.isVector2=!0;class nt{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(e,t,i,n,r,s,o,c,l){const h=this.elements;return h[0]=e,h[1]=n,h[2]=o,h[3]=t,h[4]=r,h[5]=c,h[6]=i,h[7]=s,h[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,i=e.elements;return t[0]=i[0],t[1]=i[1],t[2]=i[2],t[3]=i[3],t[4]=i[4],t[5]=i[5],t[6]=i[6],t[7]=i[7],t[8]=i[8],this}extractBasis(e,t,i){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const i=e.elements,n=t.elements,r=this.elements,s=i[0],o=i[3],c=i[6],l=i[1],h=i[4],p=i[7],f=i[2],m=i[5],_=i[8],g=n[0],b=n[3],u=n[6],d=n[1],T=n[4],M=n[7],w=n[2],E=n[5],v=n[8];return r[0]=s*g+o*d+c*w,r[3]=s*b+o*T+c*E,r[6]=s*u+o*M+c*v,r[1]=l*g+h*d+p*w,r[4]=l*b+h*T+p*E,r[7]=l*u+h*M+p*v,r[2]=f*g+m*d+_*w,r[5]=f*b+m*T+_*E,r[8]=f*u+m*M+_*v,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],i=e[1],n=e[2],r=e[3],s=e[4],o=e[5],c=e[6],l=e[7],h=e[8];return t*s*h-t*o*l-i*r*h+i*o*c+n*r*l-n*s*c}invert(){const e=this.elements,t=e[0],i=e[1],n=e[2],r=e[3],s=e[4],o=e[5],c=e[6],l=e[7],h=e[8],p=h*s-o*l,f=o*c-h*r,m=l*r-s*c,_=t*p+i*f+n*m;if(_===0)return this.set(0,0,0,0,0,0,0,0,0);const g=1/_;return e[0]=p*g,e[1]=(n*l-h*i)*g,e[2]=(o*i-n*s)*g,e[3]=f*g,e[4]=(h*t-n*c)*g,e[5]=(n*r-o*t)*g,e[6]=m*g,e[7]=(i*c-l*t)*g,e[8]=(s*t-i*r)*g,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,i,n,r,s,o){const c=Math.cos(r),l=Math.sin(r);return this.set(i*c,i*l,-i*(c*s+l*o)+s+e,-n*l,n*c,-n*(-l*s+c*o)+o+t,0,0,1),this}scale(e,t){const i=this.elements;return i[0]*=e,i[3]*=e,i[6]*=e,i[1]*=t,i[4]*=t,i[7]*=t,this}rotate(e){const t=Math.cos(e),i=Math.sin(e),n=this.elements,r=n[0],s=n[3],o=n[6],c=n[1],l=n[4],h=n[7];return n[0]=t*r+i*c,n[3]=t*s+i*l,n[6]=t*o+i*h,n[1]=-i*r+t*c,n[4]=-i*s+t*l,n[7]=-i*o+t*h,this}translate(e,t){const i=this.elements;return i[0]+=e*i[2],i[3]+=e*i[5],i[6]+=e*i[8],i[1]+=t*i[2],i[4]+=t*i[5],i[7]+=t*i[8],this}equals(e){const t=this.elements,i=e.elements;for(let n=0;n<9;n++)if(t[n]!==i[n])return!1;return!0}fromArray(e,t=0){for(let i=0;i<9;i++)this.elements[i]=e[i+t];return this}toArray(e=[],t=0){const i=this.elements;return e[t]=i[0],e[t+1]=i[1],e[t+2]=i[2],e[t+3]=i[3],e[t+4]=i[4],e[t+5]=i[5],e[t+6]=i[6],e[t+7]=i[7],e[t+8]=i[8],e}clone(){return new this.constructor().fromArray(this.elements)}}nt.prototype.isMatrix3=!0;function Mr(a){if(a.length===0)return-1/0;let e=a[0];for(let t=1,i=a.length;t<i;++t)a[t]>e&&(e=a[t]);return e}function wn(a){return document.createElementNS("http://www.w3.org/1999/xhtml",a)}let Vt;class Qr{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement=="undefined")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{Vt===void 0&&(Vt=wn("canvas")),Vt.width=e.width,Vt.height=e.height;const i=Vt.getContext("2d");e instanceof ImageData?i.putImageData(e,0,0):i.drawImage(e,0,0,e.width,e.height),t=Vt}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}}let Kr=0;class rt extends si{constructor(e=rt.DEFAULT_IMAGE,t=rt.DEFAULT_MAPPING,i=1001,n=1001,r=1006,s=1008,o=1023,c=1009,l=1,h=3e3){super(),Object.defineProperty(this,"id",{value:Kr++}),this.uuid=yi(),this.name="",this.image=e,this.mipmaps=[],this.mapping=t,this.wrapS=i,this.wrapT=n,this.magFilter=r,this.minFilter=s,this.anisotropy=l,this.format=o,this.internalFormat=null,this.type=c,this.offset=new Re(0,0),this.repeat=new Re(1,1),this.center=new Re(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new nt,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=h,this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.image=e.image,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const i={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==void 0){const n=this.image;if(n.uuid===void 0&&(n.uuid=yi()),!t&&e.images[n.uuid]===void 0){let r;if(Array.isArray(n)){r=[];for(let s=0,o=n.length;s<o;s++)n[s].isDataTexture?r.push(ji(n[s].image)):r.push(ji(n[s]))}else r=ji(n);e.images[n.uuid]={uuid:n.uuid,url:r}}i.image=n.uuid}return t||(e.textures[this.uuid]=i),i}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==300)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case 1e3:e.x=e.x-Math.floor(e.x);break;case 1001:e.x=e.x<0?0:1;break;case 1002:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case 1e3:e.y=e.y-Math.floor(e.y);break;case 1001:e.y=e.y<0?0:1;break;case 1002:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&this.version++}}rt.DEFAULT_IMAGE=void 0;rt.DEFAULT_MAPPING=300;rt.prototype.isTexture=!0;function ji(a){return typeof HTMLImageElement!="undefined"&&a instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&a instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&a instanceof ImageBitmap?Qr.getDataURL(a):a.data?{data:Array.prototype.slice.call(a.data),width:a.width,height:a.height,type:a.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}class We{constructor(e=0,t=0,i=0,n=1){this.x=e,this.y=t,this.z=i,this.w=n}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,i,n){return this.x=e,this.y=t,this.z=i,this.w=n,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,i=this.y,n=this.z,r=this.w,s=e.elements;return this.x=s[0]*t+s[4]*i+s[8]*n+s[12]*r,this.y=s[1]*t+s[5]*i+s[9]*n+s[13]*r,this.z=s[2]*t+s[6]*i+s[10]*n+s[14]*r,this.w=s[3]*t+s[7]*i+s[11]*n+s[15]*r,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,i,n,r;const c=e.elements,l=c[0],h=c[4],p=c[8],f=c[1],m=c[5],_=c[9],g=c[2],b=c[6],u=c[10];if(Math.abs(h-f)<.01&&Math.abs(p-g)<.01&&Math.abs(_-b)<.01){if(Math.abs(h+f)<.1&&Math.abs(p+g)<.1&&Math.abs(_+b)<.1&&Math.abs(l+m+u-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const T=(l+1)/2,M=(m+1)/2,w=(u+1)/2,E=(h+f)/4,v=(p+g)/4,U=(_+b)/4;return T>M&&T>w?T<.01?(i=0,n=.707106781,r=.707106781):(i=Math.sqrt(T),n=E/i,r=v/i):M>w?M<.01?(i=.707106781,n=0,r=.707106781):(n=Math.sqrt(M),i=E/n,r=U/n):w<.01?(i=.707106781,n=.707106781,r=0):(r=Math.sqrt(w),i=v/r,n=U/r),this.set(i,n,r,t),this}let d=Math.sqrt((b-_)*(b-_)+(p-g)*(p-g)+(f-h)*(f-h));return Math.abs(d)<.001&&(d=1),this.x=(b-_)/d,this.y=(p-g)/d,this.z=(f-h)/d,this.w=Math.acos((l+m+u-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(e,Math.min(t,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this.z=e.z+(t.z-e.z)*i,this.w=e.w+(t.w-e.w)*i,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t,i){return i!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}We.prototype.isVector4=!0;class Ct extends si{constructor(e,t,i={}){super(),this.width=e,this.height=t,this.depth=1,this.scissor=new We(0,0,e,t),this.scissorTest=!1,this.viewport=new We(0,0,e,t),this.texture=new rt(void 0,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.encoding),this.texture.isRenderTargetTexture=!0,this.texture.image={width:e,height:t,depth:1},this.texture.generateMipmaps=i.generateMipmaps!==void 0?i.generateMipmaps:!1,this.texture.internalFormat=i.internalFormat!==void 0?i.internalFormat:null,this.texture.minFilter=i.minFilter!==void 0?i.minFilter:1006,this.depthBuffer=i.depthBuffer!==void 0?i.depthBuffer:!0,this.stencilBuffer=i.stencilBuffer!==void 0?i.stencilBuffer:!1,this.depthTexture=i.depthTexture!==void 0?i.depthTexture:null}setTexture(e){e.image={width:this.width,height:this.height,depth:this.depth},this.texture=e}setSize(e,t,i=1){(this.width!==e||this.height!==t||this.depth!==i)&&(this.width=e,this.height=t,this.depth=i,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=i,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.texture.image={...this.texture.image},this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}Ct.prototype.isWebGLRenderTarget=!0;class yr extends Ct{constructor(e,t,i){super(e,t,i),this.samples=4}copy(e){return super.copy.call(this,e),this.samples=e.samples,this}}yr.prototype.isWebGLMultisampleRenderTarget=!0;class oi{constructor(e=0,t=0,i=0,n=1){this._x=e,this._y=t,this._z=i,this._w=n}static slerp(e,t,i,n){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),i.slerpQuaternions(e,t,n)}static slerpFlat(e,t,i,n,r,s,o){let c=i[n+0],l=i[n+1],h=i[n+2],p=i[n+3];const f=r[s+0],m=r[s+1],_=r[s+2],g=r[s+3];if(o===0){e[t+0]=c,e[t+1]=l,e[t+2]=h,e[t+3]=p;return}if(o===1){e[t+0]=f,e[t+1]=m,e[t+2]=_,e[t+3]=g;return}if(p!==g||c!==f||l!==m||h!==_){let b=1-o;const u=c*f+l*m+h*_+p*g,d=u>=0?1:-1,T=1-u*u;if(T>Number.EPSILON){const w=Math.sqrt(T),E=Math.atan2(w,u*d);b=Math.sin(b*E)/w,o=Math.sin(o*E)/w}const M=o*d;if(c=c*b+f*M,l=l*b+m*M,h=h*b+_*M,p=p*b+g*M,b===1-o){const w=1/Math.sqrt(c*c+l*l+h*h+p*p);c*=w,l*=w,h*=w,p*=w}}e[t]=c,e[t+1]=l,e[t+2]=h,e[t+3]=p}static multiplyQuaternionsFlat(e,t,i,n,r,s){const o=i[n],c=i[n+1],l=i[n+2],h=i[n+3],p=r[s],f=r[s+1],m=r[s+2],_=r[s+3];return e[t]=o*_+h*p+c*m-l*f,e[t+1]=c*_+h*f+l*p-o*m,e[t+2]=l*_+h*m+o*f-c*p,e[t+3]=h*_-o*p-c*f-l*m,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,i,n){return this._x=e,this._y=t,this._z=i,this._w=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){if(!(e&&e.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const i=e._x,n=e._y,r=e._z,s=e._order,o=Math.cos,c=Math.sin,l=o(i/2),h=o(n/2),p=o(r/2),f=c(i/2),m=c(n/2),_=c(r/2);switch(s){case"XYZ":this._x=f*h*p+l*m*_,this._y=l*m*p-f*h*_,this._z=l*h*_+f*m*p,this._w=l*h*p-f*m*_;break;case"YXZ":this._x=f*h*p+l*m*_,this._y=l*m*p-f*h*_,this._z=l*h*_-f*m*p,this._w=l*h*p+f*m*_;break;case"ZXY":this._x=f*h*p-l*m*_,this._y=l*m*p+f*h*_,this._z=l*h*_+f*m*p,this._w=l*h*p-f*m*_;break;case"ZYX":this._x=f*h*p-l*m*_,this._y=l*m*p+f*h*_,this._z=l*h*_-f*m*p,this._w=l*h*p+f*m*_;break;case"YZX":this._x=f*h*p+l*m*_,this._y=l*m*p+f*h*_,this._z=l*h*_-f*m*p,this._w=l*h*p-f*m*_;break;case"XZY":this._x=f*h*p-l*m*_,this._y=l*m*p-f*h*_,this._z=l*h*_+f*m*p,this._w=l*h*p+f*m*_;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+s)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const i=t/2,n=Math.sin(i);return this._x=e.x*n,this._y=e.y*n,this._z=e.z*n,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,i=t[0],n=t[4],r=t[8],s=t[1],o=t[5],c=t[9],l=t[2],h=t[6],p=t[10],f=i+o+p;if(f>0){const m=.5/Math.sqrt(f+1);this._w=.25/m,this._x=(h-c)*m,this._y=(r-l)*m,this._z=(s-n)*m}else if(i>o&&i>p){const m=2*Math.sqrt(1+i-o-p);this._w=(h-c)/m,this._x=.25*m,this._y=(n+s)/m,this._z=(r+l)/m}else if(o>p){const m=2*Math.sqrt(1+o-i-p);this._w=(r-l)/m,this._x=(n+s)/m,this._y=.25*m,this._z=(c+h)/m}else{const m=2*Math.sqrt(1+p-i-o);this._w=(s-n)/m,this._x=(r+l)/m,this._y=(c+h)/m,this._z=.25*m}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let i=e.dot(t)+1;return i<Number.EPSILON?(i=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=i):(this._x=0,this._y=-e.z,this._z=e.y,this._w=i)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=i),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(st(this.dot(e),-1,1)))}rotateTowards(e,t){const i=this.angleTo(e);if(i===0)return this;const n=Math.min(1,t/i);return this.slerp(e,n),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e,t){return t!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,t)):this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const i=e._x,n=e._y,r=e._z,s=e._w,o=t._x,c=t._y,l=t._z,h=t._w;return this._x=i*h+s*o+n*l-r*c,this._y=n*h+s*c+r*o-i*l,this._z=r*h+s*l+i*c-n*o,this._w=s*h-i*o-n*c-r*l,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const i=this._x,n=this._y,r=this._z,s=this._w;let o=s*e._w+i*e._x+n*e._y+r*e._z;if(o<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,o=-o):this.copy(e),o>=1)return this._w=s,this._x=i,this._y=n,this._z=r,this;const c=1-o*o;if(c<=Number.EPSILON){const m=1-t;return this._w=m*s+t*this._w,this._x=m*i+t*this._x,this._y=m*n+t*this._y,this._z=m*r+t*this._z,this.normalize(),this._onChangeCallback(),this}const l=Math.sqrt(c),h=Math.atan2(l,o),p=Math.sin((1-t)*h)/l,f=Math.sin(t*h)/l;return this._w=s*p+this._w*f,this._x=i*p+this._x*f,this._y=n*p+this._y*f,this._z=r*p+this._z*f,this._onChangeCallback(),this}slerpQuaternions(e,t,i){this.copy(e).slerp(t,i)}random(){const e=Math.random(),t=Math.sqrt(1-e),i=Math.sqrt(e),n=2*Math.PI*Math.random(),r=2*Math.PI*Math.random();return this.set(t*Math.cos(n),i*Math.sin(r),i*Math.cos(r),t*Math.sin(n))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}oi.prototype.isQuaternion=!0;class C{constructor(e=0,t=0,i=0){this.x=e,this.y=t,this.z=i}set(e,t,i){return i===void 0&&(i=this.z),this.x=e,this.y=t,this.z=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,t)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(Vn.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(Vn.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,i=this.y,n=this.z,r=e.elements;return this.x=r[0]*t+r[3]*i+r[6]*n,this.y=r[1]*t+r[4]*i+r[7]*n,this.z=r[2]*t+r[5]*i+r[8]*n,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,i=this.y,n=this.z,r=e.elements,s=1/(r[3]*t+r[7]*i+r[11]*n+r[15]);return this.x=(r[0]*t+r[4]*i+r[8]*n+r[12])*s,this.y=(r[1]*t+r[5]*i+r[9]*n+r[13])*s,this.z=(r[2]*t+r[6]*i+r[10]*n+r[14])*s,this}applyQuaternion(e){const t=this.x,i=this.y,n=this.z,r=e.x,s=e.y,o=e.z,c=e.w,l=c*t+s*n-o*i,h=c*i+o*t-r*n,p=c*n+r*i-s*t,f=-r*t-s*i-o*n;return this.x=l*c+f*-r+h*-o-p*-s,this.y=h*c+f*-s+p*-r-l*-o,this.z=p*c+f*-o+l*-s-h*-r,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,i=this.y,n=this.z,r=e.elements;return this.x=r[0]*t+r[4]*i+r[8]*n,this.y=r[1]*t+r[5]*i+r[9]*n,this.z=r[2]*t+r[6]*i+r[10]*n,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(e,Math.min(t,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this.z=e.z+(t.z-e.z)*i,this}cross(e,t){return t!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,t)):this.crossVectors(this,e)}crossVectors(e,t){const i=e.x,n=e.y,r=e.z,s=t.x,o=t.y,c=t.z;return this.x=n*c-r*o,this.y=r*s-i*c,this.z=i*o-n*s,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const i=e.dot(this)/t;return this.copy(e).multiplyScalar(i)}projectOnPlane(e){return Ji.copy(this).projectOnVector(e),this.sub(Ji)}reflect(e){return this.sub(Ji.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const i=this.dot(e)/t;return Math.acos(st(i,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,i=this.y-e.y,n=this.z-e.z;return t*t+i*i+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,i){const n=Math.sin(t)*e;return this.x=n*Math.sin(i),this.y=Math.cos(t)*e,this.z=n*Math.cos(i),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,i){return this.x=e*Math.sin(t),this.y=i,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),i=this.setFromMatrixColumn(e,1).length(),n=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=i,this.z=n,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t,i){return i!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=(Math.random()-.5)*2,t=Math.random()*Math.PI*2,i=Math.sqrt(1-e**2);return this.x=i*Math.cos(t),this.y=i*Math.sin(t),this.z=e,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}C.prototype.isVector3=!0;const Ji=new C,Vn=new oi;class li{constructor(e=new C(1/0,1/0,1/0),t=new C(-1/0,-1/0,-1/0)){this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,i=1/0,n=1/0,r=-1/0,s=-1/0,o=-1/0;for(let c=0,l=e.length;c<l;c+=3){const h=e[c],p=e[c+1],f=e[c+2];h<t&&(t=h),p<i&&(i=p),f<n&&(n=f),h>r&&(r=h),p>s&&(s=p),f>o&&(o=f)}return this.min.set(t,i,n),this.max.set(r,s,o),this}setFromBufferAttribute(e){let t=1/0,i=1/0,n=1/0,r=-1/0,s=-1/0,o=-1/0;for(let c=0,l=e.count;c<l;c++){const h=e.getX(c),p=e.getY(c),f=e.getZ(c);h<t&&(t=h),p<i&&(i=p),f<n&&(n=f),h>r&&(r=h),p>s&&(s=p),f>o&&(o=f)}return this.min.set(t,i,n),this.max.set(r,s,o),this}setFromPoints(e){this.makeEmpty();for(let t=0,i=e.length;t<i;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const i=pi.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(i),this.max.copy(e).add(i),this}setFromObject(e){return this.makeEmpty(),this.expandByObject(e)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e){e.updateWorldMatrix(!1,!1);const t=e.geometry;t!==void 0&&(t.boundingBox===null&&t.computeBoundingBox(),$i.copy(t.boundingBox),$i.applyMatrix4(e.matrixWorld),this.union($i));const i=e.children;for(let n=0,r=i.length;n<r;n++)this.expandByObject(i[n]);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,pi),pi.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,i;return e.normal.x>0?(t=e.normal.x*this.min.x,i=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,i=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,i+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,i+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,i+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,i+=e.normal.z*this.min.z),t<=-e.constant&&i>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(mi),wi.subVectors(this.max,mi),kt.subVectors(e.a,mi),Wt.subVectors(e.b,mi),Ht.subVectors(e.c,mi),yt.subVectors(Wt,kt),St.subVectors(Ht,Wt),Ut.subVectors(kt,Ht);let t=[0,-yt.z,yt.y,0,-St.z,St.y,0,-Ut.z,Ut.y,yt.z,0,-yt.x,St.z,0,-St.x,Ut.z,0,-Ut.x,-yt.y,yt.x,0,-St.y,St.x,0,-Ut.y,Ut.x,0];return!Qi(t,kt,Wt,Ht,wi)||(t=[1,0,0,0,1,0,0,0,1],!Qi(t,kt,Wt,Ht,wi))?!1:(Ti.crossVectors(yt,St),t=[Ti.x,Ti.y,Ti.z],Qi(t,kt,Wt,Ht,wi))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return pi.copy(e).clamp(this.min,this.max).sub(e).length()}getBoundingSphere(e){return this.getCenter(e.center),e.radius=this.getSize(pi).length()*.5,e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(dt[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),dt[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),dt[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),dt[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),dt[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),dt[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),dt[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),dt[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(dt),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}li.prototype.isBox3=!0;const dt=[new C,new C,new C,new C,new C,new C,new C,new C],pi=new C,$i=new li,kt=new C,Wt=new C,Ht=new C,yt=new C,St=new C,Ut=new C,mi=new C,wi=new C,Ti=new C,Gt=new C;function Qi(a,e,t,i,n){for(let r=0,s=a.length-3;r<=s;r+=3){Gt.fromArray(a,r);const o=n.x*Math.abs(Gt.x)+n.y*Math.abs(Gt.y)+n.z*Math.abs(Gt.z),c=e.dot(Gt),l=t.dot(Gt),h=i.dot(Gt);if(Math.max(-Math.max(c,l,h),Math.min(c,l,h))>o)return!1}return!0}const ea=new li,kn=new C,Ki=new C,en=new C;class Tn{constructor(e=new C,t=-1){this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const i=this.center;t!==void 0?i.copy(t):ea.setFromPoints(e).getCenter(i);let n=0;for(let r=0,s=e.length;r<s;r++)n=Math.max(n,i.distanceToSquared(e[r]));return this.radius=Math.sqrt(n),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const i=this.center.distanceToSquared(e);return t.copy(e),i>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){en.subVectors(e,this.center);const t=en.lengthSq();if(t>this.radius*this.radius){const i=Math.sqrt(t),n=(i-this.radius)*.5;this.center.add(en.multiplyScalar(n/i)),this.radius+=n}return this}union(e){return Ki.subVectors(e.center,this.center).normalize().multiplyScalar(e.radius),this.expandByPoint(kn.copy(e.center).add(Ki)),this.expandByPoint(kn.copy(e.center).sub(Ki)),this}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const ft=new C,tn=new C,Ai=new C,bt=new C,nn=new C,Ei=new C,rn=new C;class ta{constructor(e=new C,t=new C(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,ft)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const i=t.dot(this.direction);return i<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(i).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=ft.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(ft.copy(this.direction).multiplyScalar(t).add(this.origin),ft.distanceToSquared(e))}distanceSqToSegment(e,t,i,n){tn.copy(e).add(t).multiplyScalar(.5),Ai.copy(t).sub(e).normalize(),bt.copy(this.origin).sub(tn);const r=e.distanceTo(t)*.5,s=-this.direction.dot(Ai),o=bt.dot(this.direction),c=-bt.dot(Ai),l=bt.lengthSq(),h=Math.abs(1-s*s);let p,f,m,_;if(h>0)if(p=s*c-o,f=s*o-c,_=r*h,p>=0)if(f>=-_)if(f<=_){const g=1/h;p*=g,f*=g,m=p*(p+s*f+2*o)+f*(s*p+f+2*c)+l}else f=r,p=Math.max(0,-(s*f+o)),m=-p*p+f*(f+2*c)+l;else f=-r,p=Math.max(0,-(s*f+o)),m=-p*p+f*(f+2*c)+l;else f<=-_?(p=Math.max(0,-(-s*r+o)),f=p>0?-r:Math.min(Math.max(-r,-c),r),m=-p*p+f*(f+2*c)+l):f<=_?(p=0,f=Math.min(Math.max(-r,-c),r),m=f*(f+2*c)+l):(p=Math.max(0,-(s*r+o)),f=p>0?r:Math.min(Math.max(-r,-c),r),m=-p*p+f*(f+2*c)+l);else f=s>0?-r:r,p=Math.max(0,-(s*f+o)),m=-p*p+f*(f+2*c)+l;return i&&i.copy(this.direction).multiplyScalar(p).add(this.origin),n&&n.copy(Ai).multiplyScalar(f).add(tn),m}intersectSphere(e,t){ft.subVectors(e.center,this.origin);const i=ft.dot(this.direction),n=ft.dot(ft)-i*i,r=e.radius*e.radius;if(n>r)return null;const s=Math.sqrt(r-n),o=i-s,c=i+s;return o<0&&c<0?null:o<0?this.at(c,t):this.at(o,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const i=-(this.origin.dot(e.normal)+e.constant)/t;return i>=0?i:null}intersectPlane(e,t){const i=this.distanceToPlane(e);return i===null?null:this.at(i,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let i,n,r,s,o,c;const l=1/this.direction.x,h=1/this.direction.y,p=1/this.direction.z,f=this.origin;return l>=0?(i=(e.min.x-f.x)*l,n=(e.max.x-f.x)*l):(i=(e.max.x-f.x)*l,n=(e.min.x-f.x)*l),h>=0?(r=(e.min.y-f.y)*h,s=(e.max.y-f.y)*h):(r=(e.max.y-f.y)*h,s=(e.min.y-f.y)*h),i>s||r>n||((r>i||i!==i)&&(i=r),(s<n||n!==n)&&(n=s),p>=0?(o=(e.min.z-f.z)*p,c=(e.max.z-f.z)*p):(o=(e.max.z-f.z)*p,c=(e.min.z-f.z)*p),i>c||o>n)||((o>i||i!==i)&&(i=o),(c<n||n!==n)&&(n=c),n<0)?null:this.at(i>=0?i:n,t)}intersectsBox(e){return this.intersectBox(e,ft)!==null}intersectTriangle(e,t,i,n,r){nn.subVectors(t,e),Ei.subVectors(i,e),rn.crossVectors(nn,Ei);let s=this.direction.dot(rn),o;if(s>0){if(n)return null;o=1}else if(s<0)o=-1,s=-s;else return null;bt.subVectors(this.origin,e);const c=o*this.direction.dot(Ei.crossVectors(bt,Ei));if(c<0)return null;const l=o*this.direction.dot(nn.cross(bt));if(l<0||c+l>s)return null;const h=-o*bt.dot(rn);return h<0?null:this.at(h/s,r)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class ze{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(e,t,i,n,r,s,o,c,l,h,p,f,m,_,g,b){const u=this.elements;return u[0]=e,u[4]=t,u[8]=i,u[12]=n,u[1]=r,u[5]=s,u[9]=o,u[13]=c,u[2]=l,u[6]=h,u[10]=p,u[14]=f,u[3]=m,u[7]=_,u[11]=g,u[15]=b,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new ze().fromArray(this.elements)}copy(e){const t=this.elements,i=e.elements;return t[0]=i[0],t[1]=i[1],t[2]=i[2],t[3]=i[3],t[4]=i[4],t[5]=i[5],t[6]=i[6],t[7]=i[7],t[8]=i[8],t[9]=i[9],t[10]=i[10],t[11]=i[11],t[12]=i[12],t[13]=i[13],t[14]=i[14],t[15]=i[15],this}copyPosition(e){const t=this.elements,i=e.elements;return t[12]=i[12],t[13]=i[13],t[14]=i[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,i){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(e,t,i){return this.set(e.x,t.x,i.x,0,e.y,t.y,i.y,0,e.z,t.z,i.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,i=e.elements,n=1/qt.setFromMatrixColumn(e,0).length(),r=1/qt.setFromMatrixColumn(e,1).length(),s=1/qt.setFromMatrixColumn(e,2).length();return t[0]=i[0]*n,t[1]=i[1]*n,t[2]=i[2]*n,t[3]=0,t[4]=i[4]*r,t[5]=i[5]*r,t[6]=i[6]*r,t[7]=0,t[8]=i[8]*s,t[9]=i[9]*s,t[10]=i[10]*s,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const t=this.elements,i=e.x,n=e.y,r=e.z,s=Math.cos(i),o=Math.sin(i),c=Math.cos(n),l=Math.sin(n),h=Math.cos(r),p=Math.sin(r);if(e.order==="XYZ"){const f=s*h,m=s*p,_=o*h,g=o*p;t[0]=c*h,t[4]=-c*p,t[8]=l,t[1]=m+_*l,t[5]=f-g*l,t[9]=-o*c,t[2]=g-f*l,t[6]=_+m*l,t[10]=s*c}else if(e.order==="YXZ"){const f=c*h,m=c*p,_=l*h,g=l*p;t[0]=f+g*o,t[4]=_*o-m,t[8]=s*l,t[1]=s*p,t[5]=s*h,t[9]=-o,t[2]=m*o-_,t[6]=g+f*o,t[10]=s*c}else if(e.order==="ZXY"){const f=c*h,m=c*p,_=l*h,g=l*p;t[0]=f-g*o,t[4]=-s*p,t[8]=_+m*o,t[1]=m+_*o,t[5]=s*h,t[9]=g-f*o,t[2]=-s*l,t[6]=o,t[10]=s*c}else if(e.order==="ZYX"){const f=s*h,m=s*p,_=o*h,g=o*p;t[0]=c*h,t[4]=_*l-m,t[8]=f*l+g,t[1]=c*p,t[5]=g*l+f,t[9]=m*l-_,t[2]=-l,t[6]=o*c,t[10]=s*c}else if(e.order==="YZX"){const f=s*c,m=s*l,_=o*c,g=o*l;t[0]=c*h,t[4]=g-f*p,t[8]=_*p+m,t[1]=p,t[5]=s*h,t[9]=-o*h,t[2]=-l*h,t[6]=m*p+_,t[10]=f-g*p}else if(e.order==="XZY"){const f=s*c,m=s*l,_=o*c,g=o*l;t[0]=c*h,t[4]=-p,t[8]=l*h,t[1]=f*p+g,t[5]=s*h,t[9]=m*p-_,t[2]=_*p-m,t[6]=o*h,t[10]=g*p+f}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(ia,e,na)}lookAt(e,t,i){const n=this.elements;return qe.subVectors(e,t),qe.lengthSq()===0&&(qe.z=1),qe.normalize(),wt.crossVectors(i,qe),wt.lengthSq()===0&&(Math.abs(i.z)===1?qe.x+=1e-4:qe.z+=1e-4,qe.normalize(),wt.crossVectors(i,qe)),wt.normalize(),Li.crossVectors(qe,wt),n[0]=wt.x,n[4]=Li.x,n[8]=qe.x,n[1]=wt.y,n[5]=Li.y,n[9]=qe.y,n[2]=wt.z,n[6]=Li.z,n[10]=qe.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const i=e.elements,n=t.elements,r=this.elements,s=i[0],o=i[4],c=i[8],l=i[12],h=i[1],p=i[5],f=i[9],m=i[13],_=i[2],g=i[6],b=i[10],u=i[14],d=i[3],T=i[7],M=i[11],w=i[15],E=n[0],v=n[4],U=n[8],q=n[12],O=n[1],L=n[5],j=n[9],I=n[13],z=n[2],G=n[6],N=n[10],B=n[14],Y=n[3],ne=n[7],oe=n[11],te=n[15];return r[0]=s*E+o*O+c*z+l*Y,r[4]=s*v+o*L+c*G+l*ne,r[8]=s*U+o*j+c*N+l*oe,r[12]=s*q+o*I+c*B+l*te,r[1]=h*E+p*O+f*z+m*Y,r[5]=h*v+p*L+f*G+m*ne,r[9]=h*U+p*j+f*N+m*oe,r[13]=h*q+p*I+f*B+m*te,r[2]=_*E+g*O+b*z+u*Y,r[6]=_*v+g*L+b*G+u*ne,r[10]=_*U+g*j+b*N+u*oe,r[14]=_*q+g*I+b*B+u*te,r[3]=d*E+T*O+M*z+w*Y,r[7]=d*v+T*L+M*G+w*ne,r[11]=d*U+T*j+M*N+w*oe,r[15]=d*q+T*I+M*B+w*te,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],i=e[4],n=e[8],r=e[12],s=e[1],o=e[5],c=e[9],l=e[13],h=e[2],p=e[6],f=e[10],m=e[14],_=e[3],g=e[7],b=e[11],u=e[15];return _*(+r*c*p-n*l*p-r*o*f+i*l*f+n*o*m-i*c*m)+g*(+t*c*m-t*l*f+r*s*f-n*s*m+n*l*h-r*c*h)+b*(+t*l*p-t*o*m-r*s*p+i*s*m+r*o*h-i*l*h)+u*(-n*o*h-t*c*p+t*o*f+n*s*p-i*s*f+i*c*h)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,i){const n=this.elements;return e.isVector3?(n[12]=e.x,n[13]=e.y,n[14]=e.z):(n[12]=e,n[13]=t,n[14]=i),this}invert(){const e=this.elements,t=e[0],i=e[1],n=e[2],r=e[3],s=e[4],o=e[5],c=e[6],l=e[7],h=e[8],p=e[9],f=e[10],m=e[11],_=e[12],g=e[13],b=e[14],u=e[15],d=p*b*l-g*f*l+g*c*m-o*b*m-p*c*u+o*f*u,T=_*f*l-h*b*l-_*c*m+s*b*m+h*c*u-s*f*u,M=h*g*l-_*p*l+_*o*m-s*g*m-h*o*u+s*p*u,w=_*p*c-h*g*c-_*o*f+s*g*f+h*o*b-s*p*b,E=t*d+i*T+n*M+r*w;if(E===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const v=1/E;return e[0]=d*v,e[1]=(g*f*r-p*b*r-g*n*m+i*b*m+p*n*u-i*f*u)*v,e[2]=(o*b*r-g*c*r+g*n*l-i*b*l-o*n*u+i*c*u)*v,e[3]=(p*c*r-o*f*r-p*n*l+i*f*l+o*n*m-i*c*m)*v,e[4]=T*v,e[5]=(h*b*r-_*f*r+_*n*m-t*b*m-h*n*u+t*f*u)*v,e[6]=(_*c*r-s*b*r-_*n*l+t*b*l+s*n*u-t*c*u)*v,e[7]=(s*f*r-h*c*r+h*n*l-t*f*l-s*n*m+t*c*m)*v,e[8]=M*v,e[9]=(_*p*r-h*g*r-_*i*m+t*g*m+h*i*u-t*p*u)*v,e[10]=(s*g*r-_*o*r+_*i*l-t*g*l-s*i*u+t*o*u)*v,e[11]=(h*o*r-s*p*r-h*i*l+t*p*l+s*i*m-t*o*m)*v,e[12]=w*v,e[13]=(h*g*n-_*p*n+_*i*f-t*g*f-h*i*b+t*p*b)*v,e[14]=(_*o*n-s*g*n-_*i*c+t*g*c+s*i*b-t*o*b)*v,e[15]=(s*p*n-h*o*n+h*i*c-t*p*c-s*i*f+t*o*f)*v,this}scale(e){const t=this.elements,i=e.x,n=e.y,r=e.z;return t[0]*=i,t[4]*=n,t[8]*=r,t[1]*=i,t[5]*=n,t[9]*=r,t[2]*=i,t[6]*=n,t[10]*=r,t[3]*=i,t[7]*=n,t[11]*=r,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],i=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],n=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,i,n))}makeTranslation(e,t,i){return this.set(1,0,0,e,0,1,0,t,0,0,1,i,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),i=Math.sin(e);return this.set(1,0,0,0,0,t,-i,0,0,i,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),i=Math.sin(e);return this.set(t,0,i,0,0,1,0,0,-i,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),i=Math.sin(e);return this.set(t,-i,0,0,i,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const i=Math.cos(t),n=Math.sin(t),r=1-i,s=e.x,o=e.y,c=e.z,l=r*s,h=r*o;return this.set(l*s+i,l*o-n*c,l*c+n*o,0,l*o+n*c,h*o+i,h*c-n*s,0,l*c-n*o,h*c+n*s,r*c*c+i,0,0,0,0,1),this}makeScale(e,t,i){return this.set(e,0,0,0,0,t,0,0,0,0,i,0,0,0,0,1),this}makeShear(e,t,i,n,r,s){return this.set(1,i,r,0,e,1,s,0,t,n,1,0,0,0,0,1),this}compose(e,t,i){const n=this.elements,r=t._x,s=t._y,o=t._z,c=t._w,l=r+r,h=s+s,p=o+o,f=r*l,m=r*h,_=r*p,g=s*h,b=s*p,u=o*p,d=c*l,T=c*h,M=c*p,w=i.x,E=i.y,v=i.z;return n[0]=(1-(g+u))*w,n[1]=(m+M)*w,n[2]=(_-T)*w,n[3]=0,n[4]=(m-M)*E,n[5]=(1-(f+u))*E,n[6]=(b+d)*E,n[7]=0,n[8]=(_+T)*v,n[9]=(b-d)*v,n[10]=(1-(f+g))*v,n[11]=0,n[12]=e.x,n[13]=e.y,n[14]=e.z,n[15]=1,this}decompose(e,t,i){const n=this.elements;let r=qt.set(n[0],n[1],n[2]).length();const s=qt.set(n[4],n[5],n[6]).length(),o=qt.set(n[8],n[9],n[10]).length();this.determinant()<0&&(r=-r),e.x=n[12],e.y=n[13],e.z=n[14],Ke.copy(this);const l=1/r,h=1/s,p=1/o;return Ke.elements[0]*=l,Ke.elements[1]*=l,Ke.elements[2]*=l,Ke.elements[4]*=h,Ke.elements[5]*=h,Ke.elements[6]*=h,Ke.elements[8]*=p,Ke.elements[9]*=p,Ke.elements[10]*=p,t.setFromRotationMatrix(Ke),i.x=r,i.y=s,i.z=o,this}makePerspective(e,t,i,n,r,s){s===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const o=this.elements,c=2*r/(t-e),l=2*r/(i-n),h=(t+e)/(t-e),p=(i+n)/(i-n),f=-(s+r)/(s-r),m=-2*s*r/(s-r);return o[0]=c,o[4]=0,o[8]=h,o[12]=0,o[1]=0,o[5]=l,o[9]=p,o[13]=0,o[2]=0,o[6]=0,o[10]=f,o[14]=m,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(e,t,i,n,r,s){const o=this.elements,c=1/(t-e),l=1/(i-n),h=1/(s-r),p=(t+e)*c,f=(i+n)*l,m=(s+r)*h;return o[0]=2*c,o[4]=0,o[8]=0,o[12]=-p,o[1]=0,o[5]=2*l,o[9]=0,o[13]=-f,o[2]=0,o[6]=0,o[10]=-2*h,o[14]=-m,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(e){const t=this.elements,i=e.elements;for(let n=0;n<16;n++)if(t[n]!==i[n])return!1;return!0}fromArray(e,t=0){for(let i=0;i<16;i++)this.elements[i]=e[i+t];return this}toArray(e=[],t=0){const i=this.elements;return e[t]=i[0],e[t+1]=i[1],e[t+2]=i[2],e[t+3]=i[3],e[t+4]=i[4],e[t+5]=i[5],e[t+6]=i[6],e[t+7]=i[7],e[t+8]=i[8],e[t+9]=i[9],e[t+10]=i[10],e[t+11]=i[11],e[t+12]=i[12],e[t+13]=i[13],e[t+14]=i[14],e[t+15]=i[15],e}}ze.prototype.isMatrix4=!0;const qt=new C,Ke=new ze,ia=new C(0,0,0),na=new C(1,1,1),wt=new C,Li=new C,qe=new C,Wn=new ze,Hn=new oi;class ci{constructor(e=0,t=0,i=0,n=ci.DefaultOrder){this._x=e,this._y=t,this._z=i,this._order=n}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,i,n=this._order){return this._x=e,this._y=t,this._z=i,this._order=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,i=!0){const n=e.elements,r=n[0],s=n[4],o=n[8],c=n[1],l=n[5],h=n[9],p=n[2],f=n[6],m=n[10];switch(t){case"XYZ":this._y=Math.asin(st(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-h,m),this._z=Math.atan2(-s,r)):(this._x=Math.atan2(f,l),this._z=0);break;case"YXZ":this._x=Math.asin(-st(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(o,m),this._z=Math.atan2(c,l)):(this._y=Math.atan2(-p,r),this._z=0);break;case"ZXY":this._x=Math.asin(st(f,-1,1)),Math.abs(f)<.9999999?(this._y=Math.atan2(-p,m),this._z=Math.atan2(-s,l)):(this._y=0,this._z=Math.atan2(c,r));break;case"ZYX":this._y=Math.asin(-st(p,-1,1)),Math.abs(p)<.9999999?(this._x=Math.atan2(f,m),this._z=Math.atan2(c,r)):(this._x=0,this._z=Math.atan2(-s,l));break;case"YZX":this._z=Math.asin(st(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(-h,l),this._y=Math.atan2(-p,r)):(this._x=0,this._y=Math.atan2(o,m));break;case"XZY":this._z=Math.asin(-st(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(f,l),this._y=Math.atan2(o,r)):(this._x=Math.atan2(-h,m),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,i===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,i){return Wn.makeRotationFromQuaternion(e),this.setFromRotationMatrix(Wn,t,i)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return Hn.setFromEuler(this),this.setFromQuaternion(Hn,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}toVector3(e){return e?e.set(this._x,this._y,this._z):new C(this._x,this._y,this._z)}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}ci.prototype.isEuler=!0;ci.DefaultOrder="XYZ";ci.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class ra{constructor(){this.mask=1}set(e){this.mask=1<<e|0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}}let aa=0;const qn=new C,Xt=new oi,pt=new ze,Ci=new C,gi=new C,sa=new C,oa=new oi,Xn=new C(1,0,0),Yn=new C(0,1,0),Zn=new C(0,0,1),la={type:"added"},jn={type:"removed"};class Je extends si{constructor(){super(),Object.defineProperty(this,"id",{value:aa++}),this.uuid=yi(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Je.DefaultUp.clone();const e=new C,t=new ci,i=new oi,n=new C(1,1,1);function r(){i.setFromEuler(t,!1)}function s(){t.setFromQuaternion(i,void 0,!1)}t._onChange(r),i._onChange(s),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:i},scale:{configurable:!0,enumerable:!0,value:n},modelViewMatrix:{value:new ze},normalMatrix:{value:new nt}}),this.matrix=new ze,this.matrixWorld=new ze,this.matrixAutoUpdate=Je.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new ra,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return Xt.setFromAxisAngle(e,t),this.quaternion.multiply(Xt),this}rotateOnWorldAxis(e,t){return Xt.setFromAxisAngle(e,t),this.quaternion.premultiply(Xt),this}rotateX(e){return this.rotateOnAxis(Xn,e)}rotateY(e){return this.rotateOnAxis(Yn,e)}rotateZ(e){return this.rotateOnAxis(Zn,e)}translateOnAxis(e,t){return qn.copy(e).applyQuaternion(this.quaternion),this.position.add(qn.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(Xn,e)}translateY(e){return this.translateOnAxis(Yn,e)}translateZ(e){return this.translateOnAxis(Zn,e)}localToWorld(e){return e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return e.applyMatrix4(pt.copy(this.matrixWorld).invert())}lookAt(e,t,i){e.isVector3?Ci.copy(e):Ci.set(e,t,i);const n=this.parent;this.updateWorldMatrix(!0,!1),gi.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?pt.lookAt(gi,Ci,this.up):pt.lookAt(Ci,gi,this.up),this.quaternion.setFromRotationMatrix(pt),n&&(pt.extractRotation(n.matrixWorld),Xt.setFromRotationMatrix(pt),this.quaternion.premultiply(Xt.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(la)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let i=0;i<arguments.length;i++)this.remove(arguments[i]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(jn)),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){for(let e=0;e<this.children.length;e++){const t=this.children[e];t.parent=null,t.dispatchEvent(jn)}return this.children.length=0,this}attach(e){return this.updateWorldMatrix(!0,!1),pt.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),pt.multiply(e.parent.matrixWorld)),e.applyMatrix4(pt),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let i=0,n=this.children.length;i<n;i++){const s=this.children[i].getObjectByProperty(e,t);if(s!==void 0)return s}}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(gi,e,sa),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(gi,oa,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let i=0,n=t.length;i<n;i++)t[i].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let i=0,n=t.length;i<n;i++)t[i].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let i=0,n=t.length;i<n;i++)t[i].updateMatrixWorld(e)}updateWorldMatrix(e,t){const i=this.parent;if(e===!0&&i!==null&&i.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const n=this.children;for(let r=0,s=n.length;r<s;r++)n[r].updateWorldMatrix(!1,!0)}}toJSON(e){const t=e===void 0||typeof e=="string",i={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},i.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const n={};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.castShadow===!0&&(n.castShadow=!0),this.receiveShadow===!0&&(n.receiveShadow=!0),this.visible===!1&&(n.visible=!1),this.frustumCulled===!1&&(n.frustumCulled=!1),this.renderOrder!==0&&(n.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData),n.layers=this.layers.mask,n.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(n.matrixAutoUpdate=!1),this.isInstancedMesh&&(n.type="InstancedMesh",n.count=this.count,n.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(n.instanceColor=this.instanceColor.toJSON()));function r(o,c){return o[c.uuid]===void 0&&(o[c.uuid]=c.toJSON(e)),c.uuid}if(this.isScene)this.background&&(this.background.isColor?n.background=this.background.toJSON():this.background.isTexture&&(n.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&(n.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){n.geometry=r(e.geometries,this.geometry);const o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){const c=o.shapes;if(Array.isArray(c))for(let l=0,h=c.length;l<h;l++){const p=c[l];r(e.shapes,p)}else r(e.shapes,c)}}if(this.isSkinnedMesh&&(n.bindMode=this.bindMode,n.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(e.skeletons,this.skeleton),n.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const o=[];for(let c=0,l=this.material.length;c<l;c++)o.push(r(e.materials,this.material[c]));n.material=o}else n.material=r(e.materials,this.material);if(this.children.length>0){n.children=[];for(let o=0;o<this.children.length;o++)n.children.push(this.children[o].toJSON(e).object)}if(this.animations.length>0){n.animations=[];for(let o=0;o<this.animations.length;o++){const c=this.animations[o];n.animations.push(r(e.animations,c))}}if(t){const o=s(e.geometries),c=s(e.materials),l=s(e.textures),h=s(e.images),p=s(e.shapes),f=s(e.skeletons),m=s(e.animations);o.length>0&&(i.geometries=o),c.length>0&&(i.materials=c),l.length>0&&(i.textures=l),h.length>0&&(i.images=h),p.length>0&&(i.shapes=p),f.length>0&&(i.skeletons=f),m.length>0&&(i.animations=m)}return i.object=n,i;function s(o){const c=[];for(const l in o){const h=o[l];delete h.metadata,c.push(h)}return c}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let i=0;i<e.children.length;i++){const n=e.children[i];this.add(n.clone())}return this}}Je.DefaultUp=new C(0,1,0);Je.DefaultMatrixAutoUpdate=!0;Je.prototype.isObject3D=!0;const et=new C,mt=new C,an=new C,gt=new C,Yt=new C,Zt=new C,Jn=new C,sn=new C,on=new C,ln=new C;class _t{constructor(e=new C,t=new C,i=new C){this.a=e,this.b=t,this.c=i}static getNormal(e,t,i,n){n.subVectors(i,t),et.subVectors(e,t),n.cross(et);const r=n.lengthSq();return r>0?n.multiplyScalar(1/Math.sqrt(r)):n.set(0,0,0)}static getBarycoord(e,t,i,n,r){et.subVectors(n,t),mt.subVectors(i,t),an.subVectors(e,t);const s=et.dot(et),o=et.dot(mt),c=et.dot(an),l=mt.dot(mt),h=mt.dot(an),p=s*l-o*o;if(p===0)return r.set(-2,-1,-1);const f=1/p,m=(l*c-o*h)*f,_=(s*h-o*c)*f;return r.set(1-m-_,_,m)}static containsPoint(e,t,i,n){return this.getBarycoord(e,t,i,n,gt),gt.x>=0&&gt.y>=0&&gt.x+gt.y<=1}static getUV(e,t,i,n,r,s,o,c){return this.getBarycoord(e,t,i,n,gt),c.set(0,0),c.addScaledVector(r,gt.x),c.addScaledVector(s,gt.y),c.addScaledVector(o,gt.z),c}static isFrontFacing(e,t,i,n){return et.subVectors(i,t),mt.subVectors(e,t),et.cross(mt).dot(n)<0}set(e,t,i){return this.a.copy(e),this.b.copy(t),this.c.copy(i),this}setFromPointsAndIndices(e,t,i,n){return this.a.copy(e[t]),this.b.copy(e[i]),this.c.copy(e[n]),this}setFromAttributeAndIndices(e,t,i,n){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,i),this.c.fromBufferAttribute(e,n),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return et.subVectors(this.c,this.b),mt.subVectors(this.a,this.b),et.cross(mt).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return _t.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return _t.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,i,n,r){return _t.getUV(e,this.a,this.b,this.c,t,i,n,r)}containsPoint(e){return _t.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return _t.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const i=this.a,n=this.b,r=this.c;let s,o;Yt.subVectors(n,i),Zt.subVectors(r,i),sn.subVectors(e,i);const c=Yt.dot(sn),l=Zt.dot(sn);if(c<=0&&l<=0)return t.copy(i);on.subVectors(e,n);const h=Yt.dot(on),p=Zt.dot(on);if(h>=0&&p<=h)return t.copy(n);const f=c*p-h*l;if(f<=0&&c>=0&&h<=0)return s=c/(c-h),t.copy(i).addScaledVector(Yt,s);ln.subVectors(e,r);const m=Yt.dot(ln),_=Zt.dot(ln);if(_>=0&&m<=_)return t.copy(r);const g=m*l-c*_;if(g<=0&&l>=0&&_<=0)return o=l/(l-_),t.copy(i).addScaledVector(Zt,o);const b=h*_-m*p;if(b<=0&&p-h>=0&&m-_>=0)return Jn.subVectors(r,n),o=(p-h)/(p-h+(m-_)),t.copy(n).addScaledVector(Jn,o);const u=1/(b+g+f);return s=g*u,o=f*u,t.copy(i).addScaledVector(Yt,s).addScaledVector(Zt,o)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}let ca=0;class Si extends si{constructor(){super(),Object.defineProperty(this,"id",{value:ca++}),this.uuid=yi(),this.name="",this.type="Material",this.fog=!0,this.blending=1,this.side=0,this.vertexColors=!1,this.opacity=1,this.format=1023,this.transparent=!1,this.blendSrc=204,this.blendDst=205,this.blendEquation=100,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=7680,this.stencilZFail=7680,this.stencilZPass=7680,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const i=e[t];if(i===void 0){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}if(t==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=i===1;continue}const n=this[t];if(n===void 0){console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.");continue}n&&n.isColor?n.set(i):n&&n.isVector3&&i&&i.isVector3?n.copy(i):this[t]=i}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const i={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.color&&this.color.isColor&&(i.color=this.color.getHex()),this.roughness!==void 0&&(i.roughness=this.roughness),this.metalness!==void 0&&(i.metalness=this.metalness),this.sheen!==void 0&&(i.sheen=this.sheen),this.sheenTint&&this.sheenTint.isColor&&(i.sheenTint=this.sheenTint.getHex()),this.sheenRoughness!==void 0&&(i.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(i.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(i.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(i.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(i.specularIntensity=this.specularIntensity),this.specularTint&&this.specularTint.isColor&&(i.specularTint=this.specularTint.getHex()),this.shininess!==void 0&&(i.shininess=this.shininess),this.clearcoat!==void 0&&(i.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(i.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(i.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(i.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,i.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(i.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(i.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(i.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(i.lightMap=this.lightMap.toJSON(e).uuid,i.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(i.aoMap=this.aoMap.toJSON(e).uuid,i.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(i.bumpMap=this.bumpMap.toJSON(e).uuid,i.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(i.normalMap=this.normalMap.toJSON(e).uuid,i.normalMapType=this.normalMapType,i.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(i.displacementMap=this.displacementMap.toJSON(e).uuid,i.displacementScale=this.displacementScale,i.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(i.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(i.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(i.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(i.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(i.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularTintMap&&this.specularTintMap.isTexture&&(i.specularTintMap=this.specularTintMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(i.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(i.combine=this.combine)),this.envMapIntensity!==void 0&&(i.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(i.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(i.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(i.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(i.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(i.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(i.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(i.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&(i.attenuationDistance=this.attenuationDistance),this.attenuationTint!==void 0&&(i.attenuationTint=this.attenuationTint.getHex()),this.size!==void 0&&(i.size=this.size),this.shadowSide!==null&&(i.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(i.sizeAttenuation=this.sizeAttenuation),this.blending!==1&&(i.blending=this.blending),this.side!==0&&(i.side=this.side),this.vertexColors&&(i.vertexColors=!0),this.opacity<1&&(i.opacity=this.opacity),this.format!==1023&&(i.format=this.format),this.transparent===!0&&(i.transparent=this.transparent),i.depthFunc=this.depthFunc,i.depthTest=this.depthTest,i.depthWrite=this.depthWrite,i.colorWrite=this.colorWrite,i.stencilWrite=this.stencilWrite,i.stencilWriteMask=this.stencilWriteMask,i.stencilFunc=this.stencilFunc,i.stencilRef=this.stencilRef,i.stencilFuncMask=this.stencilFuncMask,i.stencilFail=this.stencilFail,i.stencilZFail=this.stencilZFail,i.stencilZPass=this.stencilZPass,this.rotation&&this.rotation!==0&&(i.rotation=this.rotation),this.polygonOffset===!0&&(i.polygonOffset=!0),this.polygonOffsetFactor!==0&&(i.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(i.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&this.linewidth!==1&&(i.linewidth=this.linewidth),this.dashSize!==void 0&&(i.dashSize=this.dashSize),this.gapSize!==void 0&&(i.gapSize=this.gapSize),this.scale!==void 0&&(i.scale=this.scale),this.dithering===!0&&(i.dithering=!0),this.alphaTest>0&&(i.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(i.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(i.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(i.wireframe=this.wireframe),this.wireframeLinewidth>1&&(i.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(i.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(i.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(i.flatShading=this.flatShading),this.visible===!1&&(i.visible=!1),this.toneMapped===!1&&(i.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData);function n(r){const s=[];for(const o in r){const c=r[o];delete c.metadata,s.push(c)}return s}if(t){const r=n(e.textures),s=n(e.images);r.length>0&&(i.textures=r),s.length>0&&(i.images=s)}return i}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.fog=e.fog,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.format=e.format,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let i=null;if(t!==null){const n=t.length;i=new Array(n);for(let r=0;r!==n;++r)i[r]=t[r].clone()}return this.clippingPlanes=i,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}Si.prototype.isMaterial=!0;const Sr={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},tt={h:0,s:0,l:0},Ri={h:0,s:0,l:0};function cn(a,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?a+(e-a)*6*t:t<1/2?e:t<2/3?a+(e-a)*6*(2/3-t):a}function un(a){return a<.04045?a*.0773993808:Math.pow(a*.9478672986+.0521327014,2.4)}function hn(a){return a<.0031308?a*12.92:1.055*Math.pow(a,.41666)-.055}class Ee{constructor(e,t,i){return t===void 0&&i===void 0?this.set(e):this.setRGB(e,t,i)}set(e){return e&&e.isColor?this.copy(e):typeof e=="number"?this.setHex(e):typeof e=="string"&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,this}setRGB(e,t,i){return this.r=e,this.g=t,this.b=i,this}setHSL(e,t,i){if(e=jr(e,1),t=st(t,0,1),i=st(i,0,1),t===0)this.r=this.g=this.b=i;else{const n=i<=.5?i*(1+t):i+t-i*t,r=2*i-n;this.r=cn(r,n,e+1/3),this.g=cn(r,n,e),this.b=cn(r,n,e-1/3)}return this}setStyle(e){function t(n){n!==void 0&&parseFloat(n)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let i;if(i=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let n;const r=i[1],s=i[2];switch(r){case"rgb":case"rgba":if(n=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return this.r=Math.min(255,parseInt(n[1],10))/255,this.g=Math.min(255,parseInt(n[2],10))/255,this.b=Math.min(255,parseInt(n[3],10))/255,t(n[4]),this;if(n=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return this.r=Math.min(100,parseInt(n[1],10))/100,this.g=Math.min(100,parseInt(n[2],10))/100,this.b=Math.min(100,parseInt(n[3],10))/100,t(n[4]),this;break;case"hsl":case"hsla":if(n=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)){const o=parseFloat(n[1])/360,c=parseInt(n[2],10)/100,l=parseInt(n[3],10)/100;return t(n[4]),this.setHSL(o,c,l)}break}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(e)){const n=i[1],r=n.length;if(r===3)return this.r=parseInt(n.charAt(0)+n.charAt(0),16)/255,this.g=parseInt(n.charAt(1)+n.charAt(1),16)/255,this.b=parseInt(n.charAt(2)+n.charAt(2),16)/255,this;if(r===6)return this.r=parseInt(n.charAt(0)+n.charAt(1),16)/255,this.g=parseInt(n.charAt(2)+n.charAt(3),16)/255,this.b=parseInt(n.charAt(4)+n.charAt(5),16)/255,this}return e&&e.length>0?this.setColorName(e):this}setColorName(e){const t=Sr[e.toLowerCase()];return t!==void 0?this.setHex(t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copyGammaToLinear(e,t=2){return this.r=Math.pow(e.r,t),this.g=Math.pow(e.g,t),this.b=Math.pow(e.b,t),this}copyLinearToGamma(e,t=2){const i=t>0?1/t:1;return this.r=Math.pow(e.r,i),this.g=Math.pow(e.g,i),this.b=Math.pow(e.b,i),this}convertGammaToLinear(e){return this.copyGammaToLinear(this,e),this}convertLinearToGamma(e){return this.copyLinearToGamma(this,e),this}copySRGBToLinear(e){return this.r=un(e.r),this.g=un(e.g),this.b=un(e.b),this}copyLinearToSRGB(e){return this.r=hn(e.r),this.g=hn(e.g),this.b=hn(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(e){const t=this.r,i=this.g,n=this.b,r=Math.max(t,i,n),s=Math.min(t,i,n);let o,c;const l=(s+r)/2;if(s===r)o=0,c=0;else{const h=r-s;switch(c=l<=.5?h/(r+s):h/(2-r-s),r){case t:o=(i-n)/h+(i<n?6:0);break;case i:o=(n-t)/h+2;break;case n:o=(t-i)/h+4;break}o/=6}return e.h=o,e.s=c,e.l=l,e}getStyle(){return"rgb("+(this.r*255|0)+","+(this.g*255|0)+","+(this.b*255|0)+")"}offsetHSL(e,t,i){return this.getHSL(tt),tt.h+=e,tt.s+=t,tt.l+=i,this.setHSL(tt.h,tt.s,tt.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,i){return this.r=e.r+(t.r-e.r)*i,this.g=e.g+(t.g-e.g)*i,this.b=e.b+(t.b-e.b)*i,this}lerpHSL(e,t){this.getHSL(tt),e.getHSL(Ri);const i=Zi(tt.h,Ri.h,t),n=Zi(tt.s,Ri.s,t),r=Zi(tt.l,Ri.l,t);return this.setHSL(i,n,r),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),e.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}Ee.NAMES=Sr;Ee.prototype.isColor=!0;Ee.prototype.r=1;Ee.prototype.g=1;Ee.prototype.b=1;class Wi extends Si{constructor(e){super(),this.type="MeshBasicMaterial",this.color=new Ee(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this}}Wi.prototype.isMeshBasicMaterial=!0;const Ce=new C,Di=new Re;class je{constructor(e,t,i){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=i===!0,this.usage=35044,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this}copyAt(e,t,i){e*=this.itemSize,i*=t.itemSize;for(let n=0,r=this.itemSize;n<r;n++)this.array[e+n]=t.array[i+n];return this}copyArray(e){return this.array.set(e),this}copyColorsArray(e){const t=this.array;let i=0;for(let n=0,r=e.length;n<r;n++){let s=e[n];s===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",n),s=new Ee),t[i++]=s.r,t[i++]=s.g,t[i++]=s.b}return this}copyVector2sArray(e){const t=this.array;let i=0;for(let n=0,r=e.length;n<r;n++){let s=e[n];s===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",n),s=new Re),t[i++]=s.x,t[i++]=s.y}return this}copyVector3sArray(e){const t=this.array;let i=0;for(let n=0,r=e.length;n<r;n++){let s=e[n];s===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",n),s=new C),t[i++]=s.x,t[i++]=s.y,t[i++]=s.z}return this}copyVector4sArray(e){const t=this.array;let i=0;for(let n=0,r=e.length;n<r;n++){let s=e[n];s===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",n),s=new We),t[i++]=s.x,t[i++]=s.y,t[i++]=s.z,t[i++]=s.w}return this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,i=this.count;t<i;t++)Di.fromBufferAttribute(this,t),Di.applyMatrix3(e),this.setXY(t,Di.x,Di.y);else if(this.itemSize===3)for(let t=0,i=this.count;t<i;t++)Ce.fromBufferAttribute(this,t),Ce.applyMatrix3(e),this.setXYZ(t,Ce.x,Ce.y,Ce.z);return this}applyMatrix4(e){for(let t=0,i=this.count;t<i;t++)Ce.x=this.getX(t),Ce.y=this.getY(t),Ce.z=this.getZ(t),Ce.applyMatrix4(e),this.setXYZ(t,Ce.x,Ce.y,Ce.z);return this}applyNormalMatrix(e){for(let t=0,i=this.count;t<i;t++)Ce.x=this.getX(t),Ce.y=this.getY(t),Ce.z=this.getZ(t),Ce.applyNormalMatrix(e),this.setXYZ(t,Ce.x,Ce.y,Ce.z);return this}transformDirection(e){for(let t=0,i=this.count;t<i;t++)Ce.x=this.getX(t),Ce.y=this.getY(t),Ce.z=this.getZ(t),Ce.transformDirection(e),this.setXYZ(t,Ce.x,Ce.y,Ce.z);return this}set(e,t=0){return this.array.set(e,t),this}getX(e){return this.array[e*this.itemSize]}setX(e,t){return this.array[e*this.itemSize]=t,this}getY(e){return this.array[e*this.itemSize+1]}setY(e,t){return this.array[e*this.itemSize+1]=t,this}getZ(e){return this.array[e*this.itemSize+2]}setZ(e,t){return this.array[e*this.itemSize+2]=t,this}getW(e){return this.array[e*this.itemSize+3]}setW(e,t){return this.array[e*this.itemSize+3]=t,this}setXY(e,t,i){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=i,this}setXYZ(e,t,i,n){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=i,this.array[e+2]=n,this}setXYZW(e,t,i,n,r){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=i,this.array[e+2]=n,this.array[e+3]=r,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==35044&&(e.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(e.updateRange=this.updateRange),e}}je.prototype.isBufferAttribute=!0;class br extends je{constructor(e,t,i){super(new Uint16Array(e),t,i)}}class wr extends je{constructor(e,t,i){super(new Uint32Array(e),t,i)}}class ua extends je{constructor(e,t,i){super(new Uint16Array(e),t,i)}}ua.prototype.isFloat16BufferAttribute=!0;class ct extends je{constructor(e,t,i){super(new Float32Array(e),t,i)}}let ha=0;const Ze=new ze,dn=new Je,jt=new C,Xe=new li,_i=new li,Ne=new C;class xt extends si{constructor(){super(),Object.defineProperty(this,"id",{value:ha++}),this.uuid=yi(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(Mr(e)>65535?wr:br)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,i=0){this.groups.push({start:e,count:t,materialIndex:i})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const i=this.attributes.normal;if(i!==void 0){const r=new nt().getNormalMatrix(e);i.applyNormalMatrix(r),i.needsUpdate=!0}const n=this.attributes.tangent;return n!==void 0&&(n.transformDirection(e),n.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return Ze.makeRotationFromQuaternion(e),this.applyMatrix4(Ze),this}rotateX(e){return Ze.makeRotationX(e),this.applyMatrix4(Ze),this}rotateY(e){return Ze.makeRotationY(e),this.applyMatrix4(Ze),this}rotateZ(e){return Ze.makeRotationZ(e),this.applyMatrix4(Ze),this}translate(e,t,i){return Ze.makeTranslation(e,t,i),this.applyMatrix4(Ze),this}scale(e,t,i){return Ze.makeScale(e,t,i),this.applyMatrix4(Ze),this}lookAt(e){return dn.lookAt(e),dn.updateMatrix(),this.applyMatrix4(dn.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(jt).negate(),this.translate(jt.x,jt.y,jt.z),this}setFromPoints(e){const t=[];for(let i=0,n=e.length;i<n;i++){const r=e[i];t.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new ct(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new li);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new C(-1/0,-1/0,-1/0),new C(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let i=0,n=t.length;i<n;i++){const r=t[i];Xe.setFromBufferAttribute(r),this.morphTargetsRelative?(Ne.addVectors(this.boundingBox.min,Xe.min),this.boundingBox.expandByPoint(Ne),Ne.addVectors(this.boundingBox.max,Xe.max),this.boundingBox.expandByPoint(Ne)):(this.boundingBox.expandByPoint(Xe.min),this.boundingBox.expandByPoint(Xe.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Tn);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new C,1/0);return}if(e){const i=this.boundingSphere.center;if(Xe.setFromBufferAttribute(e),t)for(let r=0,s=t.length;r<s;r++){const o=t[r];_i.setFromBufferAttribute(o),this.morphTargetsRelative?(Ne.addVectors(Xe.min,_i.min),Xe.expandByPoint(Ne),Ne.addVectors(Xe.max,_i.max),Xe.expandByPoint(Ne)):(Xe.expandByPoint(_i.min),Xe.expandByPoint(_i.max))}Xe.getCenter(i);let n=0;for(let r=0,s=e.count;r<s;r++)Ne.fromBufferAttribute(e,r),n=Math.max(n,i.distanceToSquared(Ne));if(t)for(let r=0,s=t.length;r<s;r++){const o=t[r],c=this.morphTargetsRelative;for(let l=0,h=o.count;l<h;l++)Ne.fromBufferAttribute(o,l),c&&(jt.fromBufferAttribute(e,l),Ne.add(jt)),n=Math.max(n,i.distanceToSquared(Ne))}this.boundingSphere.radius=Math.sqrt(n),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const i=e.array,n=t.position.array,r=t.normal.array,s=t.uv.array,o=n.length/3;t.tangent===void 0&&this.setAttribute("tangent",new je(new Float32Array(4*o),4));const c=t.tangent.array,l=[],h=[];for(let O=0;O<o;O++)l[O]=new C,h[O]=new C;const p=new C,f=new C,m=new C,_=new Re,g=new Re,b=new Re,u=new C,d=new C;function T(O,L,j){p.fromArray(n,O*3),f.fromArray(n,L*3),m.fromArray(n,j*3),_.fromArray(s,O*2),g.fromArray(s,L*2),b.fromArray(s,j*2),f.sub(p),m.sub(p),g.sub(_),b.sub(_);const I=1/(g.x*b.y-b.x*g.y);!isFinite(I)||(u.copy(f).multiplyScalar(b.y).addScaledVector(m,-g.y).multiplyScalar(I),d.copy(m).multiplyScalar(g.x).addScaledVector(f,-b.x).multiplyScalar(I),l[O].add(u),l[L].add(u),l[j].add(u),h[O].add(d),h[L].add(d),h[j].add(d))}let M=this.groups;M.length===0&&(M=[{start:0,count:i.length}]);for(let O=0,L=M.length;O<L;++O){const j=M[O],I=j.start,z=j.count;for(let G=I,N=I+z;G<N;G+=3)T(i[G+0],i[G+1],i[G+2])}const w=new C,E=new C,v=new C,U=new C;function q(O){v.fromArray(r,O*3),U.copy(v);const L=l[O];w.copy(L),w.sub(v.multiplyScalar(v.dot(L))).normalize(),E.crossVectors(U,L);const I=E.dot(h[O])<0?-1:1;c[O*4]=w.x,c[O*4+1]=w.y,c[O*4+2]=w.z,c[O*4+3]=I}for(let O=0,L=M.length;O<L;++O){const j=M[O],I=j.start,z=j.count;for(let G=I,N=I+z;G<N;G+=3)q(i[G+0]),q(i[G+1]),q(i[G+2])}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let i=this.getAttribute("normal");if(i===void 0)i=new je(new Float32Array(t.count*3),3),this.setAttribute("normal",i);else for(let f=0,m=i.count;f<m;f++)i.setXYZ(f,0,0,0);const n=new C,r=new C,s=new C,o=new C,c=new C,l=new C,h=new C,p=new C;if(e)for(let f=0,m=e.count;f<m;f+=3){const _=e.getX(f+0),g=e.getX(f+1),b=e.getX(f+2);n.fromBufferAttribute(t,_),r.fromBufferAttribute(t,g),s.fromBufferAttribute(t,b),h.subVectors(s,r),p.subVectors(n,r),h.cross(p),o.fromBufferAttribute(i,_),c.fromBufferAttribute(i,g),l.fromBufferAttribute(i,b),o.add(h),c.add(h),l.add(h),i.setXYZ(_,o.x,o.y,o.z),i.setXYZ(g,c.x,c.y,c.z),i.setXYZ(b,l.x,l.y,l.z)}else for(let f=0,m=t.count;f<m;f+=3)n.fromBufferAttribute(t,f+0),r.fromBufferAttribute(t,f+1),s.fromBufferAttribute(t,f+2),h.subVectors(s,r),p.subVectors(n,r),h.cross(p),i.setXYZ(f+0,h.x,h.y,h.z),i.setXYZ(f+1,h.x,h.y,h.z),i.setXYZ(f+2,h.x,h.y,h.z);this.normalizeNormals(),i.needsUpdate=!0}}merge(e,t){if(!(e&&e.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",e);return}t===void 0&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const i=this.attributes;for(const n in i){if(e.attributes[n]===void 0)continue;const s=i[n].array,o=e.attributes[n],c=o.array,l=o.itemSize*t,h=Math.min(c.length,s.length-l);for(let p=0,f=l;p<h;p++,f++)s[f]=c[p]}return this}normalizeNormals(){const e=this.attributes.normal;for(let t=0,i=e.count;t<i;t++)Ne.fromBufferAttribute(e,t),Ne.normalize(),e.setXYZ(t,Ne.x,Ne.y,Ne.z)}toNonIndexed(){function e(o,c){const l=o.array,h=o.itemSize,p=o.normalized,f=new l.constructor(c.length*h);let m=0,_=0;for(let g=0,b=c.length;g<b;g++){o.isInterleavedBufferAttribute?m=c[g]*o.data.stride+o.offset:m=c[g]*h;for(let u=0;u<h;u++)f[_++]=l[m++]}return new je(f,h,p)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new xt,i=this.index.array,n=this.attributes;for(const o in n){const c=n[o],l=e(c,i);t.setAttribute(o,l)}const r=this.morphAttributes;for(const o in r){const c=[],l=r[o];for(let h=0,p=l.length;h<p;h++){const f=l[h],m=e(f,i);c.push(m)}t.morphAttributes[o]=c}t.morphTargetsRelative=this.morphTargetsRelative;const s=this.groups;for(let o=0,c=s.length;o<c;o++){const l=s[o];t.addGroup(l.start,l.count,l.materialIndex)}return t}toJSON(){const e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const c=this.parameters;for(const l in c)c[l]!==void 0&&(e[l]=c[l]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const i=this.attributes;for(const c in i){const l=i[c];e.data.attributes[c]=l.toJSON(e.data)}const n={};let r=!1;for(const c in this.morphAttributes){const l=this.morphAttributes[c],h=[];for(let p=0,f=l.length;p<f;p++){const m=l[p];h.push(m.toJSON(e.data))}h.length>0&&(n[c]=h,r=!0)}r&&(e.data.morphAttributes=n,e.data.morphTargetsRelative=this.morphTargetsRelative);const s=this.groups;s.length>0&&(e.data.groups=JSON.parse(JSON.stringify(s)));const o=this.boundingSphere;return o!==null&&(e.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const i=e.index;i!==null&&this.setIndex(i.clone(t));const n=e.attributes;for(const l in n){const h=n[l];this.setAttribute(l,h.clone(t))}const r=e.morphAttributes;for(const l in r){const h=[],p=r[l];for(let f=0,m=p.length;f<m;f++)h.push(p[f].clone(t));this.morphAttributes[l]=h}this.morphTargetsRelative=e.morphTargetsRelative;const s=e.groups;for(let l=0,h=s.length;l<h;l++){const p=s[l];this.addGroup(p.start,p.count,p.materialIndex)}const o=e.boundingBox;o!==null&&(this.boundingBox=o.clone());const c=e.boundingSphere;return c!==null&&(this.boundingSphere=c.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,e.parameters!==void 0&&(this.parameters=Object.assign({},e.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}xt.prototype.isBufferGeometry=!0;const $n=new ze,Jt=new ta,fn=new Tn,Tt=new C,At=new C,Et=new C,pn=new C,mn=new C,gn=new C,Pi=new C,Fi=new C,Ii=new C,Ni=new Re,Bi=new Re,zi=new Re,_n=new C,Ui=new C;class lt extends Je{constructor(e=new xt,t=new Wi){super(),this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,i=Object.keys(t);if(i.length>0){const n=t[i[0]];if(n!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,s=n.length;r<s;r++){const o=n[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(e,t){const i=this.geometry,n=this.material,r=this.matrixWorld;if(n===void 0||(i.boundingSphere===null&&i.computeBoundingSphere(),fn.copy(i.boundingSphere),fn.applyMatrix4(r),e.ray.intersectsSphere(fn)===!1)||($n.copy(r).invert(),Jt.copy(e.ray).applyMatrix4($n),i.boundingBox!==null&&Jt.intersectsBox(i.boundingBox)===!1))return;let s;if(i.isBufferGeometry){const o=i.index,c=i.attributes.position,l=i.morphAttributes.position,h=i.morphTargetsRelative,p=i.attributes.uv,f=i.attributes.uv2,m=i.groups,_=i.drawRange;if(o!==null)if(Array.isArray(n))for(let g=0,b=m.length;g<b;g++){const u=m[g],d=n[u.materialIndex],T=Math.max(u.start,_.start),M=Math.min(o.count,Math.min(u.start+u.count,_.start+_.count));for(let w=T,E=M;w<E;w+=3){const v=o.getX(w),U=o.getX(w+1),q=o.getX(w+2);s=Gi(this,d,e,Jt,c,l,h,p,f,v,U,q),s&&(s.faceIndex=Math.floor(w/3),s.face.materialIndex=u.materialIndex,t.push(s))}}else{const g=Math.max(0,_.start),b=Math.min(o.count,_.start+_.count);for(let u=g,d=b;u<d;u+=3){const T=o.getX(u),M=o.getX(u+1),w=o.getX(u+2);s=Gi(this,n,e,Jt,c,l,h,p,f,T,M,w),s&&(s.faceIndex=Math.floor(u/3),t.push(s))}}else if(c!==void 0)if(Array.isArray(n))for(let g=0,b=m.length;g<b;g++){const u=m[g],d=n[u.materialIndex],T=Math.max(u.start,_.start),M=Math.min(c.count,Math.min(u.start+u.count,_.start+_.count));for(let w=T,E=M;w<E;w+=3){const v=w,U=w+1,q=w+2;s=Gi(this,d,e,Jt,c,l,h,p,f,v,U,q),s&&(s.faceIndex=Math.floor(w/3),s.face.materialIndex=u.materialIndex,t.push(s))}}else{const g=Math.max(0,_.start),b=Math.min(c.count,_.start+_.count);for(let u=g,d=b;u<d;u+=3){const T=u,M=u+1,w=u+2;s=Gi(this,n,e,Jt,c,l,h,p,f,T,M,w),s&&(s.faceIndex=Math.floor(u/3),t.push(s))}}}else i.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}lt.prototype.isMesh=!0;function da(a,e,t,i,n,r,s,o){let c;if(e.side===1?c=i.intersectTriangle(s,r,n,!0,o):c=i.intersectTriangle(n,r,s,e.side!==2,o),c===null)return null;Ui.copy(o),Ui.applyMatrix4(a.matrixWorld);const l=t.ray.origin.distanceTo(Ui);return l<t.near||l>t.far?null:{distance:l,point:Ui.clone(),object:a}}function Gi(a,e,t,i,n,r,s,o,c,l,h,p){Tt.fromBufferAttribute(n,l),At.fromBufferAttribute(n,h),Et.fromBufferAttribute(n,p);const f=a.morphTargetInfluences;if(r&&f){Pi.set(0,0,0),Fi.set(0,0,0),Ii.set(0,0,0);for(let _=0,g=r.length;_<g;_++){const b=f[_],u=r[_];b!==0&&(pn.fromBufferAttribute(u,l),mn.fromBufferAttribute(u,h),gn.fromBufferAttribute(u,p),s?(Pi.addScaledVector(pn,b),Fi.addScaledVector(mn,b),Ii.addScaledVector(gn,b)):(Pi.addScaledVector(pn.sub(Tt),b),Fi.addScaledVector(mn.sub(At),b),Ii.addScaledVector(gn.sub(Et),b)))}Tt.add(Pi),At.add(Fi),Et.add(Ii)}a.isSkinnedMesh&&(a.boneTransform(l,Tt),a.boneTransform(h,At),a.boneTransform(p,Et));const m=da(a,e,t,i,Tt,At,Et,_n);if(m){o&&(Ni.fromBufferAttribute(o,l),Bi.fromBufferAttribute(o,h),zi.fromBufferAttribute(o,p),m.uv=_t.getUV(_n,Tt,At,Et,Ni,Bi,zi,new Re)),c&&(Ni.fromBufferAttribute(c,l),Bi.fromBufferAttribute(c,h),zi.fromBufferAttribute(c,p),m.uv2=_t.getUV(_n,Tt,At,Et,Ni,Bi,zi,new Re));const _={a:l,b:h,c:p,normal:new C,materialIndex:0};_t.getNormal(Tt,At,Et,_.normal),m.face=_}return m}class ui extends xt{constructor(e=1,t=1,i=1,n=1,r=1,s=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:i,widthSegments:n,heightSegments:r,depthSegments:s};const o=this;n=Math.floor(n),r=Math.floor(r),s=Math.floor(s);const c=[],l=[],h=[],p=[];let f=0,m=0;_("z","y","x",-1,-1,i,t,e,s,r,0),_("z","y","x",1,-1,i,t,-e,s,r,1),_("x","z","y",1,1,e,i,t,n,s,2),_("x","z","y",1,-1,e,i,-t,n,s,3),_("x","y","z",1,-1,e,t,i,n,r,4),_("x","y","z",-1,-1,e,t,-i,n,r,5),this.setIndex(c),this.setAttribute("position",new ct(l,3)),this.setAttribute("normal",new ct(h,3)),this.setAttribute("uv",new ct(p,2));function _(g,b,u,d,T,M,w,E,v,U,q){const O=M/v,L=w/U,j=M/2,I=w/2,z=E/2,G=v+1,N=U+1;let B=0,Y=0;const ne=new C;for(let oe=0;oe<N;oe++){const te=oe*L-I;for(let xe=0;xe<G;xe++){const H=xe*O-j;ne[g]=H*d,ne[b]=te*T,ne[u]=z,l.push(ne.x,ne.y,ne.z),ne[g]=0,ne[b]=0,ne[u]=E>0?1:-1,h.push(ne.x,ne.y,ne.z),p.push(xe/v),p.push(1-oe/U),B+=1}}for(let oe=0;oe<U;oe++)for(let te=0;te<v;te++){const xe=f+te+G*oe,H=f+te+G*(oe+1),X=f+(te+1)+G*(oe+1),re=f+(te+1)+G*oe;c.push(xe,H,re),c.push(H,X,re),Y+=6}o.addGroup(m,Y,q),m+=Y,f+=B}}static fromJSON(e){return new ui(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function ri(a){const e={};for(const t in a){e[t]={};for(const i in a[t]){const n=a[t][i];n&&(n.isColor||n.isMatrix3||n.isMatrix4||n.isVector2||n.isVector3||n.isVector4||n.isTexture||n.isQuaternion)?e[t][i]=n.clone():Array.isArray(n)?e[t][i]=n.slice():e[t][i]=n}}return e}function Oe(a){const e={};for(let t=0;t<a.length;t++){const i=ri(a[t]);for(const n in i)e[n]=i[n]}return e}const fa={clone:ri,merge:Oe};var pa="void main(){gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}",ma="void main(){gl_FragColor=vec4(1.0,0.0,0.0,1.0);}";class ai extends Si{constructor(e){super(),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=pa,this.fragmentShader=ma,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&(e.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(e))}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=ri(e.uniforms),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const n in this.uniforms){const s=this.uniforms[n].value;s&&s.isTexture?t.uniforms[n]={type:"t",value:s.toJSON(e).uuid}:s&&s.isColor?t.uniforms[n]={type:"c",value:s.getHex()}:s&&s.isVector2?t.uniforms[n]={type:"v2",value:s.toArray()}:s&&s.isVector3?t.uniforms[n]={type:"v3",value:s.toArray()}:s&&s.isVector4?t.uniforms[n]={type:"v4",value:s.toArray()}:s&&s.isMatrix3?t.uniforms[n]={type:"m3",value:s.toArray()}:s&&s.isMatrix4?t.uniforms[n]={type:"m4",value:s.toArray()}:t.uniforms[n]={value:s}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const i={};for(const n in this.extensions)this.extensions[n]===!0&&(i[n]=!0);return Object.keys(i).length>0&&(t.extensions=i),t}}ai.prototype.isShaderMaterial=!0;class An extends Je{constructor(){super(),this.type="Camera",this.matrixWorldInverse=new ze,this.projectionMatrix=new ze,this.projectionMatrixInverse=new ze}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}An.prototype.isCamera=!0;class it extends An{constructor(e=50,t=1,i=.1,n=2e3){super(),this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=i,this.far=n,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=Gn*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(Yi*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return Gn*2*Math.atan(Math.tan(Yi*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,i,n,r,s){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=i,this.view.offsetY=n,this.view.width=r,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(Yi*.5*this.fov)/this.zoom,i=2*t,n=this.aspect*i,r=-.5*n;const s=this.view;if(this.view!==null&&this.view.enabled){const c=s.fullWidth,l=s.fullHeight;r+=s.offsetX*n/c,t-=s.offsetY*i/l,n*=s.width/c,i*=s.height/l}const o=this.filmOffset;o!==0&&(r+=e*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+n,t,t-i,e,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}it.prototype.isPerspectiveCamera=!0;const $t=90,Qt=1;class ga extends Je{constructor(e,t,i){if(super(),this.type="CubeCamera",i.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=i;const n=new it($t,Qt,e,t);n.layers=this.layers,n.up.set(0,-1,0),n.lookAt(new C(1,0,0)),this.add(n);const r=new it($t,Qt,e,t);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new C(-1,0,0)),this.add(r);const s=new it($t,Qt,e,t);s.layers=this.layers,s.up.set(0,0,1),s.lookAt(new C(0,1,0)),this.add(s);const o=new it($t,Qt,e,t);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(new C(0,-1,0)),this.add(o);const c=new it($t,Qt,e,t);c.layers=this.layers,c.up.set(0,-1,0),c.lookAt(new C(0,0,1)),this.add(c);const l=new it($t,Qt,e,t);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new C(0,0,-1)),this.add(l)}update(e,t){this.parent===null&&this.updateMatrixWorld();const i=this.renderTarget,[n,r,s,o,c,l]=this.children,h=e.xr.enabled,p=e.getRenderTarget();e.xr.enabled=!1;const f=i.texture.generateMipmaps;i.texture.generateMipmaps=!1,e.setRenderTarget(i,0),e.render(t,n),e.setRenderTarget(i,1),e.render(t,r),e.setRenderTarget(i,2),e.render(t,s),e.setRenderTarget(i,3),e.render(t,o),e.setRenderTarget(i,4),e.render(t,c),i.texture.generateMipmaps=f,e.setRenderTarget(i,5),e.render(t,l),e.setRenderTarget(p),e.xr.enabled=h}}class En extends rt{constructor(e,t,i,n,r,s,o,c,l,h){e=e!==void 0?e:[],t=t!==void 0?t:301,super(e,t,i,n,r,s,o,c,l,h),this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}En.prototype.isCubeTexture=!0;class Tr extends Ct{constructor(e,t,i){Number.isInteger(t)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),t=i),super(e,e,t),t=t||{},this.texture=new En(void 0,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:1006,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.format=1023,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const i={uniforms:{tEquirect:{value:null}},vertexShader:`varying vec3 vWorldDirection;vec3 transformDirection(in vec3 dir,in mat4 matrix){return normalize((matrix*vec4(dir,0.0)).xyz);}void main(){vWorldDirection=transformDirection(position,modelMatrix);
#include <begin_vertex>
#include <project_vertex>
}`,fragmentShader:`uniform sampler2D tEquirect;varying vec3 vWorldDirection;
#include <common>
void main(){vec3 direction=normalize(vWorldDirection);vec2 sampleUV=equirectUv(direction);gl_FragColor=texture2D(tEquirect,sampleUV);}`},n=new ui(5,5,5),r=new ai({name:"CubemapFromEquirect",uniforms:ri(i.uniforms),vertexShader:i.vertexShader,fragmentShader:i.fragmentShader,side:1,blending:0});r.uniforms.tEquirect.value=t;const s=new lt(n,r),o=t.minFilter;return t.minFilter===1008&&(t.minFilter=1006),new ga(1,10,this).update(e,s),t.minFilter=o,s.geometry.dispose(),s.material.dispose(),this}clear(e,t,i,n){const r=e.getRenderTarget();for(let s=0;s<6;s++)e.setRenderTarget(this,s),e.clear(t,i,n);e.setRenderTarget(r)}}Tr.prototype.isWebGLCubeRenderTarget=!0;const xn=new C,_a=new C,xa=new nt;class Lt{constructor(e=new C(1,0,0),t=0){this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,i,n){return this.normal.set(e,t,i),this.constant=n,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,i){const n=xn.subVectors(i,t).cross(_a.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(n,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){const i=e.delta(xn),n=this.normal.dot(i);if(n===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const r=-(e.start.dot(this.normal)+this.constant)/n;return r<0||r>1?null:t.copy(i).multiplyScalar(r).add(e.start)}intersectsLine(e){const t=this.distanceToPoint(e.start),i=this.distanceToPoint(e.end);return t<0&&i>0||i<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const i=t||xa.getNormalMatrix(e),n=this.coplanarPoint(xn).applyMatrix4(e),r=this.normal.applyMatrix3(i).normalize();return this.constant=-n.dot(r),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}Lt.prototype.isPlane=!0;const Kt=new Tn,Oi=new C;class Ar{constructor(e=new Lt,t=new Lt,i=new Lt,n=new Lt,r=new Lt,s=new Lt){this.planes=[e,t,i,n,r,s]}set(e,t,i,n,r,s){const o=this.planes;return o[0].copy(e),o[1].copy(t),o[2].copy(i),o[3].copy(n),o[4].copy(r),o[5].copy(s),this}copy(e){const t=this.planes;for(let i=0;i<6;i++)t[i].copy(e.planes[i]);return this}setFromProjectionMatrix(e){const t=this.planes,i=e.elements,n=i[0],r=i[1],s=i[2],o=i[3],c=i[4],l=i[5],h=i[6],p=i[7],f=i[8],m=i[9],_=i[10],g=i[11],b=i[12],u=i[13],d=i[14],T=i[15];return t[0].setComponents(o-n,p-c,g-f,T-b).normalize(),t[1].setComponents(o+n,p+c,g+f,T+b).normalize(),t[2].setComponents(o+r,p+l,g+m,T+u).normalize(),t[3].setComponents(o-r,p-l,g-m,T-u).normalize(),t[4].setComponents(o-s,p-h,g-_,T-d).normalize(),t[5].setComponents(o+s,p+h,g+_,T+d).normalize(),this}intersectsObject(e){const t=e.geometry;return t.boundingSphere===null&&t.computeBoundingSphere(),Kt.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(Kt)}intersectsSprite(e){return Kt.center.set(0,0,0),Kt.radius=.7071067811865476,Kt.applyMatrix4(e.matrixWorld),this.intersectsSphere(Kt)}intersectsSphere(e){const t=this.planes,i=e.center,n=-e.radius;for(let r=0;r<6;r++)if(t[r].distanceToPoint(i)<n)return!1;return!0}intersectsBox(e){const t=this.planes;for(let i=0;i<6;i++){const n=t[i];if(Oi.x=n.normal.x>0?e.max.x:e.min.x,Oi.y=n.normal.y>0?e.max.y:e.min.y,Oi.z=n.normal.z>0?e.max.z:e.min.z,n.distanceToPoint(Oi)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let i=0;i<6;i++)if(t[i].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function Er(){let a=null,e=!1,t=null,i=null;function n(r,s){t(r,s),i=a.requestAnimationFrame(n)}return{start:function(){e!==!0&&t!==null&&(i=a.requestAnimationFrame(n),e=!0)},stop:function(){a.cancelAnimationFrame(i),e=!1},setAnimationLoop:function(r){t=r},setContext:function(r){a=r}}}function va(a,e){const t=e.isWebGL2,i=new WeakMap;function n(l,h){const p=l.array,f=l.usage,m=a.createBuffer();a.bindBuffer(h,m),a.bufferData(h,p,f),l.onUploadCallback();let _=5126;return p instanceof Float32Array?_=5126:p instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):p instanceof Uint16Array?l.isFloat16BufferAttribute?t?_=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):_=5123:p instanceof Int16Array?_=5122:p instanceof Uint32Array?_=5125:p instanceof Int32Array?_=5124:p instanceof Int8Array?_=5120:(p instanceof Uint8Array||p instanceof Uint8ClampedArray)&&(_=5121),{buffer:m,type:_,bytesPerElement:p.BYTES_PER_ELEMENT,version:l.version}}function r(l,h,p){const f=h.array,m=h.updateRange;a.bindBuffer(p,l),m.count===-1?a.bufferSubData(p,0,f):(t?a.bufferSubData(p,m.offset*f.BYTES_PER_ELEMENT,f,m.offset,m.count):a.bufferSubData(p,m.offset*f.BYTES_PER_ELEMENT,f.subarray(m.offset,m.offset+m.count)),m.count=-1)}function s(l){return l.isInterleavedBufferAttribute&&(l=l.data),i.get(l)}function o(l){l.isInterleavedBufferAttribute&&(l=l.data);const h=i.get(l);h&&(a.deleteBuffer(h.buffer),i.delete(l))}function c(l,h){if(l.isGLBufferAttribute){const f=i.get(l);(!f||f.version<l.version)&&i.set(l,{buffer:l.buffer,type:l.type,bytesPerElement:l.elementSize,version:l.version});return}l.isInterleavedBufferAttribute&&(l=l.data);const p=i.get(l);p===void 0?i.set(l,n(l,h)):p.version<l.version&&(r(p.buffer,l,h),p.version=l.version)}return{get:s,remove:o,update:c}}class Ln extends xt{constructor(e=1,t=1,i=1,n=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:i,heightSegments:n};const r=e/2,s=t/2,o=Math.floor(i),c=Math.floor(n),l=o+1,h=c+1,p=e/o,f=t/c,m=[],_=[],g=[],b=[];for(let u=0;u<h;u++){const d=u*f-s;for(let T=0;T<l;T++){const M=T*p-r;_.push(M,-d,0),g.push(0,0,1),b.push(T/o),b.push(1-u/c)}}for(let u=0;u<c;u++)for(let d=0;d<o;d++){const T=d+l*u,M=d+l*(u+1),w=d+1+l*(u+1),E=d+1+l*u;m.push(T,M,E),m.push(M,w,E)}this.setIndex(m),this.setAttribute("position",new ct(_,3)),this.setAttribute("normal",new ct(g,3)),this.setAttribute("uv",new ct(b,2))}static fromJSON(e){return new Ln(e.width,e.height,e.widthSegments,e.heightSegments)}}var Ma=`#ifdef USE_ALPHAMAP
diffuseColor.a*=texture2D(alphaMap,vUv).g;
#endif`,ya=`#ifdef USE_ALPHAMAP
uniform sampler2D alphaMap;
#endif`,Sa=`#ifdef USE_ALPHATEST
if(diffuseColor.a<alphaTest)discard;
#endif`,ba=`#ifdef USE_ALPHATEST
uniform float alphaTest;
#endif`,wa=`#ifdef USE_AOMAP
float ambientOcclusion=(texture2D(aoMap,vUv2).r-1.0)*aoMapIntensity+1.0;reflectedLight.indirectDiffuse*=ambientOcclusion;
#if defined(USE_ENVMAP)&&defined(STANDARD)
float dotNV=saturate(dot(geometry.normal,geometry.viewDir));reflectedLight.indirectSpecular*=computeSpecularOcclusion(dotNV,ambientOcclusion,material.roughness);
#endif
#endif`,Ta=`#ifdef USE_AOMAP
uniform sampler2D aoMap;uniform float aoMapIntensity;
#endif`,Aa="vec3 transformed=vec3(position);",Ea=`vec3 objectNormal=vec3(normal);
#ifdef USE_TANGENT
vec3 objectTangent=vec3(tangent.xyz);
#endif`,La=`vec3 BRDF_Lambert(const in vec3 diffuseColor){return RECIPROCAL_PI*diffuseColor;}vec3 F_Schlick(const in vec3 f0,const in float f90,const in float dotVH){float fresnel=exp2((-5.55473*dotVH-6.98316)*dotVH);return f0*(1.0-fresnel)+(f90*fresnel);}float V_GGX_SmithCorrelated(const in float alpha,const in float dotNL,const in float dotNV){float a2=pow2(alpha);float gv=dotNL*sqrt(a2+(1.0-a2)*pow2(dotNV));float gl=dotNV*sqrt(a2+(1.0-a2)*pow2(dotNL));return 0.5/max(gv+gl,EPSILON);}float D_GGX(const in float alpha,const in float dotNH){float a2=pow2(alpha);float denom=pow2(dotNH)*(a2-1.0)+1.0;return RECIPROCAL_PI*a2/pow2(denom);}vec3 BRDF_GGX(const in vec3 lightDir,const in vec3 viewDir,const in vec3 normal,const in vec3 f0,const in float f90,const in float roughness){float alpha=pow2(roughness);vec3 halfDir=normalize(lightDir+viewDir);float dotNL=saturate(dot(normal,lightDir));float dotNV=saturate(dot(normal,viewDir));float dotNH=saturate(dot(normal,halfDir));float dotVH=saturate(dot(viewDir,halfDir));vec3 F=F_Schlick(f0,f90,dotVH);float V=V_GGX_SmithCorrelated(alpha,dotNL,dotNV);float D=D_GGX(alpha,dotNH);return F*(V*D);}vec2 LTC_Uv(const in vec3 N,const in vec3 V,const in float roughness){const float LUT_SIZE=64.0;const float LUT_SCALE=(LUT_SIZE-1.0)/LUT_SIZE;const float LUT_BIAS=0.5/LUT_SIZE;float dotNV=saturate(dot(N,V));vec2 uv=vec2(roughness,sqrt(1.0-dotNV));uv=uv*LUT_SCALE+LUT_BIAS;return uv;}float LTC_ClippedSphereFormFactor(const in vec3 f){float l=length(f);return max((l*l+f.z)/(l+1.0),0.0);}vec3 LTC_EdgeVectorFormFactor(const in vec3 v1,const in vec3 v2){float x=dot(v1,v2);float y=abs(x);float a=0.8543985+(0.4965155+0.0145206*y)*y;float b=3.4175940+(4.1616724+y)*y;float v=a/b;float theta_sintheta=(x>0.0)?v:0.5*inversesqrt(max(1.0-x*x,1e-7))-v;return cross(v1,v2)*theta_sintheta;}vec3 LTC_Evaluate(const in vec3 N,const in vec3 V,const in vec3 P,const in mat3 mInv,const in vec3 rectCoords[4]){vec3 v1=rectCoords[1]-rectCoords[0];vec3 v2=rectCoords[3]-rectCoords[0];vec3 lightNormal=cross(v1,v2);if(dot(lightNormal,P-rectCoords[0])<0.0)return vec3(0.0);vec3 T1,T2;T1=normalize(V-N*dot(V,N));T2=-cross(N,T1);mat3 mat=mInv*transposeMat3(mat3(T1,T2,N));vec3 coords[4];coords[0]=mat*(rectCoords[0]-P);coords[1]=mat*(rectCoords[1]-P);coords[2]=mat*(rectCoords[2]-P);coords[3]=mat*(rectCoords[3]-P);coords[0]=normalize(coords[0]);coords[1]=normalize(coords[1]);coords[2]=normalize(coords[2]);coords[3]=normalize(coords[3]);vec3 vectorFormFactor=vec3(0.0);vectorFormFactor+=LTC_EdgeVectorFormFactor(coords[0],coords[1]);vectorFormFactor+=LTC_EdgeVectorFormFactor(coords[1],coords[2]);vectorFormFactor+=LTC_EdgeVectorFormFactor(coords[2],coords[3]);vectorFormFactor+=LTC_EdgeVectorFormFactor(coords[3],coords[0]);float result=LTC_ClippedSphereFormFactor(vectorFormFactor);return vec3(result);}float G_BlinnPhong_Implicit(){return 0.25;}float D_BlinnPhong(const in float shininess,const in float dotNH){return RECIPROCAL_PI*(shininess*0.5+1.0)*pow(dotNH,shininess);}vec3 BRDF_BlinnPhong(const in vec3 lightDir,const in vec3 viewDir,const in vec3 normal,const in vec3 specularColor,const in float shininess){vec3 halfDir=normalize(lightDir+viewDir);float dotNH=saturate(dot(normal,halfDir));float dotVH=saturate(dot(viewDir,halfDir));vec3 F=F_Schlick(specularColor,1.0,dotVH);float G=G_BlinnPhong_Implicit();float D=D_BlinnPhong(shininess,dotNH);return F*(G*D);}
#if defined(USE_SHEEN)
float D_Charlie(float roughness,float dotNH){float alpha=pow2(roughness);float invAlpha=1.0/alpha;float cos2h=dotNH*dotNH;float sin2h=max(1.0-cos2h,0.0078125);return(2.0+invAlpha)*pow(sin2h,invAlpha*0.5)/(2.0*PI);}float V_Neubelt(float dotNV,float dotNL){return saturate(1.0/(4.0*(dotNL+dotNV-dotNL*dotNV)));}vec3 BRDF_Sheen(const in vec3 lightDir,const in vec3 viewDir,const in vec3 normal,vec3 sheenTint,const in float sheenRoughness){vec3 halfDir=normalize(lightDir+viewDir);float dotNL=saturate(dot(normal,lightDir));float dotNV=saturate(dot(normal,viewDir));float dotNH=saturate(dot(normal,halfDir));float D=D_Charlie(sheenRoughness,dotNH);float V=V_Neubelt(dotNV,dotNL);return sheenTint*(D*V);}
#endif`,Ca=`#ifdef USE_BUMPMAP
uniform sampler2D bumpMap;uniform float bumpScale;vec2 dHdxy_fwd(){vec2 dSTdx=dFdx(vUv);vec2 dSTdy=dFdy(vUv);float Hll=bumpScale*texture2D(bumpMap,vUv).x;float dBx=bumpScale*texture2D(bumpMap,vUv+dSTdx).x-Hll;float dBy=bumpScale*texture2D(bumpMap,vUv+dSTdy).x-Hll;return vec2(dBx,dBy);}vec3 perturbNormalArb(vec3 surf_pos,vec3 surf_norm,vec2 dHdxy,float faceDirection){vec3 vSigmaX=vec3(dFdx(surf_pos.x),dFdx(surf_pos.y),dFdx(surf_pos.z));vec3 vSigmaY=vec3(dFdy(surf_pos.x),dFdy(surf_pos.y),dFdy(surf_pos.z));vec3 vN=surf_norm;vec3 R1=cross(vSigmaY,vN);vec3 R2=cross(vN,vSigmaX);float fDet=dot(vSigmaX,R1)*faceDirection;vec3 vGrad=sign(fDet)*(dHdxy.x*R1+dHdxy.y*R2);return normalize(abs(fDet)*surf_norm-vGrad);}
#endif`,Ra=`#if NUM_CLIPPING_PLANES>0
vec4 plane;
#pragma unroll_loop_start
for(int i=0;i<UNION_CLIPPING_PLANES;i++){plane=clippingPlanes[i];if(dot(vClipPosition,plane.xyz)>plane.w)discard;}
#pragma unroll_loop_end
#if UNION_CLIPPING_PLANES<NUM_CLIPPING_PLANES
bool clipped=true;
#pragma unroll_loop_start
for(int i=UNION_CLIPPING_PLANES;i<NUM_CLIPPING_PLANES;i++){plane=clippingPlanes[i];clipped=(dot(vClipPosition,plane.xyz)>plane.w)&&clipped;}
#pragma unroll_loop_end
if(clipped)discard;
#endif
#endif`,Da=`#if NUM_CLIPPING_PLANES>0
varying vec3 vClipPosition;uniform vec4 clippingPlanes[NUM_CLIPPING_PLANES];
#endif`,Pa=`#if NUM_CLIPPING_PLANES>0
varying vec3 vClipPosition;
#endif`,Fa=`#if NUM_CLIPPING_PLANES>0
vClipPosition=-mvPosition.xyz;
#endif`,Ia=`#if defined(USE_COLOR_ALPHA)
diffuseColor*=vColor;
#elif defined(USE_COLOR)
diffuseColor.rgb*=vColor;
#endif`,Na=`#if defined(USE_COLOR_ALPHA)
varying vec4 vColor;
#elif defined(USE_COLOR)
varying vec3 vColor;
#endif`,Ba=`#if defined(USE_COLOR_ALPHA)
varying vec4 vColor;
#elif defined(USE_COLOR)||defined(USE_INSTANCING_COLOR)
varying vec3 vColor;
#endif`,za=`#if defined(USE_COLOR_ALPHA)
vColor=vec4(1.0);
#elif defined(USE_COLOR)||defined(USE_INSTANCING_COLOR)
vColor=vec3(1.0);
#endif
#ifdef USE_COLOR
vColor*=color;
#endif
#ifdef USE_INSTANCING_COLOR
vColor.xyz*=instanceColor.xyz;
#endif`,Ua=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate(a)clamp(a,0.0,1.0)
#endif
#define whiteComplement(a)(1.0-saturate(a))
float pow2(const in float x){return x*x;}float pow3(const in float x){return x*x*x;}float pow4(const in float x){float x2=x*x;return x2*x2;}float max3(const in vec3 v){return max(max(v.x,v.y),v.z);}float average(const in vec3 color){return dot(color,vec3(0.3333));}highp float rand(const in vec2 uv){const highp float a=12.9898,b=78.233,c=43758.5453;highp float dt=dot(uv.xy,vec2(a,b)),sn=mod(dt,PI);return fract(sin(sn)*c);}
#ifdef HIGH_PRECISION
float precisionSafeLength(vec3 v){return length(v);}
#else
float precisionSafeLength(vec3 v){float maxComponent=max3(abs(v));return length(v/maxComponent)*maxComponent;}
#endif
struct IncidentLight{vec3 color;vec3 direction;bool visible;};struct ReflectedLight{vec3 directDiffuse;vec3 directSpecular;vec3 indirectDiffuse;vec3 indirectSpecular;};struct GeometricContext{vec3 position;vec3 normal;vec3 viewDir;
#ifdef USE_CLEARCOAT
vec3 clearcoatNormal;
#endif
};vec3 transformDirection(in vec3 dir,in mat4 matrix){return normalize((matrix*vec4(dir,0.0)).xyz);}vec3 inverseTransformDirection(in vec3 dir,in mat4 matrix){return normalize((vec4(dir,0.0)*matrix).xyz);}mat3 transposeMat3(const in mat3 m){mat3 tmp;tmp[0]=vec3(m[0].x,m[1].x,m[2].x);tmp[1]=vec3(m[0].y,m[1].y,m[2].y);tmp[2]=vec3(m[0].z,m[1].z,m[2].z);return tmp;}float linearToRelativeLuminance(const in vec3 color){vec3 weights=vec3(0.2126,0.7152,0.0722);return dot(weights,color.rgb);}bool isPerspectiveMatrix(mat4 m){return m[2][3]==-1.0;}vec2 equirectUv(in vec3 dir){float u=atan(dir.z,dir.x)*RECIPROCAL_PI2+0.5;float v=asin(clamp(dir.y,-1.0,1.0))*RECIPROCAL_PI+0.5;return vec2(u,v);}`,Ga=`#ifdef ENVMAP_TYPE_CUBE_UV
#define cubeUV_maxMipLevel 8.0
#define cubeUV_minMipLevel 4.0
#define cubeUV_maxTileSize 256.0
#define cubeUV_minTileSize 16.0
float getFace(vec3 direction){vec3 absDirection=abs(direction);float face=-1.0;if(absDirection.x>absDirection.z){if(absDirection.x>absDirection.y)face=direction.x>0.0?0.0:3.0;else face=direction.y>0.0?1.0:4.0;}else{if(absDirection.z>absDirection.y)face=direction.z>0.0?2.0:5.0;else face=direction.y>0.0?1.0:4.0;}return face;}vec2 getUV(vec3 direction,float face){vec2 uv;if(face==0.0){uv=vec2(direction.z,direction.y)/abs(direction.x);}else if(face==1.0){uv=vec2(-direction.x,-direction.z)/abs(direction.y);}else if(face==2.0){uv=vec2(-direction.x,direction.y)/abs(direction.z);}else if(face==3.0){uv=vec2(-direction.z,direction.y)/abs(direction.x);}else if(face==4.0){uv=vec2(-direction.x,direction.z)/abs(direction.y);}else{uv=vec2(direction.x,direction.y)/abs(direction.z);}return 0.5*(uv+1.0);}vec3 bilinearCubeUV(sampler2D envMap,vec3 direction,float mipInt){float face=getFace(direction);float filterInt=max(cubeUV_minMipLevel-mipInt,0.0);mipInt=max(mipInt,cubeUV_minMipLevel);float faceSize=exp2(mipInt);float texelSize=1.0/(3.0*cubeUV_maxTileSize);vec2 uv=getUV(direction,face)*(faceSize-1.0);vec2 f=fract(uv);uv+=0.5-f;if(face>2.0){uv.y+=faceSize;face-=3.0;}uv.x+=face*faceSize;if(mipInt<cubeUV_maxMipLevel){uv.y+=2.0*cubeUV_maxTileSize;}uv.y+=filterInt*2.0*cubeUV_minTileSize;uv.x+=3.0*max(0.0,cubeUV_maxTileSize-2.0*faceSize);uv*=texelSize;vec3 tl=envMapTexelToLinear(texture2D(envMap,uv)).rgb;uv.x+=texelSize;vec3 tr=envMapTexelToLinear(texture2D(envMap,uv)).rgb;uv.y+=texelSize;vec3 br=envMapTexelToLinear(texture2D(envMap,uv)).rgb;uv.x-=texelSize;vec3 bl=envMapTexelToLinear(texture2D(envMap,uv)).rgb;vec3 tm=mix(tl,tr,f.x);vec3 bm=mix(bl,br,f.x);return mix(tm,bm,f.y);}
#define r0 1.0
#define v0 0.339
#define m0-2.0
#define r1 0.8
#define v1 0.276
#define m1-1.0
#define r4 0.4
#define v4 0.046
#define m4 2.0
#define r5 0.305
#define v5 0.016
#define m5 3.0
#define r6 0.21
#define v6 0.0038
#define m6 4.0
float roughnessToMip(float roughness){float mip=0.0;if(roughness>=r1){mip=(r0-roughness)*(m1-m0)/(r0-r1)+m0;}else if(roughness>=r4){mip=(r1-roughness)*(m4-m1)/(r1-r4)+m1;}else if(roughness>=r5){mip=(r4-roughness)*(m5-m4)/(r4-r5)+m4;}else if(roughness>=r6){mip=(r5-roughness)*(m6-m5)/(r5-r6)+m5;}else{mip=-2.0*log2(1.16*roughness);}return mip;}vec4 textureCubeUV(sampler2D envMap,vec3 sampleDir,float roughness){float mip=clamp(roughnessToMip(roughness),m0,cubeUV_maxMipLevel);float mipF=fract(mip);float mipInt=floor(mip);vec3 color0=bilinearCubeUV(envMap,sampleDir,mipInt);if(mipF==0.0){return vec4(color0,1.0);}else{vec3 color1=bilinearCubeUV(envMap,sampleDir,mipInt+1.0);return vec4(mix(color0,color1,mipF),1.0);}}
#endif`,Oa=`vec3 transformedNormal=objectNormal;
#ifdef USE_INSTANCING
mat3 m=mat3(instanceMatrix);transformedNormal/=vec3(dot(m[0],m[0]),dot(m[1],m[1]),dot(m[2],m[2]));transformedNormal=m*transformedNormal;
#endif
transformedNormal=normalMatrix*transformedNormal;
#ifdef FLIP_SIDED
transformedNormal=-transformedNormal;
#endif
#ifdef USE_TANGENT
vec3 transformedTangent=(modelViewMatrix*vec4(objectTangent,0.0)).xyz;
#ifdef FLIP_SIDED
transformedTangent=-transformedTangent;
#endif
#endif`,Va=`#ifdef USE_DISPLACEMENTMAP
uniform sampler2D displacementMap;uniform float displacementScale;uniform float displacementBias;
#endif`,ka=`#ifdef USE_DISPLACEMENTMAP
transformed+=normalize(objectNormal)*(texture2D(displacementMap,vUv).x*displacementScale+displacementBias);
#endif`,Wa=`#ifdef USE_EMISSIVEMAP
vec4 emissiveColor=texture2D(emissiveMap,vUv);emissiveColor.rgb=emissiveMapTexelToLinear(emissiveColor).rgb;totalEmissiveRadiance*=emissiveColor.rgb;
#endif`,Ha=`#ifdef USE_EMISSIVEMAP
uniform sampler2D emissiveMap;
#endif`,qa="gl_FragColor=linearToOutputTexel(gl_FragColor);",Xa="vec4 LinearToLinear(in vec4 value){return value;}vec4 GammaToLinear(in vec4 value,in float gammaFactor){return vec4(pow(value.rgb,vec3(gammaFactor)),value.a);}vec4 LinearToGamma(in vec4 value,in float gammaFactor){return vec4(pow(value.rgb,vec3(1.0/gammaFactor)),value.a);}vec4 sRGBToLinear(in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}vec4 LinearTosRGB(in vec4 value){return vec4(mix(pow(value.rgb,vec3(0.41666))*1.055-vec3(0.055),value.rgb*12.92,vec3(lessThanEqual(value.rgb,vec3(0.0031308)))),value.a);}vec4 RGBEToLinear(in vec4 value){return vec4(value.rgb*exp2(value.a*255.0-128.0),1.0);}vec4 LinearToRGBE(in vec4 value){float maxComponent=max(max(value.r,value.g),value.b);float fExp=clamp(ceil(log2(maxComponent)),-128.0,127.0);return vec4(value.rgb/exp2(fExp),(fExp+128.0)/255.0);}vec4 RGBMToLinear(in vec4 value,in float maxRange){return vec4(value.rgb*value.a*maxRange,1.0);}vec4 LinearToRGBM(in vec4 value,in float maxRange){float maxRGB=max(value.r,max(value.g,value.b));float M=clamp(maxRGB/maxRange,0.0,1.0);M=ceil(M*255.0)/255.0;return vec4(value.rgb/(M*maxRange),M);}vec4 RGBDToLinear(in vec4 value,in float maxRange){return vec4(value.rgb*((maxRange/255.0)/value.a),1.0);}vec4 LinearToRGBD(in vec4 value,in float maxRange){float maxRGB=max(value.r,max(value.g,value.b));float D=max(maxRange/maxRGB,1.0);D=clamp(floor(D)/255.0,0.0,1.0);return vec4(value.rgb*(D*(255.0/maxRange)),D);}const mat3 cLogLuvM=mat3(0.2209,0.3390,0.4184,0.1138,0.6780,0.7319,0.0102,0.1130,0.2969);vec4 LinearToLogLuv(in vec4 value){vec3 Xp_Y_XYZp=cLogLuvM*value.rgb;Xp_Y_XYZp=max(Xp_Y_XYZp,vec3(1e-6,1e-6,1e-6));vec4 vResult;vResult.xy=Xp_Y_XYZp.xy/Xp_Y_XYZp.z;float Le=2.0*log2(Xp_Y_XYZp.y)+127.0;vResult.w=fract(Le);vResult.z=(Le-(floor(vResult.w*255.0))/255.0)/255.0;return vResult;}const mat3 cLogLuvInverseM=mat3(6.0014,-2.7008,-1.7996,-1.3320,3.1029,-5.7721,0.3008,-1.0882,5.6268);vec4 LogLuvToLinear(in vec4 value){float Le=value.z*255.0+value.w;vec3 Xp_Y_XYZp;Xp_Y_XYZp.y=exp2((Le-127.0)/2.0);Xp_Y_XYZp.z=Xp_Y_XYZp.y/value.y;Xp_Y_XYZp.x=value.x*Xp_Y_XYZp.z;vec3 vRGB=cLogLuvInverseM*Xp_Y_XYZp.rgb;return vec4(max(vRGB,0.0),1.0);}",Ya=`#ifdef USE_ENVMAP
#ifdef ENV_WORLDPOS
vec3 cameraToFrag;if(isOrthographic){cameraToFrag=normalize(vec3(-viewMatrix[0][2],-viewMatrix[1][2],-viewMatrix[2][2]));}else{cameraToFrag=normalize(vWorldPosition-cameraPosition);}vec3 worldNormal=inverseTransformDirection(normal,viewMatrix);
#ifdef ENVMAP_MODE_REFLECTION
vec3 reflectVec=reflect(cameraToFrag,worldNormal);
#else
vec3 reflectVec=refract(cameraToFrag,worldNormal,refractionRatio);
#endif
#else
vec3 reflectVec=vReflect;
#endif
#ifdef ENVMAP_TYPE_CUBE
vec4 envColor=textureCube(envMap,vec3(flipEnvMap*reflectVec.x,reflectVec.yz));envColor=envMapTexelToLinear(envColor);
#elif defined(ENVMAP_TYPE_CUBE_UV)
vec4 envColor=textureCubeUV(envMap,reflectVec,0.0);
#else
vec4 envColor=vec4(0.0);
#endif
#ifdef ENVMAP_BLENDING_MULTIPLY
outgoingLight=mix(outgoingLight,outgoingLight*envColor.xyz,specularStrength*reflectivity);
#elif defined(ENVMAP_BLENDING_MIX)
outgoingLight=mix(outgoingLight,envColor.xyz,specularStrength*reflectivity);
#elif defined(ENVMAP_BLENDING_ADD)
outgoingLight+=envColor.xyz*specularStrength*reflectivity;
#endif
#endif`,Za=`#ifdef USE_ENVMAP
uniform float envMapIntensity;uniform float flipEnvMap;uniform int maxMipLevel;
#ifdef ENVMAP_TYPE_CUBE
uniform samplerCube envMap;
#else
uniform sampler2D envMap;
#endif
#endif`,ja=`#ifdef USE_ENVMAP
uniform float reflectivity;
#if defined(USE_BUMPMAP)||defined(USE_NORMALMAP)||defined(PHONG)
#define ENV_WORLDPOS
#endif
#ifdef ENV_WORLDPOS
varying vec3 vWorldPosition;uniform float refractionRatio;
#else
varying vec3 vReflect;
#endif
#endif`,Ja=`#ifdef USE_ENVMAP
#if defined(USE_BUMPMAP)||defined(USE_NORMALMAP)||defined(PHONG)
#define ENV_WORLDPOS
#endif
#ifdef ENV_WORLDPOS
varying vec3 vWorldPosition;
#else
varying vec3 vReflect;uniform float refractionRatio;
#endif
#endif`,$a=`#ifdef USE_ENVMAP
#ifdef ENV_WORLDPOS
vWorldPosition=worldPosition.xyz;
#else
vec3 cameraToVertex;if(isOrthographic){cameraToVertex=normalize(vec3(-viewMatrix[0][2],-viewMatrix[1][2],-viewMatrix[2][2]));}else{cameraToVertex=normalize(worldPosition.xyz-cameraPosition);}vec3 worldNormal=inverseTransformDirection(transformedNormal,viewMatrix);
#ifdef ENVMAP_MODE_REFLECTION
vReflect=reflect(cameraToVertex,worldNormal);
#else
vReflect=refract(cameraToVertex,worldNormal,refractionRatio);
#endif
#endif
#endif`,Qa=`#ifdef USE_FOG
vFogDepth=-mvPosition.z;
#endif`,Ka=`#ifdef USE_FOG
varying float vFogDepth;
#endif`,es=`#ifdef USE_FOG
#ifdef FOG_EXP2
float fogFactor=1.0-exp(-fogDensity*fogDensity*vFogDepth*vFogDepth);
#else
float fogFactor=smoothstep(fogNear,fogFar,vFogDepth);
#endif
gl_FragColor.rgb=mix(gl_FragColor.rgb,fogColor,fogFactor);
#endif`,ts=`#ifdef USE_FOG
uniform vec3 fogColor;varying float vFogDepth;
#ifdef FOG_EXP2
uniform float fogDensity;
#else
uniform float fogNear;uniform float fogFar;
#endif
#endif`,is=`#ifdef USE_GRADIENTMAP
uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance(vec3 normal,vec3 lightDirection){float dotNL=dot(normal,lightDirection);vec2 coord=vec2(dotNL*0.5+0.5,0.0);
#ifdef USE_GRADIENTMAP
return texture2D(gradientMap,coord).rgb;
#else
return(coord.x<0.7)?vec3(0.7):vec3(1.0);
#endif
}`,ns=`#ifdef USE_LIGHTMAP
vec4 lightMapTexel=texture2D(lightMap,vUv2);vec3 lightMapIrradiance=lightMapTexelToLinear(lightMapTexel).rgb*lightMapIntensity;
#ifndef PHYSICALLY_CORRECT_LIGHTS
lightMapIrradiance*=PI;
#endif
reflectedLight.indirectDiffuse+=lightMapIrradiance;
#endif`,rs=`#ifdef USE_LIGHTMAP
uniform sampler2D lightMap;uniform float lightMapIntensity;
#endif`,as=`vec3 diffuse=vec3(1.0);GeometricContext geometry;geometry.position=mvPosition.xyz;geometry.normal=normalize(transformedNormal);geometry.viewDir=(isOrthographic)?vec3(0,0,1):normalize(-mvPosition.xyz);GeometricContext backGeometry;backGeometry.position=geometry.position;backGeometry.normal=-geometry.normal;backGeometry.viewDir=geometry.viewDir;vLightFront=vec3(0.0);vIndirectFront=vec3(0.0);
#ifdef DOUBLE_SIDED
vLightBack=vec3(0.0);vIndirectBack=vec3(0.0);
#endif
IncidentLight directLight;float dotNL;vec3 directLightColor_Diffuse;vIndirectFront+=getAmbientLightIrradiance(ambientLightColor);vIndirectFront+=getLightProbeIrradiance(lightProbe,geometry.normal);
#ifdef DOUBLE_SIDED
vIndirectBack+=getAmbientLightIrradiance(ambientLightColor);vIndirectBack+=getLightProbeIrradiance(lightProbe,backGeometry.normal);
#endif
#if NUM_POINT_LIGHTS>0
#pragma unroll_loop_start
for(int i=0;i<NUM_POINT_LIGHTS;i++){getPointLightInfo(pointLights[i],geometry,directLight);dotNL=dot(geometry.normal,directLight.direction);directLightColor_Diffuse=directLight.color;vLightFront+=saturate(dotNL)*directLightColor_Diffuse;
#ifdef DOUBLE_SIDED
vLightBack+=saturate(-dotNL)*directLightColor_Diffuse;
#endif
}
#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS>0
#pragma unroll_loop_start
for(int i=0;i<NUM_SPOT_LIGHTS;i++){getSpotLightInfo(spotLights[i],geometry,directLight);dotNL=dot(geometry.normal,directLight.direction);directLightColor_Diffuse=directLight.color;vLightFront+=saturate(dotNL)*directLightColor_Diffuse;
#ifdef DOUBLE_SIDED
vLightBack+=saturate(-dotNL)*directLightColor_Diffuse;
#endif
}
#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS>0
#pragma unroll_loop_start
for(int i=0;i<NUM_DIR_LIGHTS;i++){getDirectionalLightInfo(directionalLights[i],geometry,directLight);dotNL=dot(geometry.normal,directLight.direction);directLightColor_Diffuse=directLight.color;vLightFront+=saturate(dotNL)*directLightColor_Diffuse;
#ifdef DOUBLE_SIDED
vLightBack+=saturate(-dotNL)*directLightColor_Diffuse;
#endif
}
#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS>0
#pragma unroll_loop_start
for(int i=0;i<NUM_HEMI_LIGHTS;i++){vIndirectFront+=getHemisphereLightIrradiance(hemisphereLights[i],geometry.normal);
#ifdef DOUBLE_SIDED
vIndirectBack+=getHemisphereLightIrradiance(hemisphereLights[i],backGeometry.normal);
#endif
}
#pragma unroll_loop_end
#endif`,ss=`uniform bool receiveShadow;uniform vec3 ambientLightColor;uniform vec3 lightProbe[9];vec3 shGetIrradianceAt(in vec3 normal,in vec3 shCoefficients[9]){float x=normal.x,y=normal.y,z=normal.z;vec3 result=shCoefficients[0]*0.886227;result+=shCoefficients[1]*2.0*0.511664*y;result+=shCoefficients[2]*2.0*0.511664*z;result+=shCoefficients[3]*2.0*0.511664*x;result+=shCoefficients[4]*2.0*0.429043*x*y;result+=shCoefficients[5]*2.0*0.429043*y*z;result+=shCoefficients[6]*(0.743125*z*z-0.247708);result+=shCoefficients[7]*2.0*0.429043*x*z;result+=shCoefficients[8]*0.429043*(x*x-y*y);return result;}vec3 getLightProbeIrradiance(const in vec3 lightProbe[9],const in vec3 normal){vec3 worldNormal=inverseTransformDirection(normal,viewMatrix);vec3 irradiance=shGetIrradianceAt(worldNormal,lightProbe);return irradiance;}vec3 getAmbientLightIrradiance(const in vec3 ambientLightColor){vec3 irradiance=ambientLightColor;return irradiance;}float getDistanceAttenuation(const in float lightDistance,const in float cutoffDistance,const in float decayExponent){
#if defined(PHYSICALLY_CORRECT_LIGHTS)
float distanceFalloff=1.0/max(pow(lightDistance,decayExponent),0.01);if(cutoffDistance>0.0){distanceFalloff*=pow2(saturate(1.0-pow4(lightDistance/cutoffDistance)));}return distanceFalloff;
#else
if(cutoffDistance>0.0&&decayExponent>0.0){return pow(saturate(-lightDistance/cutoffDistance+1.0),decayExponent);}return 1.0;
#endif
}float getSpotAttenuation(const in float coneCosine,const in float penumbraCosine,const in float angleCosine){return smoothstep(coneCosine,penumbraCosine,angleCosine);}
#if NUM_DIR_LIGHTS>0
struct DirectionalLight{vec3 direction;vec3 color;};uniform DirectionalLight directionalLights[NUM_DIR_LIGHTS];void getDirectionalLightInfo(const in DirectionalLight directionalLight,const in GeometricContext geometry,out IncidentLight light){light.color=directionalLight.color;light.direction=directionalLight.direction;light.visible=true;}
#endif
#if NUM_POINT_LIGHTS>0
struct PointLight{vec3 position;vec3 color;float distance;float decay;};uniform PointLight pointLights[NUM_POINT_LIGHTS];void getPointLightInfo(const in PointLight pointLight,const in GeometricContext geometry,out IncidentLight light){vec3 lVector=pointLight.position-geometry.position;light.direction=normalize(lVector);float lightDistance=length(lVector);light.color=pointLight.color;light.color*=getDistanceAttenuation(lightDistance,pointLight.distance,pointLight.decay);light.visible=(light.color!=vec3(0.0));}
#endif
#if NUM_SPOT_LIGHTS>0
struct SpotLight{vec3 position;vec3 direction;vec3 color;float distance;float decay;float coneCos;float penumbraCos;};uniform SpotLight spotLights[NUM_SPOT_LIGHTS];void getSpotLightInfo(const in SpotLight spotLight,const in GeometricContext geometry,out IncidentLight light){vec3 lVector=spotLight.position-geometry.position;light.direction=normalize(lVector);float angleCos=dot(light.direction,spotLight.direction);float spotAttenuation=getSpotAttenuation(spotLight.coneCos,spotLight.penumbraCos,angleCos);if(spotAttenuation>0.0){float lightDistance=length(lVector);light.color=spotLight.color*spotAttenuation;light.color*=getDistanceAttenuation(lightDistance,spotLight.distance,spotLight.decay);light.visible=(light.color!=vec3(0.0));}else{light.color=vec3(0.0);light.visible=false;}}
#endif
#if NUM_RECT_AREA_LIGHTS>0
struct RectAreaLight{vec3 color;vec3 position;vec3 halfWidth;vec3 halfHeight;};uniform sampler2D ltc_1;uniform sampler2D ltc_2;uniform RectAreaLight rectAreaLights[NUM_RECT_AREA_LIGHTS];
#endif
#if NUM_HEMI_LIGHTS>0
struct HemisphereLight{vec3 direction;vec3 skyColor;vec3 groundColor;};uniform HemisphereLight hemisphereLights[NUM_HEMI_LIGHTS];vec3 getHemisphereLightIrradiance(const in HemisphereLight hemiLight,const in vec3 normal){float dotNL=dot(normal,hemiLight.direction);float hemiDiffuseWeight=0.5*dotNL+0.5;vec3 irradiance=mix(hemiLight.groundColor,hemiLight.skyColor,hemiDiffuseWeight);return irradiance;}
#endif`,os=`#if defined(USE_ENVMAP)
#ifdef ENVMAP_MODE_REFRACTION
uniform float refractionRatio;
#endif
vec3 getIBLIrradiance(const in vec3 normal){
#if defined(ENVMAP_TYPE_CUBE_UV)
vec3 worldNormal=inverseTransformDirection(normal,viewMatrix);vec4 envMapColor=textureCubeUV(envMap,worldNormal,1.0);return PI*envMapColor.rgb*envMapIntensity;
#else
return vec3(0.0);
#endif
}vec3 getIBLRadiance(const in vec3 viewDir,const in vec3 normal,const in float roughness){
#if defined(ENVMAP_TYPE_CUBE_UV)
vec3 reflectVec;
#ifdef ENVMAP_MODE_REFLECTION
reflectVec=reflect(-viewDir,normal);reflectVec=normalize(mix(reflectVec,normal,roughness*roughness));
#else
reflectVec=refract(-viewDir,normal,refractionRatio);
#endif
reflectVec=inverseTransformDirection(reflectVec,viewMatrix);vec4 envMapColor=textureCubeUV(envMap,reflectVec,roughness);return envMapColor.rgb*envMapIntensity;
#else
return vec3(0.0);
#endif
}
#endif`,ls="ToonMaterial material;material.diffuseColor=diffuseColor.rgb;",cs=`varying vec3 vViewPosition;struct ToonMaterial{vec3 diffuseColor;};void RE_Direct_Toon(const in IncidentLight directLight,const in GeometricContext geometry,const in ToonMaterial material,inout ReflectedLight reflectedLight){vec3 irradiance=getGradientIrradiance(geometry.normal,directLight.direction)*directLight.color;reflectedLight.directDiffuse+=irradiance*BRDF_Lambert(material.diffuseColor);}void RE_IndirectDiffuse_Toon(const in vec3 irradiance,const in GeometricContext geometry,const in ToonMaterial material,inout ReflectedLight reflectedLight){reflectedLight.indirectDiffuse+=irradiance*BRDF_Lambert(material.diffuseColor);}
#define RE_Direct RE_Direct_Toon
#define RE_IndirectDiffuse RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD(material)(0)`,us="BlinnPhongMaterial material;material.diffuseColor=diffuseColor.rgb;material.specularColor=specular;material.specularShininess=shininess;material.specularStrength=specularStrength;",hs=`varying vec3 vViewPosition;struct BlinnPhongMaterial{vec3 diffuseColor;vec3 specularColor;float specularShininess;float specularStrength;};void RE_Direct_BlinnPhong(const in IncidentLight directLight,const in GeometricContext geometry,const in BlinnPhongMaterial material,inout ReflectedLight reflectedLight){float dotNL=saturate(dot(geometry.normal,directLight.direction));vec3 irradiance=dotNL*directLight.color;reflectedLight.directDiffuse+=irradiance*BRDF_Lambert(material.diffuseColor);reflectedLight.directSpecular+=irradiance*BRDF_BlinnPhong(directLight.direction,geometry.viewDir,geometry.normal,material.specularColor,material.specularShininess)*material.specularStrength;}void RE_IndirectDiffuse_BlinnPhong(const in vec3 irradiance,const in GeometricContext geometry,const in BlinnPhongMaterial material,inout ReflectedLight reflectedLight){reflectedLight.indirectDiffuse+=irradiance*BRDF_Lambert(material.diffuseColor);}
#define RE_Direct RE_Direct_BlinnPhong
#define RE_IndirectDiffuse RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD(material)(0)`,ds=`PhysicalMaterial material;material.diffuseColor=diffuseColor.rgb*(1.0-metalnessFactor);vec3 dxy=max(abs(dFdx(geometryNormal)),abs(dFdy(geometryNormal)));float geometryRoughness=max(max(dxy.x,dxy.y),dxy.z);material.roughness=max(roughnessFactor,0.0525);material.roughness+=geometryRoughness;material.roughness=min(material.roughness,1.0);
#ifdef IOR
#ifdef SPECULAR
float specularIntensityFactor=specularIntensity;vec3 specularTintFactor=specularTint;
#ifdef USE_SPECULARINTENSITYMAP
specularIntensityFactor*=texture2D(specularIntensityMap,vUv).a;
#endif
#ifdef USE_SPECULARTINTMAP
specularTintFactor*=specularTintMapTexelToLinear(texture2D(specularTintMap,vUv)).rgb;
#endif
material.specularF90=mix(specularIntensityFactor,1.0,metalnessFactor);
#else
float specularIntensityFactor=1.0;vec3 specularTintFactor=vec3(1.0);material.specularF90=1.0;
#endif
material.specularColor=mix(min(pow2((ior-1.0)/(ior+1.0))*specularTintFactor,vec3(1.0))*specularIntensityFactor,diffuseColor.rgb,metalnessFactor);
#else
material.specularColor=mix(vec3(0.04),diffuseColor.rgb,metalnessFactor);material.specularF90=1.0;
#endif
#ifdef USE_CLEARCOAT
material.clearcoat=clearcoat;material.clearcoatRoughness=clearcoatRoughness;material.clearcoatF0=vec3(0.04);material.clearcoatF90=1.0;
#ifdef USE_CLEARCOATMAP
material.clearcoat*=texture2D(clearcoatMap,vUv).x;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
material.clearcoatRoughness*=texture2D(clearcoatRoughnessMap,vUv).y;
#endif
material.clearcoat=saturate(material.clearcoat);material.clearcoatRoughness=max(material.clearcoatRoughness,0.0525);material.clearcoatRoughness+=geometryRoughness;material.clearcoatRoughness=min(material.clearcoatRoughness,1.0);
#endif
#ifdef USE_SHEEN
material.sheenTint=sheenTint;material.sheenRoughness=clamp(sheenRoughness,0.07,1.0);
#endif`,fs=`struct PhysicalMaterial{vec3 diffuseColor;float roughness;vec3 specularColor;float specularF90;
#ifdef USE_CLEARCOAT
float clearcoat;float clearcoatRoughness;vec3 clearcoatF0;float clearcoatF90;
#endif
#ifdef USE_SHEEN
vec3 sheenTint;float sheenRoughness;
#endif
};vec3 clearcoatSpecular=vec3(0.0);vec2 DFGApprox(const in vec3 normal,const in vec3 viewDir,const in float roughness){float dotNV=saturate(dot(normal,viewDir));const vec4 c0=vec4(-1,-0.0275,-0.572,0.022);const vec4 c1=vec4(1,0.0425,1.04,-0.04);vec4 r=roughness*c0+c1;float a004=min(r.x*r.x,exp2(-9.28*dotNV))*r.x+r.y;vec2 fab=vec2(-1.04,1.04)*a004+r.zw;return fab;}vec3 EnvironmentBRDF(const in vec3 normal,const in vec3 viewDir,const in vec3 specularColor,const in float specularF90,const in float roughness){vec2 fab=DFGApprox(normal,viewDir,roughness);return specularColor*fab.x+specularF90*fab.y;}void computeMultiscattering(const in vec3 normal,const in vec3 viewDir,const in vec3 specularColor,const in float specularF90,const in float roughness,inout vec3 singleScatter,inout vec3 multiScatter){vec2 fab=DFGApprox(normal,viewDir,roughness);vec3 FssEss=specularColor*fab.x+specularF90*fab.y;float Ess=fab.x+fab.y;float Ems=1.0-Ess;vec3 Favg=specularColor+(1.0-specularColor)*0.047619;vec3 Fms=FssEss*Favg/(1.0-Ems*Favg);singleScatter+=FssEss;multiScatter+=Fms*Ems;}
#if NUM_RECT_AREA_LIGHTS>0
void RE_Direct_RectArea_Physical(const in RectAreaLight rectAreaLight,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){vec3 normal=geometry.normal;vec3 viewDir=geometry.viewDir;vec3 position=geometry.position;vec3 lightPos=rectAreaLight.position;vec3 halfWidth=rectAreaLight.halfWidth;vec3 halfHeight=rectAreaLight.halfHeight;vec3 lightColor=rectAreaLight.color;float roughness=material.roughness;vec3 rectCoords[4];rectCoords[0]=lightPos+halfWidth-halfHeight;rectCoords[1]=lightPos-halfWidth-halfHeight;rectCoords[2]=lightPos-halfWidth+halfHeight;rectCoords[3]=lightPos+halfWidth+halfHeight;vec2 uv=LTC_Uv(normal,viewDir,roughness);vec4 t1=texture2D(ltc_1,uv);vec4 t2=texture2D(ltc_2,uv);mat3 mInv=mat3(vec3(t1.x,0,t1.y),vec3(0,1,0),vec3(t1.z,0,t1.w));vec3 fresnel=(material.specularColor*t2.x+(vec3(1.0)-material.specularColor)*t2.y);reflectedLight.directSpecular+=lightColor*fresnel*LTC_Evaluate(normal,viewDir,position,mInv,rectCoords);reflectedLight.directDiffuse+=lightColor*material.diffuseColor*LTC_Evaluate(normal,viewDir,position,mat3(1.0),rectCoords);}
#endif
void RE_Direct_Physical(const in IncidentLight directLight,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){float dotNL=saturate(dot(geometry.normal,directLight.direction));vec3 irradiance=dotNL*directLight.color;
#ifdef USE_CLEARCOAT
float dotNLcc=saturate(dot(geometry.clearcoatNormal,directLight.direction));vec3 ccIrradiance=dotNLcc*directLight.color;clearcoatSpecular+=ccIrradiance*BRDF_GGX(directLight.direction,geometry.viewDir,geometry.clearcoatNormal,material.clearcoatF0,material.clearcoatF90,material.clearcoatRoughness);
#endif
#ifdef USE_SHEEN
reflectedLight.directSpecular+=irradiance*BRDF_Sheen(directLight.direction,geometry.viewDir,geometry.normal,material.sheenTint,material.sheenRoughness);
#endif
reflectedLight.directSpecular+=irradiance*BRDF_GGX(directLight.direction,geometry.viewDir,geometry.normal,material.specularColor,material.specularF90,material.roughness);reflectedLight.directDiffuse+=irradiance*BRDF_Lambert(material.diffuseColor);}void RE_IndirectDiffuse_Physical(const in vec3 irradiance,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){reflectedLight.indirectDiffuse+=irradiance*BRDF_Lambert(material.diffuseColor);}void RE_IndirectSpecular_Physical(const in vec3 radiance,const in vec3 irradiance,const in vec3 clearcoatRadiance,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){
#ifdef USE_CLEARCOAT
clearcoatSpecular+=clearcoatRadiance*EnvironmentBRDF(geometry.clearcoatNormal,geometry.viewDir,material.clearcoatF0,material.clearcoatF90,material.clearcoatRoughness);
#endif
vec3 singleScattering=vec3(0.0);vec3 multiScattering=vec3(0.0);vec3 cosineWeightedIrradiance=irradiance*RECIPROCAL_PI;computeMultiscattering(geometry.normal,geometry.viewDir,material.specularColor,material.specularF90,material.roughness,singleScattering,multiScattering);vec3 diffuse=material.diffuseColor*(1.0-(singleScattering+multiScattering));reflectedLight.indirectSpecular+=radiance*singleScattering;reflectedLight.indirectSpecular+=multiScattering*cosineWeightedIrradiance;reflectedLight.indirectDiffuse+=diffuse*cosineWeightedIrradiance;}
#define RE_Direct RE_Direct_Physical
#define RE_Direct_RectArea RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular RE_IndirectSpecular_Physical
float computeSpecularOcclusion(const in float dotNV,const in float ambientOcclusion,const in float roughness){return saturate(pow(dotNV+ambientOcclusion,exp2(-16.0*roughness-1.0))-1.0+ambientOcclusion);}`,ps=`GeometricContext geometry;geometry.position=-vViewPosition;geometry.normal=normal;geometry.viewDir=(isOrthographic)?vec3(0,0,1):normalize(vViewPosition);
#ifdef USE_CLEARCOAT
geometry.clearcoatNormal=clearcoatNormal;
#endif
IncidentLight directLight;
#if (NUM_POINT_LIGHTS>0)&&defined(RE_Direct)
PointLight pointLight;
#if defined(USE_SHADOWMAP)&&NUM_POINT_LIGHT_SHADOWS>0
PointLightShadow pointLightShadow;
#endif
#pragma unroll_loop_start
for(int i=0;i<NUM_POINT_LIGHTS;i++){pointLight=pointLights[i];getPointLightInfo(pointLight,geometry,directLight);
#if defined(USE_SHADOWMAP)&&(UNROLLED_LOOP_INDEX<NUM_POINT_LIGHT_SHADOWS)
pointLightShadow=pointLightShadows[i];directLight.color*=all(bvec2(directLight.visible,receiveShadow))?getPointShadow(pointShadowMap[i],pointLightShadow.shadowMapSize,pointLightShadow.shadowBias,pointLightShadow.shadowRadius,vPointShadowCoord[i],pointLightShadow.shadowCameraNear,pointLightShadow.shadowCameraFar):1.0;
#endif
RE_Direct(directLight,geometry,material,reflectedLight);}
#pragma unroll_loop_end
#endif
#if (NUM_SPOT_LIGHTS>0)&&defined(RE_Direct)
SpotLight spotLight;
#if defined(USE_SHADOWMAP)&&NUM_SPOT_LIGHT_SHADOWS>0
SpotLightShadow spotLightShadow;
#endif
#pragma unroll_loop_start
for(int i=0;i<NUM_SPOT_LIGHTS;i++){spotLight=spotLights[i];getSpotLightInfo(spotLight,geometry,directLight);
#if defined(USE_SHADOWMAP)&&(UNROLLED_LOOP_INDEX<NUM_SPOT_LIGHT_SHADOWS)
spotLightShadow=spotLightShadows[i];directLight.color*=all(bvec2(directLight.visible,receiveShadow))?getShadow(spotShadowMap[i],spotLightShadow.shadowMapSize,spotLightShadow.shadowBias,spotLightShadow.shadowRadius,vSpotShadowCoord[i]):1.0;
#endif
RE_Direct(directLight,geometry,material,reflectedLight);}
#pragma unroll_loop_end
#endif
#if (NUM_DIR_LIGHTS>0)&&defined(RE_Direct)
DirectionalLight directionalLight;
#if defined(USE_SHADOWMAP)&&NUM_DIR_LIGHT_SHADOWS>0
DirectionalLightShadow directionalLightShadow;
#endif
#pragma unroll_loop_start
for(int i=0;i<NUM_DIR_LIGHTS;i++){directionalLight=directionalLights[i];getDirectionalLightInfo(directionalLight,geometry,directLight);
#if defined(USE_SHADOWMAP)&&(UNROLLED_LOOP_INDEX<NUM_DIR_LIGHT_SHADOWS)
directionalLightShadow=directionalLightShadows[i];directLight.color*=all(bvec2(directLight.visible,receiveShadow))?getShadow(directionalShadowMap[i],directionalLightShadow.shadowMapSize,directionalLightShadow.shadowBias,directionalLightShadow.shadowRadius,vDirectionalShadowCoord[i]):1.0;
#endif
RE_Direct(directLight,geometry,material,reflectedLight);}
#pragma unroll_loop_end
#endif
#if (NUM_RECT_AREA_LIGHTS>0)&&defined(RE_Direct_RectArea)
RectAreaLight rectAreaLight;
#pragma unroll_loop_start
for(int i=0;i<NUM_RECT_AREA_LIGHTS;i++){rectAreaLight=rectAreaLights[i];RE_Direct_RectArea(rectAreaLight,geometry,material,reflectedLight);}
#pragma unroll_loop_end
#endif
#if defined(RE_IndirectDiffuse)
vec3 iblIrradiance=vec3(0.0);vec3 irradiance=getAmbientLightIrradiance(ambientLightColor);irradiance+=getLightProbeIrradiance(lightProbe,geometry.normal);
#if (NUM_HEMI_LIGHTS>0)
#pragma unroll_loop_start
for(int i=0;i<NUM_HEMI_LIGHTS;i++){irradiance+=getHemisphereLightIrradiance(hemisphereLights[i],geometry.normal);}
#pragma unroll_loop_end
#endif
#endif
#if defined(RE_IndirectSpecular)
vec3 radiance=vec3(0.0);vec3 clearcoatRadiance=vec3(0.0);
#endif`,ms=`#if defined(RE_IndirectDiffuse)
#ifdef USE_LIGHTMAP
vec4 lightMapTexel=texture2D(lightMap,vUv2);vec3 lightMapIrradiance=lightMapTexelToLinear(lightMapTexel).rgb*lightMapIntensity;
#ifndef PHYSICALLY_CORRECT_LIGHTS
lightMapIrradiance*=PI;
#endif
irradiance+=lightMapIrradiance;
#endif
#if defined(USE_ENVMAP)&&defined(STANDARD)&&defined(ENVMAP_TYPE_CUBE_UV)
iblIrradiance+=getIBLIrradiance(geometry.normal);
#endif
#endif
#if defined(USE_ENVMAP)&&defined(RE_IndirectSpecular)
radiance+=getIBLRadiance(geometry.viewDir,geometry.normal,material.roughness);
#ifdef USE_CLEARCOAT
clearcoatRadiance+=getIBLRadiance(geometry.viewDir,geometry.clearcoatNormal,material.clearcoatRoughness);
#endif
#endif`,gs=`#if defined(RE_IndirectDiffuse)
RE_IndirectDiffuse(irradiance,geometry,material,reflectedLight);
#endif
#if defined(RE_IndirectSpecular)
RE_IndirectSpecular(radiance,iblIrradiance,clearcoatRadiance,geometry,material,reflectedLight);
#endif`,_s=`#if defined(USE_LOGDEPTHBUF)&&defined(USE_LOGDEPTHBUF_EXT)
gl_FragDepthEXT=vIsPerspective==0.0?gl_FragCoord.z:log2(vFragDepth)*logDepthBufFC*0.5;
#endif`,xs=`#if defined(USE_LOGDEPTHBUF)&&defined(USE_LOGDEPTHBUF_EXT)
uniform float logDepthBufFC;varying float vFragDepth;varying float vIsPerspective;
#endif`,vs=`#ifdef USE_LOGDEPTHBUF
#ifdef USE_LOGDEPTHBUF_EXT
varying float vFragDepth;varying float vIsPerspective;
#else
uniform float logDepthBufFC;
#endif
#endif`,Ms=`#ifdef USE_LOGDEPTHBUF
#ifdef USE_LOGDEPTHBUF_EXT
vFragDepth=1.0+gl_Position.w;vIsPerspective=float(isPerspectiveMatrix(projectionMatrix));
#else
if(isPerspectiveMatrix(projectionMatrix)){gl_Position.z=log2(max(EPSILON,gl_Position.w+1.0))*logDepthBufFC-1.0;gl_Position.z*=gl_Position.w;}
#endif
#endif`,ys=`#ifdef USE_MAP
vec4 texelColor=texture2D(map,vUv);texelColor=mapTexelToLinear(texelColor);diffuseColor*=texelColor;
#endif`,Ss=`#ifdef USE_MAP
uniform sampler2D map;
#endif`,bs=`#if defined(USE_MAP)||defined(USE_ALPHAMAP)
vec2 uv=(uvTransform*vec3(gl_PointCoord.x,1.0-gl_PointCoord.y,1)).xy;
#endif
#ifdef USE_MAP
vec4 mapTexel=texture2D(map,uv);diffuseColor*=mapTexelToLinear(mapTexel);
#endif
#ifdef USE_ALPHAMAP
diffuseColor.a*=texture2D(alphaMap,uv).g;
#endif`,ws=`#if defined(USE_MAP)||defined(USE_ALPHAMAP)
uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
uniform sampler2D alphaMap;
#endif`,Ts=`float metalnessFactor=metalness;
#ifdef USE_METALNESSMAP
vec4 texelMetalness=texture2D(metalnessMap,vUv);metalnessFactor*=texelMetalness.b;
#endif`,As=`#ifdef USE_METALNESSMAP
uniform sampler2D metalnessMap;
#endif`,Es=`#ifdef USE_MORPHNORMALS
objectNormal*=morphTargetBaseInfluence;
#ifdef MORPHTARGETS_TEXTURE
for(int i=0;i<MORPHTARGETS_COUNT;i++){if(morphTargetInfluences[i]>0.0)objectNormal+=getMorph(gl_VertexID,i,1,2)*morphTargetInfluences[i];}
#else
objectNormal+=morphNormal0*morphTargetInfluences[0];objectNormal+=morphNormal1*morphTargetInfluences[1];objectNormal+=morphNormal2*morphTargetInfluences[2];objectNormal+=morphNormal3*morphTargetInfluences[3];
#endif
#endif`,Ls=`#ifdef USE_MORPHTARGETS
uniform float morphTargetBaseInfluence;
#ifdef MORPHTARGETS_TEXTURE
uniform float morphTargetInfluences[MORPHTARGETS_COUNT];uniform sampler2DArray morphTargetsTexture;uniform vec2 morphTargetsTextureSize;vec3 getMorph(const in int vertexIndex,const in int morphTargetIndex,const in int offset,const in int stride){float texelIndex=float(vertexIndex*stride+offset);float y=floor(texelIndex/morphTargetsTextureSize.x);float x=texelIndex-y*morphTargetsTextureSize.x;vec3 morphUV=vec3((x+0.5)/morphTargetsTextureSize.x,y/morphTargetsTextureSize.y,morphTargetIndex);return texture(morphTargetsTexture,morphUV).xyz;}
#else
#ifndef USE_MORPHNORMALS
uniform float morphTargetInfluences[8];
#else
uniform float morphTargetInfluences[4];
#endif
#endif
#endif`,Cs=`#ifdef USE_MORPHTARGETS
transformed*=morphTargetBaseInfluence;
#ifdef MORPHTARGETS_TEXTURE
for(int i=0;i<MORPHTARGETS_COUNT;i++){
#ifndef USE_MORPHNORMALS
if(morphTargetInfluences[i]>0.0)transformed+=getMorph(gl_VertexID,i,0,1)*morphTargetInfluences[i];
#else
if(morphTargetInfluences[i]>0.0)transformed+=getMorph(gl_VertexID,i,0,2)*morphTargetInfluences[i];
#endif
}
#else
transformed+=morphTarget0*morphTargetInfluences[0];transformed+=morphTarget1*morphTargetInfluences[1];transformed+=morphTarget2*morphTargetInfluences[2];transformed+=morphTarget3*morphTargetInfluences[3];
#ifndef USE_MORPHNORMALS
transformed+=morphTarget4*morphTargetInfluences[4];transformed+=morphTarget5*morphTargetInfluences[5];transformed+=morphTarget6*morphTargetInfluences[6];transformed+=morphTarget7*morphTargetInfluences[7];
#endif
#endif
#endif`,Rs=`float faceDirection=gl_FrontFacing?1.0:-1.0;
#ifdef FLAT_SHADED
vec3 fdx=vec3(dFdx(vViewPosition.x),dFdx(vViewPosition.y),dFdx(vViewPosition.z));vec3 fdy=vec3(dFdy(vViewPosition.x),dFdy(vViewPosition.y),dFdy(vViewPosition.z));vec3 normal=normalize(cross(fdx,fdy));
#else
vec3 normal=normalize(vNormal);
#ifdef DOUBLE_SIDED
normal=normal*faceDirection;
#endif
#ifdef USE_TANGENT
vec3 tangent=normalize(vTangent);vec3 bitangent=normalize(vBitangent);
#ifdef DOUBLE_SIDED
tangent=tangent*faceDirection;bitangent=bitangent*faceDirection;
#endif
#if defined(TANGENTSPACE_NORMALMAP)||defined(USE_CLEARCOAT_NORMALMAP)
mat3 vTBN=mat3(tangent,bitangent,normal);
#endif
#endif
#endif
vec3 geometryNormal=normal;`,Ds=`#ifdef OBJECTSPACE_NORMALMAP
normal=texture2D(normalMap,vUv).xyz*2.0-1.0;
#ifdef FLIP_SIDED
normal=-normal;
#endif
#ifdef DOUBLE_SIDED
normal=normal*faceDirection;
#endif
normal=normalize(normalMatrix*normal);
#elif defined(TANGENTSPACE_NORMALMAP)
vec3 mapN=texture2D(normalMap,vUv).xyz*2.0-1.0;mapN.xy*=normalScale;
#ifdef USE_TANGENT
normal=normalize(vTBN*mapN);
#else
normal=perturbNormal2Arb(-vViewPosition,normal,mapN,faceDirection);
#endif
#elif defined(USE_BUMPMAP)
normal=perturbNormalArb(-vViewPosition,normal,dHdxy_fwd(),faceDirection);
#endif`,Ps=`#ifndef FLAT_SHADED
varying vec3 vNormal;
#ifdef USE_TANGENT
varying vec3 vTangent;varying vec3 vBitangent;
#endif
#endif`,Fs=`#ifndef FLAT_SHADED
varying vec3 vNormal;
#ifdef USE_TANGENT
varying vec3 vTangent;varying vec3 vBitangent;
#endif
#endif`,Is=`#ifndef FLAT_SHADED
vNormal=normalize(transformedNormal);
#ifdef USE_TANGENT
vTangent=normalize(transformedTangent);vBitangent=normalize(cross(vNormal,vTangent)*tangent.w);
#endif
#endif`,Ns=`#ifdef USE_NORMALMAP
uniform sampler2D normalMap;uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
uniform mat3 normalMatrix;
#endif
#if !defined(USE_TANGENT)&&(defined(TANGENTSPACE_NORMALMAP)||defined(USE_CLEARCOAT_NORMALMAP))
vec3 perturbNormal2Arb(vec3 eye_pos,vec3 surf_norm,vec3 mapN,float faceDirection){vec3 q0=vec3(dFdx(eye_pos.x),dFdx(eye_pos.y),dFdx(eye_pos.z));vec3 q1=vec3(dFdy(eye_pos.x),dFdy(eye_pos.y),dFdy(eye_pos.z));vec2 st0=dFdx(vUv.st);vec2 st1=dFdy(vUv.st);vec3 N=surf_norm;vec3 q1perp=cross(q1,N);vec3 q0perp=cross(N,q0);vec3 T=q1perp*st0.x+q0perp*st1.x;vec3 B=q1perp*st0.y+q0perp*st1.y;float det=max(dot(T,T),dot(B,B));float scale=(det==0.0)?0.0:faceDirection*inversesqrt(det);return normalize(T*(mapN.x*scale)+B*(mapN.y*scale)+N*mapN.z);}
#endif`,Bs=`#ifdef USE_CLEARCOAT
vec3 clearcoatNormal=geometryNormal;
#endif`,zs=`#ifdef USE_CLEARCOAT_NORMALMAP
vec3 clearcoatMapN=texture2D(clearcoatNormalMap,vUv).xyz*2.0-1.0;clearcoatMapN.xy*=clearcoatNormalScale;
#ifdef USE_TANGENT
clearcoatNormal=normalize(vTBN*clearcoatMapN);
#else
clearcoatNormal=perturbNormal2Arb(-vViewPosition,clearcoatNormal,clearcoatMapN,faceDirection);
#endif
#endif`,Us=`#ifdef USE_CLEARCOATMAP
uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
uniform sampler2D clearcoatNormalMap;uniform vec2 clearcoatNormalScale;
#endif`,Gs=`#ifdef OPAQUE
diffuseColor.a=1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a*=transmissionAlpha+0.1;
#endif
gl_FragColor=vec4(outgoingLight,diffuseColor.a);`,Os="vec3 packNormalToRGB(const in vec3 normal){return normalize(normal)*0.5+0.5;}vec3 unpackRGBToNormal(const in vec3 rgb){return 2.0*rgb.xyz-1.0;}const float PackUpscale=256./255.;const float UnpackDownscale=255./256.;const vec3 PackFactors=vec3(256.*256.*256.,256.*256.,256.);const vec4 UnpackFactors=UnpackDownscale/vec4(PackFactors,1.);const float ShiftRight8=1./256.;vec4 packDepthToRGBA(const in float v){vec4 r=vec4(fract(v*PackFactors),v);r.yzw-=r.xyz*ShiftRight8;return r*PackUpscale;}float unpackRGBAToDepth(const in vec4 v){return dot(v,UnpackFactors);}vec4 pack2HalfToRGBA(vec2 v){vec4 r=vec4(v.x,fract(v.x*255.0),v.y,fract(v.y*255.0));return vec4(r.x-r.y/255.0,r.y,r.z-r.w/255.0,r.w);}vec2 unpackRGBATo2Half(vec4 v){return vec2(v.x+(v.y/255.0),v.z+(v.w/255.0));}float viewZToOrthographicDepth(const in float viewZ,const in float near,const in float far){return(viewZ+near)/(near-far);}float orthographicDepthToViewZ(const in float linearClipZ,const in float near,const in float far){return linearClipZ*(near-far)-near;}float viewZToPerspectiveDepth(const in float viewZ,const in float near,const in float far){return((near+viewZ)*far)/((far-near)*viewZ);}float perspectiveDepthToViewZ(const in float invClipZ,const in float near,const in float far){return(near*far)/((far-near)*invClipZ-far);}",Vs=`#ifdef PREMULTIPLIED_ALPHA
gl_FragColor.rgb*=gl_FragColor.a;
#endif`,ks=`vec4 mvPosition=vec4(transformed,1.0);
#ifdef USE_INSTANCING
mvPosition=instanceMatrix*mvPosition;
#endif
mvPosition=modelViewMatrix*mvPosition;gl_Position=projectionMatrix*mvPosition;`,Ws=`#ifdef DITHERING
gl_FragColor.rgb=dithering(gl_FragColor.rgb);
#endif`,Hs=`#ifdef DITHERING
vec3 dithering(vec3 color){float grid_position=rand(gl_FragCoord.xy);vec3 dither_shift_RGB=vec3(0.25/255.0,-0.25/255.0,0.25/255.0);dither_shift_RGB=mix(2.0*dither_shift_RGB,-2.0*dither_shift_RGB,grid_position);return color+dither_shift_RGB;}
#endif`,qs=`float roughnessFactor=roughness;
#ifdef USE_ROUGHNESSMAP
vec4 texelRoughness=texture2D(roughnessMap,vUv);roughnessFactor*=texelRoughness.g;
#endif`,Xs=`#ifdef USE_ROUGHNESSMAP
uniform sampler2D roughnessMap;
#endif`,Ys=`#ifdef USE_SHADOWMAP
#if NUM_DIR_LIGHT_SHADOWS>0
uniform sampler2D directionalShadowMap[NUM_DIR_LIGHT_SHADOWS];varying vec4 vDirectionalShadowCoord[NUM_DIR_LIGHT_SHADOWS];struct DirectionalLightShadow{float shadowBias;float shadowNormalBias;float shadowRadius;vec2 shadowMapSize;};uniform DirectionalLightShadow directionalLightShadows[NUM_DIR_LIGHT_SHADOWS];
#endif
#if NUM_SPOT_LIGHT_SHADOWS>0
uniform sampler2D spotShadowMap[NUM_SPOT_LIGHT_SHADOWS];varying vec4 vSpotShadowCoord[NUM_SPOT_LIGHT_SHADOWS];struct SpotLightShadow{float shadowBias;float shadowNormalBias;float shadowRadius;vec2 shadowMapSize;};uniform SpotLightShadow spotLightShadows[NUM_SPOT_LIGHT_SHADOWS];
#endif
#if NUM_POINT_LIGHT_SHADOWS>0
uniform sampler2D pointShadowMap[NUM_POINT_LIGHT_SHADOWS];varying vec4 vPointShadowCoord[NUM_POINT_LIGHT_SHADOWS];struct PointLightShadow{float shadowBias;float shadowNormalBias;float shadowRadius;vec2 shadowMapSize;float shadowCameraNear;float shadowCameraFar;};uniform PointLightShadow pointLightShadows[NUM_POINT_LIGHT_SHADOWS];
#endif
float texture2DCompare(sampler2D depths,vec2 uv,float compare){return step(compare,unpackRGBAToDepth(texture2D(depths,uv)));}vec2 texture2DDistribution(sampler2D shadow,vec2 uv){return unpackRGBATo2Half(texture2D(shadow,uv));}float VSMShadow(sampler2D shadow,vec2 uv,float compare){float occlusion=1.0;vec2 distribution=texture2DDistribution(shadow,uv);float hard_shadow=step(compare,distribution.x);if(hard_shadow!=1.0){float distance=compare-distribution.x;float variance=max(0.00000,distribution.y*distribution.y);float softness_probability=variance/(variance+distance*distance);softness_probability=clamp((softness_probability-0.3)/(0.95-0.3),0.0,1.0);occlusion=clamp(max(hard_shadow,softness_probability),0.0,1.0);}return occlusion;}float getShadow(sampler2D shadowMap,vec2 shadowMapSize,float shadowBias,float shadowRadius,vec4 shadowCoord){float shadow=1.0;shadowCoord.xyz/=shadowCoord.w;shadowCoord.z+=shadowBias;bvec4 inFrustumVec=bvec4(shadowCoord.x>=0.0,shadowCoord.x<=1.0,shadowCoord.y>=0.0,shadowCoord.y<=1.0);bool inFrustum=all(inFrustumVec);bvec2 frustumTestVec=bvec2(inFrustum,shadowCoord.z<=1.0);bool frustumTest=all(frustumTestVec);if(frustumTest){
#if defined(SHADOWMAP_TYPE_PCF)
vec2 texelSize=vec2(1.0)/shadowMapSize;float dx0=-texelSize.x*shadowRadius;float dy0=-texelSize.y*shadowRadius;float dx1=+texelSize.x*shadowRadius;float dy1=+texelSize.y*shadowRadius;float dx2=dx0/2.0;float dy2=dy0/2.0;float dx3=dx1/2.0;float dy3=dy1/2.0;shadow=(texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx0,dy0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(0.0,dy0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx1,dy0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx2,dy2),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(0.0,dy2),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx3,dy2),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx0,0.0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx2,0.0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy,shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx3,0.0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx1,0.0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx2,dy3),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(0.0,dy3),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx3,dy3),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx0,dy1),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(0.0,dy1),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx1,dy1),shadowCoord.z))*(1.0/17.0);
#elif defined(SHADOWMAP_TYPE_PCF_SOFT)
vec2 texelSize=vec2(1.0)/shadowMapSize;float dx=texelSize.x;float dy=texelSize.y;vec2 uv=shadowCoord.xy;vec2 f=fract(uv*shadowMapSize+0.5);uv-=f*texelSize;shadow=(texture2DCompare(shadowMap,uv,shadowCoord.z)+texture2DCompare(shadowMap,uv+vec2(dx,0.0),shadowCoord.z)+texture2DCompare(shadowMap,uv+vec2(0.0,dy),shadowCoord.z)+texture2DCompare(shadowMap,uv+texelSize,shadowCoord.z)+mix(texture2DCompare(shadowMap,uv+vec2(-dx,0.0),shadowCoord.z),texture2DCompare(shadowMap,uv+vec2(2.0*dx,0.0),shadowCoord.z),f.x)+mix(texture2DCompare(shadowMap,uv+vec2(-dx,dy),shadowCoord.z),texture2DCompare(shadowMap,uv+vec2(2.0*dx,dy),shadowCoord.z),f.x)+mix(texture2DCompare(shadowMap,uv+vec2(0.0,-dy),shadowCoord.z),texture2DCompare(shadowMap,uv+vec2(0.0,2.0*dy),shadowCoord.z),f.y)+mix(texture2DCompare(shadowMap,uv+vec2(dx,-dy),shadowCoord.z),texture2DCompare(shadowMap,uv+vec2(dx,2.0*dy),shadowCoord.z),f.y)+mix(mix(texture2DCompare(shadowMap,uv+vec2(-dx,-dy),shadowCoord.z),texture2DCompare(shadowMap,uv+vec2(2.0*dx,-dy),shadowCoord.z),f.x),mix(texture2DCompare(shadowMap,uv+vec2(-dx,2.0*dy),shadowCoord.z),texture2DCompare(shadowMap,uv+vec2(2.0*dx,2.0*dy),shadowCoord.z),f.x),f.y))*(1.0/9.0);
#elif defined(SHADOWMAP_TYPE_VSM)
shadow=VSMShadow(shadowMap,shadowCoord.xy,shadowCoord.z);
#else
shadow=texture2DCompare(shadowMap,shadowCoord.xy,shadowCoord.z);
#endif
}return shadow;}vec2 cubeToUV(vec3 v,float texelSizeY){vec3 absV=abs(v);float scaleToCube=1.0/max(absV.x,max(absV.y,absV.z));absV*=scaleToCube;v*=scaleToCube*(1.0-2.0*texelSizeY);vec2 planar=v.xy;float almostATexel=1.5*texelSizeY;float almostOne=1.0-almostATexel;if(absV.z>=almostOne){if(v.z>0.0)planar.x=4.0-v.x;}else if(absV.x>=almostOne){float signX=sign(v.x);planar.x=v.z*signX+2.0*signX;}else if(absV.y>=almostOne){float signY=sign(v.y);planar.x=v.x+2.0*signY+2.0;planar.y=v.z*signY-2.0;}return vec2(0.125,0.25)*planar+vec2(0.375,0.75);}float getPointShadow(sampler2D shadowMap,vec2 shadowMapSize,float shadowBias,float shadowRadius,vec4 shadowCoord,float shadowCameraNear,float shadowCameraFar){vec2 texelSize=vec2(1.0)/(shadowMapSize*vec2(4.0,2.0));vec3 lightToPosition=shadowCoord.xyz;float dp=(length(lightToPosition)-shadowCameraNear)/(shadowCameraFar-shadowCameraNear);dp+=shadowBias;vec3 bd3D=normalize(lightToPosition);
#if defined(SHADOWMAP_TYPE_PCF)||defined(SHADOWMAP_TYPE_PCF_SOFT)||defined(SHADOWMAP_TYPE_VSM)
vec2 offset=vec2(-1,1)*shadowRadius*texelSize.y;return(texture2DCompare(shadowMap,cubeToUV(bd3D+offset.xyy,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.yyy,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.xyx,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.yyx,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.xxy,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.yxy,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.xxx,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.yxx,texelSize.y),dp))*(1.0/9.0);
#else
return texture2DCompare(shadowMap,cubeToUV(bd3D,texelSize.y),dp);
#endif
}
#endif`,Zs=`#ifdef USE_SHADOWMAP
#if NUM_DIR_LIGHT_SHADOWS>0
uniform mat4 directionalShadowMatrix[NUM_DIR_LIGHT_SHADOWS];varying vec4 vDirectionalShadowCoord[NUM_DIR_LIGHT_SHADOWS];struct DirectionalLightShadow{float shadowBias;float shadowNormalBias;float shadowRadius;vec2 shadowMapSize;};uniform DirectionalLightShadow directionalLightShadows[NUM_DIR_LIGHT_SHADOWS];
#endif
#if NUM_SPOT_LIGHT_SHADOWS>0
uniform mat4 spotShadowMatrix[NUM_SPOT_LIGHT_SHADOWS];varying vec4 vSpotShadowCoord[NUM_SPOT_LIGHT_SHADOWS];struct SpotLightShadow{float shadowBias;float shadowNormalBias;float shadowRadius;vec2 shadowMapSize;};uniform SpotLightShadow spotLightShadows[NUM_SPOT_LIGHT_SHADOWS];
#endif
#if NUM_POINT_LIGHT_SHADOWS>0
uniform mat4 pointShadowMatrix[NUM_POINT_LIGHT_SHADOWS];varying vec4 vPointShadowCoord[NUM_POINT_LIGHT_SHADOWS];struct PointLightShadow{float shadowBias;float shadowNormalBias;float shadowRadius;vec2 shadowMapSize;float shadowCameraNear;float shadowCameraFar;};uniform PointLightShadow pointLightShadows[NUM_POINT_LIGHT_SHADOWS];
#endif
#endif`,js=`#ifdef USE_SHADOWMAP
#if NUM_DIR_LIGHT_SHADOWS>0||NUM_SPOT_LIGHT_SHADOWS>0||NUM_POINT_LIGHT_SHADOWS>0
vec3 shadowWorldNormal=inverseTransformDirection(transformedNormal,viewMatrix);vec4 shadowWorldPosition;
#endif
#if NUM_DIR_LIGHT_SHADOWS>0
#pragma unroll_loop_start
for(int i=0;i<NUM_DIR_LIGHT_SHADOWS;i++){shadowWorldPosition=worldPosition+vec4(shadowWorldNormal*directionalLightShadows[i].shadowNormalBias,0);vDirectionalShadowCoord[i]=directionalShadowMatrix[i]*shadowWorldPosition;}
#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHT_SHADOWS>0
#pragma unroll_loop_start
for(int i=0;i<NUM_SPOT_LIGHT_SHADOWS;i++){shadowWorldPosition=worldPosition+vec4(shadowWorldNormal*spotLightShadows[i].shadowNormalBias,0);vSpotShadowCoord[i]=spotShadowMatrix[i]*shadowWorldPosition;}
#pragma unroll_loop_end
#endif
#if NUM_POINT_LIGHT_SHADOWS>0
#pragma unroll_loop_start
for(int i=0;i<NUM_POINT_LIGHT_SHADOWS;i++){shadowWorldPosition=worldPosition+vec4(shadowWorldNormal*pointLightShadows[i].shadowNormalBias,0);vPointShadowCoord[i]=pointShadowMatrix[i]*shadowWorldPosition;}
#pragma unroll_loop_end
#endif
#endif`,Js=`float getShadowMask(){float shadow=1.0;
#ifdef USE_SHADOWMAP
#if NUM_DIR_LIGHT_SHADOWS>0
DirectionalLightShadow directionalLight;
#pragma unroll_loop_start
for(int i=0;i<NUM_DIR_LIGHT_SHADOWS;i++){directionalLight=directionalLightShadows[i];shadow*=receiveShadow?getShadow(directionalShadowMap[i],directionalLight.shadowMapSize,directionalLight.shadowBias,directionalLight.shadowRadius,vDirectionalShadowCoord[i]):1.0;}
#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHT_SHADOWS>0
SpotLightShadow spotLight;
#pragma unroll_loop_start
for(int i=0;i<NUM_SPOT_LIGHT_SHADOWS;i++){spotLight=spotLightShadows[i];shadow*=receiveShadow?getShadow(spotShadowMap[i],spotLight.shadowMapSize,spotLight.shadowBias,spotLight.shadowRadius,vSpotShadowCoord[i]):1.0;}
#pragma unroll_loop_end
#endif
#if NUM_POINT_LIGHT_SHADOWS>0
PointLightShadow pointLight;
#pragma unroll_loop_start
for(int i=0;i<NUM_POINT_LIGHT_SHADOWS;i++){pointLight=pointLightShadows[i];shadow*=receiveShadow?getPointShadow(pointShadowMap[i],pointLight.shadowMapSize,pointLight.shadowBias,pointLight.shadowRadius,vPointShadowCoord[i],pointLight.shadowCameraNear,pointLight.shadowCameraFar):1.0;}
#pragma unroll_loop_end
#endif
#endif
return shadow;}`,$s=`#ifdef USE_SKINNING
mat4 boneMatX=getBoneMatrix(skinIndex.x);mat4 boneMatY=getBoneMatrix(skinIndex.y);mat4 boneMatZ=getBoneMatrix(skinIndex.z);mat4 boneMatW=getBoneMatrix(skinIndex.w);
#endif`,Qs=`#ifdef USE_SKINNING
uniform mat4 bindMatrix;uniform mat4 bindMatrixInverse;
#ifdef BONE_TEXTURE
uniform highp sampler2D boneTexture;uniform int boneTextureSize;mat4 getBoneMatrix(const in float i){float j=i*4.0;float x=mod(j,float(boneTextureSize));float y=floor(j/float(boneTextureSize));float dx=1.0/float(boneTextureSize);float dy=1.0/float(boneTextureSize);y=dy*(y+0.5);vec4 v1=texture2D(boneTexture,vec2(dx*(x+0.5),y));vec4 v2=texture2D(boneTexture,vec2(dx*(x+1.5),y));vec4 v3=texture2D(boneTexture,vec2(dx*(x+2.5),y));vec4 v4=texture2D(boneTexture,vec2(dx*(x+3.5),y));mat4 bone=mat4(v1,v2,v3,v4);return bone;}
#else
uniform mat4 boneMatrices[MAX_BONES];mat4 getBoneMatrix(const in float i){mat4 bone=boneMatrices[int(i)];return bone;}
#endif
#endif`,Ks=`#ifdef USE_SKINNING
vec4 skinVertex=bindMatrix*vec4(transformed,1.0);vec4 skinned=vec4(0.0);skinned+=boneMatX*skinVertex*skinWeight.x;skinned+=boneMatY*skinVertex*skinWeight.y;skinned+=boneMatZ*skinVertex*skinWeight.z;skinned+=boneMatW*skinVertex*skinWeight.w;transformed=(bindMatrixInverse*skinned).xyz;
#endif`,eo=`#ifdef USE_SKINNING
mat4 skinMatrix=mat4(0.0);skinMatrix+=skinWeight.x*boneMatX;skinMatrix+=skinWeight.y*boneMatY;skinMatrix+=skinWeight.z*boneMatZ;skinMatrix+=skinWeight.w*boneMatW;skinMatrix=bindMatrixInverse*skinMatrix*bindMatrix;objectNormal=vec4(skinMatrix*vec4(objectNormal,0.0)).xyz;
#ifdef USE_TANGENT
objectTangent=vec4(skinMatrix*vec4(objectTangent,0.0)).xyz;
#endif
#endif`,to=`float specularStrength;
#ifdef USE_SPECULARMAP
vec4 texelSpecular=texture2D(specularMap,vUv);specularStrength=texelSpecular.r;
#else
specularStrength=1.0;
#endif`,io=`#ifdef USE_SPECULARMAP
uniform sampler2D specularMap;
#endif`,no=`#if defined(TONE_MAPPING)
gl_FragColor.rgb=toneMapping(gl_FragColor.rgb);
#endif`,ro=`#ifndef saturate
#define saturate(a)clamp(a,0.0,1.0)
#endif
uniform float toneMappingExposure;vec3 LinearToneMapping(vec3 color){return toneMappingExposure*color;}vec3 ReinhardToneMapping(vec3 color){color*=toneMappingExposure;return saturate(color/(vec3(1.0)+color));}vec3 OptimizedCineonToneMapping(vec3 color){color*=toneMappingExposure;color=max(vec3(0.0),color-0.004);return pow((color*(6.2*color+0.5))/(color*(6.2*color+1.7)+0.06),vec3(2.2));}vec3 RRTAndODTFit(vec3 v){vec3 a=v*(v+0.0245786)-0.000090537;vec3 b=v*(0.983729*v+0.4329510)+0.238081;return a/b;}vec3 ACESFilmicToneMapping(vec3 color){const mat3 ACESInputMat=mat3(vec3(0.59719,0.07600,0.02840),vec3(0.35458,0.90834,0.13383),vec3(0.04823,0.01566,0.83777));const mat3 ACESOutputMat=mat3(vec3(1.60475,-0.10208,-0.00327),vec3(-0.53108,1.10813,-0.07276),vec3(-0.07367,-0.00605,1.07602));color*=toneMappingExposure/0.6;color=ACESInputMat*color;color=RRTAndODTFit(color);color=ACESOutputMat*color;return saturate(color);}vec3 CustomToneMapping(vec3 color){return color;}`,ao=`#ifdef USE_TRANSMISSION
float transmissionAlpha=1.0;float transmissionFactor=transmission;float thicknessFactor=thickness;
#ifdef USE_TRANSMISSIONMAP
transmissionFactor*=texture2D(transmissionMap,vUv).r;
#endif
#ifdef USE_THICKNESSMAP
thicknessFactor*=texture2D(thicknessMap,vUv).g;
#endif
vec3 pos=vWorldPosition;vec3 v=normalize(cameraPosition-pos);vec3 n=inverseTransformDirection(normal,viewMatrix);vec4 transmission=getIBLVolumeRefraction(n,v,roughnessFactor,material.diffuseColor,material.specularColor,material.specularF90,pos,modelMatrix,viewMatrix,projectionMatrix,ior,thicknessFactor,attenuationTint,attenuationDistance);totalDiffuse=mix(totalDiffuse,transmission.rgb,transmissionFactor);transmissionAlpha=mix(transmissionAlpha,transmission.a,transmissionFactor);
#endif`,so=`#ifdef USE_TRANSMISSION
uniform float transmission;uniform float thickness;uniform float attenuationDistance;uniform vec3 attenuationTint;
#ifdef USE_TRANSMISSIONMAP
uniform sampler2D transmissionMap;
#endif
#ifdef USE_THICKNESSMAP
uniform sampler2D thicknessMap;
#endif
uniform vec2 transmissionSamplerSize;uniform sampler2D transmissionSamplerMap;uniform mat4 modelMatrix;uniform mat4 projectionMatrix;varying vec3 vWorldPosition;vec3 getVolumeTransmissionRay(vec3 n,vec3 v,float thickness,float ior,mat4 modelMatrix){vec3 refractionVector=refract(-v,normalize(n),1.0/ior);vec3 modelScale;modelScale.x=length(vec3(modelMatrix[0].xyz));modelScale.y=length(vec3(modelMatrix[1].xyz));modelScale.z=length(vec3(modelMatrix[2].xyz));return normalize(refractionVector)*thickness*modelScale;}float applyIorToRoughness(float roughness,float ior){return roughness*clamp(ior*2.0-2.0,0.0,1.0);}vec4 getTransmissionSample(vec2 fragCoord,float roughness,float ior){float framebufferLod=log2(transmissionSamplerSize.x)*applyIorToRoughness(roughness,ior);
#ifdef TEXTURE_LOD_EXT
return texture2DLodEXT(transmissionSamplerMap,fragCoord.xy,framebufferLod);
#else
return texture2D(transmissionSamplerMap,fragCoord.xy,framebufferLod);
#endif
}vec3 applyVolumeAttenuation(vec3 radiance,float transmissionDistance,vec3 attenuationColor,float attenuationDistance){if(attenuationDistance==0.0){return radiance;}else{vec3 attenuationCoefficient=-log(attenuationColor)/attenuationDistance;vec3 transmittance=exp(-attenuationCoefficient*transmissionDistance);return transmittance*radiance;}}vec4 getIBLVolumeRefraction(vec3 n,vec3 v,float roughness,vec3 diffuseColor,vec3 specularColor,float specularF90,vec3 position,mat4 modelMatrix,mat4 viewMatrix,mat4 projMatrix,float ior,float thickness,vec3 attenuationColor,float attenuationDistance){vec3 transmissionRay=getVolumeTransmissionRay(n,v,thickness,ior,modelMatrix);vec3 refractedRayExit=position+transmissionRay;vec4 ndcPos=projMatrix*viewMatrix*vec4(refractedRayExit,1.0);vec2 refractionCoords=ndcPos.xy/ndcPos.w;refractionCoords+=1.0;refractionCoords/=2.0;vec4 transmittedLight=getTransmissionSample(refractionCoords,roughness,ior);vec3 attenuatedColor=applyVolumeAttenuation(transmittedLight.rgb,length(transmissionRay),attenuationColor,attenuationDistance);vec3 F=EnvironmentBRDF(n,v,specularColor,specularF90,roughness);return vec4((1.0-F)*attenuatedColor*diffuseColor,transmittedLight.a);}
#endif`,oo=`#if (defined(USE_UV)&&!defined(UVS_VERTEX_ONLY))
varying vec2 vUv;
#endif`,lo=`#ifdef USE_UV
#ifdef UVS_VERTEX_ONLY
vec2 vUv;
#else
varying vec2 vUv;
#endif
uniform mat3 uvTransform;
#endif`,co=`#ifdef USE_UV
vUv=(uvTransform*vec3(uv,1)).xy;
#endif`,uo=`#if defined(USE_LIGHTMAP)||defined(USE_AOMAP)
varying vec2 vUv2;
#endif`,ho=`#if defined(USE_LIGHTMAP)||defined(USE_AOMAP)
attribute vec2 uv2;varying vec2 vUv2;uniform mat3 uv2Transform;
#endif`,fo=`#if defined(USE_LIGHTMAP)||defined(USE_AOMAP)
vUv2=(uv2Transform*vec3(uv2,1)).xy;
#endif`,po=`#if defined(USE_ENVMAP)||defined(DISTANCE)||defined(USE_SHADOWMAP)||defined(USE_TRANSMISSION)
vec4 worldPosition=vec4(transformed,1.0);
#ifdef USE_INSTANCING
worldPosition=instanceMatrix*worldPosition;
#endif
worldPosition=modelMatrix*worldPosition;
#endif`;const mo="varying vec2 vUv;uniform mat3 uvTransform;void main(){vUv=(uvTransform*vec3(uv,1)).xy;gl_Position=vec4(position.xy,1.0,1.0);}",go=`uniform sampler2D t2D;varying vec2 vUv;void main(){vec4 texColor=texture2D(t2D,vUv);gl_FragColor=mapTexelToLinear(texColor);
#include <tonemapping_fragment>
#include <encodings_fragment>
}`,_o=`varying vec3 vWorldDirection;
#include <common>
void main(){vWorldDirection=transformDirection(position,modelMatrix);
#include <begin_vertex>
#include <project_vertex>
gl_Position.z=gl_Position.w;}`,xo=`#include <envmap_common_pars_fragment>
uniform float opacity;varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main(){vec3 vReflect=vWorldDirection;
#include <envmap_fragment>
gl_FragColor=envColor;gl_FragColor.a*=opacity;
#include <tonemapping_fragment>
#include <encodings_fragment>
}`,vo=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;void main(){
#include <uv_vertex>
#include <skinbase_vertex>
#ifdef USE_DISPLACEMENTMAP
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinnormal_vertex>
#endif
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <displacementmap_vertex>
#include <project_vertex>
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
vHighPrecisionZW=gl_Position.zw;}`,Mo=`#if DEPTH_PACKING==3200
uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;void main(){
#include <clipping_planes_fragment>
vec4 diffuseColor=vec4(1.0);
#if DEPTH_PACKING==3200
diffuseColor.a=opacity;
#endif
#include <map_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
#include <logdepthbuf_fragment>
float fragCoordZ=0.5*vHighPrecisionZW[0]/vHighPrecisionZW[1]+0.5;
#if DEPTH_PACKING==3200
gl_FragColor=vec4(vec3(1.0-fragCoordZ),opacity);
#elif DEPTH_PACKING==3201
gl_FragColor=packDepthToRGBA(fragCoordZ);
#endif
}`,yo=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main(){
#include <uv_vertex>
#include <skinbase_vertex>
#ifdef USE_DISPLACEMENTMAP
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinnormal_vertex>
#endif
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <displacementmap_vertex>
#include <project_vertex>
#include <worldpos_vertex>
#include <clipping_planes_vertex>
vWorldPosition=worldPosition.xyz;}`,So=`#define DISTANCE
uniform vec3 referencePosition;uniform float nearDistance;uniform float farDistance;varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main(){
#include <clipping_planes_fragment>
vec4 diffuseColor=vec4(1.0);
#include <map_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
float dist=length(vWorldPosition-referencePosition);dist=(dist-nearDistance)/(farDistance-nearDistance);dist=saturate(dist);gl_FragColor=packDepthToRGBA(dist);}`,bo=`varying vec3 vWorldDirection;
#include <common>
void main(){vWorldDirection=transformDirection(position,modelMatrix);
#include <begin_vertex>
#include <project_vertex>
}`,wo=`uniform sampler2D tEquirect;varying vec3 vWorldDirection;
#include <common>
void main(){vec3 direction=normalize(vWorldDirection);vec2 sampleUV=equirectUv(direction);vec4 texColor=texture2D(tEquirect,sampleUV);gl_FragColor=mapTexelToLinear(texColor);
#include <tonemapping_fragment>
#include <encodings_fragment>
}`,To=`uniform float scale;attribute float lineDistance;varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main(){vLineDistance=scale*lineDistance;
#include <color_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <project_vertex>
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
#include <fog_vertex>
}`,Ao=`uniform vec3 diffuse;uniform float opacity;uniform float dashSize;uniform float totalSize;varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main(){
#include <clipping_planes_fragment>
if(mod(vLineDistance,totalSize)>dashSize){discard;}vec3 outgoingLight=vec3(0.0);vec4 diffuseColor=vec4(diffuse,opacity);
#include <logdepthbuf_fragment>
#include <color_fragment>
outgoingLight=diffuseColor.rgb;
#include <output_fragment>
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
}`,Eo=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main(){
#include <uv_vertex>
#include <uv2_vertex>
#include <color_vertex>
#if defined(USE_ENVMAP)||defined(USE_SKINNING)
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <defaultnormal_vertex>
#endif
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <project_vertex>
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
#include <worldpos_vertex>
#include <envmap_vertex>
#include <fog_vertex>
}`,Lo=`uniform vec3 diffuse;uniform float opacity;
#ifndef FLAT_SHADED
varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main(){
#include <clipping_planes_fragment>
vec4 diffuseColor=vec4(diffuse,opacity);
#include <logdepthbuf_fragment>
#include <map_fragment>
#include <color_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
#include <specularmap_fragment>
ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));
#ifdef USE_LIGHTMAP
vec4 lightMapTexel=texture2D(lightMap,vUv2);reflectedLight.indirectDiffuse+=lightMapTexelToLinear(lightMapTexel).rgb*lightMapIntensity;
#else
reflectedLight.indirectDiffuse+=vec3(1.0);
#endif
#include <aomap_fragment>
reflectedLight.indirectDiffuse*=diffuseColor.rgb;vec3 outgoingLight=reflectedLight.indirectDiffuse;
#include <envmap_fragment>
#include <output_fragment>
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
#include <dithering_fragment>
}`,Co=`#define LAMBERT
varying vec3 vLightFront;varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
varying vec3 vLightBack;varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main(){
#include <uv_vertex>
#include <uv2_vertex>
#include <color_vertex>
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <defaultnormal_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <project_vertex>
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
#include <worldpos_vertex>
#include <envmap_vertex>
#include <lights_lambert_vertex>
#include <shadowmap_vertex>
#include <fog_vertex>
}`,Ro=`uniform vec3 diffuse;uniform vec3 emissive;uniform float opacity;varying vec3 vLightFront;varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
varying vec3 vLightBack;varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main(){
#include <clipping_planes_fragment>
vec4 diffuseColor=vec4(diffuse,opacity);ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));vec3 totalEmissiveRadiance=emissive;
#include <logdepthbuf_fragment>
#include <map_fragment>
#include <color_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
#include <specularmap_fragment>
#include <emissivemap_fragment>
#ifdef DOUBLE_SIDED
reflectedLight.indirectDiffuse+=(gl_FrontFacing)?vIndirectFront:vIndirectBack;
#else
reflectedLight.indirectDiffuse+=vIndirectFront;
#endif
#include <lightmap_fragment>
reflectedLight.indirectDiffuse*=BRDF_Lambert(diffuseColor.rgb);
#ifdef DOUBLE_SIDED
reflectedLight.directDiffuse=(gl_FrontFacing)?vLightFront:vLightBack;
#else
reflectedLight.directDiffuse=vLightFront;
#endif
reflectedLight.directDiffuse*=BRDF_Lambert(diffuseColor.rgb)*getShadowMask();
#include <aomap_fragment>
vec3 outgoingLight=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+totalEmissiveRadiance;
#include <envmap_fragment>
#include <output_fragment>
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
#include <dithering_fragment>
}`,Do=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main(){
#include <uv_vertex>
#include <color_vertex>
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <defaultnormal_vertex>
#include <normal_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <displacementmap_vertex>
#include <project_vertex>
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
#include <fog_vertex>
vViewPosition=-mvPosition.xyz;}`,Po=`#define MATCAP
uniform vec3 diffuse;uniform float opacity;uniform sampler2D matcap;varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main(){
#include <clipping_planes_fragment>
vec4 diffuseColor=vec4(diffuse,opacity);
#include <logdepthbuf_fragment>
#include <map_fragment>
#include <color_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
#include <normal_fragment_begin>
#include <normal_fragment_maps>
vec3 viewDir=normalize(vViewPosition);vec3 x=normalize(vec3(viewDir.z,0.0,-viewDir.x));vec3 y=cross(viewDir,x);vec2 uv=vec2(dot(x,normal),dot(y,normal))*0.495+0.5;
#ifdef USE_MATCAP
vec4 matcapColor=texture2D(matcap,uv);matcapColor=matcapTexelToLinear(matcapColor);
#else
vec4 matcapColor=vec4(1.0);
#endif
vec3 outgoingLight=diffuseColor.rgb*matcapColor.rgb;
#include <output_fragment>
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
#include <dithering_fragment>
}`,Fo=`#define NORMAL
#if defined(FLAT_SHADED)||defined(USE_BUMPMAP)||defined(TANGENTSPACE_NORMALMAP)
varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main(){
#include <uv_vertex>
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <defaultnormal_vertex>
#include <normal_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <displacementmap_vertex>
#include <project_vertex>
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
#if defined(FLAT_SHADED)||defined(USE_BUMPMAP)||defined(TANGENTSPACE_NORMALMAP)
vViewPosition=-mvPosition.xyz;
#endif
}`,Io=`#define NORMAL
uniform float opacity;
#if defined(FLAT_SHADED)||defined(USE_BUMPMAP)||defined(TANGENTSPACE_NORMALMAP)
varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main(){
#include <clipping_planes_fragment>
#include <logdepthbuf_fragment>
#include <normal_fragment_begin>
#include <normal_fragment_maps>
gl_FragColor=vec4(packNormalToRGB(normal),opacity);}`,No=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main(){
#include <uv_vertex>
#include <uv2_vertex>
#include <color_vertex>
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <defaultnormal_vertex>
#include <normal_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <displacementmap_vertex>
#include <project_vertex>
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
vViewPosition=-mvPosition.xyz;
#include <worldpos_vertex>
#include <envmap_vertex>
#include <shadowmap_vertex>
#include <fog_vertex>
}`,Bo=`#define PHONG
uniform vec3 diffuse;uniform vec3 emissive;uniform vec3 specular;uniform float shininess;uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main(){
#include <clipping_planes_fragment>
vec4 diffuseColor=vec4(diffuse,opacity);ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));vec3 totalEmissiveRadiance=emissive;
#include <logdepthbuf_fragment>
#include <map_fragment>
#include <color_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
#include <specularmap_fragment>
#include <normal_fragment_begin>
#include <normal_fragment_maps>
#include <emissivemap_fragment>
#include <lights_phong_fragment>
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>
#include <aomap_fragment>
vec3 outgoingLight=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+reflectedLight.directSpecular+reflectedLight.indirectSpecular+totalEmissiveRadiance;
#include <envmap_fragment>
#include <output_fragment>
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
#include <dithering_fragment>
}`,zo=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main(){
#include <uv_vertex>
#include <uv2_vertex>
#include <color_vertex>
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <defaultnormal_vertex>
#include <normal_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <displacementmap_vertex>
#include <project_vertex>
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
vViewPosition=-mvPosition.xyz;
#include <worldpos_vertex>
#include <shadowmap_vertex>
#include <fog_vertex>
#ifdef USE_TRANSMISSION
vWorldPosition=worldPosition.xyz;
#endif
}`,Uo=`#define STANDARD
#ifdef PHYSICAL
#define IOR
#define SPECULAR
#endif
uniform vec3 diffuse;uniform vec3 emissive;uniform float roughness;uniform float metalness;uniform float opacity;
#ifdef IOR
uniform float ior;
#endif
#ifdef SPECULAR
uniform float specularIntensity;uniform vec3 specularTint;
#ifdef USE_SPECULARINTENSITYMAP
uniform sampler2D specularIntensityMap;
#endif
#ifdef USE_SPECULARTINTMAP
uniform sampler2D specularTintMap;
#endif
#endif
#ifdef USE_CLEARCOAT
uniform float clearcoat;uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
uniform vec3 sheenTint;uniform float sheenRoughness;
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main(){
#include <clipping_planes_fragment>
vec4 diffuseColor=vec4(diffuse,opacity);ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));vec3 totalEmissiveRadiance=emissive;
#include <logdepthbuf_fragment>
#include <map_fragment>
#include <color_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
#include <roughnessmap_fragment>
#include <metalnessmap_fragment>
#include <normal_fragment_begin>
#include <normal_fragment_maps>
#include <clearcoat_normal_fragment_begin>
#include <clearcoat_normal_fragment_maps>
#include <emissivemap_fragment>
#include <lights_physical_fragment>
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>
#include <aomap_fragment>
vec3 totalDiffuse=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse;vec3 totalSpecular=reflectedLight.directSpecular+reflectedLight.indirectSpecular;
#include <transmission_fragment>
vec3 outgoingLight=totalDiffuse+totalSpecular+totalEmissiveRadiance;
#ifdef USE_CLEARCOAT
float dotNVcc=saturate(dot(geometry.clearcoatNormal,geometry.viewDir));vec3 Fcc=F_Schlick(material.clearcoatF0,material.clearcoatF90,dotNVcc);outgoingLight=outgoingLight*(1.0-clearcoat*Fcc)+clearcoatSpecular*clearcoat;
#endif
#include <output_fragment>
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
#include <dithering_fragment>
}`,Go=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main(){
#include <uv_vertex>
#include <uv2_vertex>
#include <color_vertex>
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <defaultnormal_vertex>
#include <normal_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <displacementmap_vertex>
#include <project_vertex>
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
vViewPosition=-mvPosition.xyz;
#include <worldpos_vertex>
#include <shadowmap_vertex>
#include <fog_vertex>
}`,Oo=`#define TOON
uniform vec3 diffuse;uniform vec3 emissive;uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main(){
#include <clipping_planes_fragment>
vec4 diffuseColor=vec4(diffuse,opacity);ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));vec3 totalEmissiveRadiance=emissive;
#include <logdepthbuf_fragment>
#include <map_fragment>
#include <color_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
#include <normal_fragment_begin>
#include <normal_fragment_maps>
#include <emissivemap_fragment>
#include <lights_toon_fragment>
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>
#include <aomap_fragment>
vec3 outgoingLight=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+totalEmissiveRadiance;
#include <output_fragment>
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
#include <dithering_fragment>
}`,Vo=`uniform float size;uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main(){
#include <color_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <project_vertex>
gl_PointSize=size;
#ifdef USE_SIZEATTENUATION
bool isPerspective=isPerspectiveMatrix(projectionMatrix);if(isPerspective)gl_PointSize*=(scale/-mvPosition.z);
#endif
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
#include <worldpos_vertex>
#include <fog_vertex>
}`,ko=`uniform vec3 diffuse;uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main(){
#include <clipping_planes_fragment>
vec3 outgoingLight=vec3(0.0);vec4 diffuseColor=vec4(diffuse,opacity);
#include <logdepthbuf_fragment>
#include <map_particle_fragment>
#include <color_fragment>
#include <alphatest_fragment>
outgoingLight=diffuseColor.rgb;
#include <output_fragment>
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
}`,Wo=`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main(){
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <defaultnormal_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <project_vertex>
#include <worldpos_vertex>
#include <shadowmap_vertex>
#include <fog_vertex>
}`,Ho=`uniform vec3 color;uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main(){gl_FragColor=vec4(color,opacity*(1.0-getShadowMask()));
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
}`,qo=`uniform float rotation;uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main(){
#include <uv_vertex>
vec4 mvPosition=modelViewMatrix*vec4(0.0,0.0,0.0,1.0);vec2 scale;scale.x=length(vec3(modelMatrix[0].x,modelMatrix[0].y,modelMatrix[0].z));scale.y=length(vec3(modelMatrix[1].x,modelMatrix[1].y,modelMatrix[1].z));
#ifndef USE_SIZEATTENUATION
bool isPerspective=isPerspectiveMatrix(projectionMatrix);if(isPerspective)scale*=-mvPosition.z;
#endif
vec2 alignedPosition=(position.xy-(center-vec2(0.5)))*scale;vec2 rotatedPosition;rotatedPosition.x=cos(rotation)*alignedPosition.x-sin(rotation)*alignedPosition.y;rotatedPosition.y=sin(rotation)*alignedPosition.x+cos(rotation)*alignedPosition.y;mvPosition.xy+=rotatedPosition;gl_Position=projectionMatrix*mvPosition;
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
#include <fog_vertex>
}`,Xo=`uniform vec3 diffuse;uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main(){
#include <clipping_planes_fragment>
vec3 outgoingLight=vec3(0.0);vec4 diffuseColor=vec4(diffuse,opacity);
#include <logdepthbuf_fragment>
#include <map_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
outgoingLight=diffuseColor.rgb;
#include <output_fragment>
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
}`,Me={alphamap_fragment:Ma,alphamap_pars_fragment:ya,alphatest_fragment:Sa,alphatest_pars_fragment:ba,aomap_fragment:wa,aomap_pars_fragment:Ta,begin_vertex:Aa,beginnormal_vertex:Ea,bsdfs:La,bumpmap_pars_fragment:Ca,clipping_planes_fragment:Ra,clipping_planes_pars_fragment:Da,clipping_planes_pars_vertex:Pa,clipping_planes_vertex:Fa,color_fragment:Ia,color_pars_fragment:Na,color_pars_vertex:Ba,color_vertex:za,common:Ua,cube_uv_reflection_fragment:Ga,defaultnormal_vertex:Oa,displacementmap_pars_vertex:Va,displacementmap_vertex:ka,emissivemap_fragment:Wa,emissivemap_pars_fragment:Ha,encodings_fragment:qa,encodings_pars_fragment:Xa,envmap_fragment:Ya,envmap_common_pars_fragment:Za,envmap_pars_fragment:ja,envmap_pars_vertex:Ja,envmap_physical_pars_fragment:os,envmap_vertex:$a,fog_vertex:Qa,fog_pars_vertex:Ka,fog_fragment:es,fog_pars_fragment:ts,gradientmap_pars_fragment:is,lightmap_fragment:ns,lightmap_pars_fragment:rs,lights_lambert_vertex:as,lights_pars_begin:ss,lights_toon_fragment:ls,lights_toon_pars_fragment:cs,lights_phong_fragment:us,lights_phong_pars_fragment:hs,lights_physical_fragment:ds,lights_physical_pars_fragment:fs,lights_fragment_begin:ps,lights_fragment_maps:ms,lights_fragment_end:gs,logdepthbuf_fragment:_s,logdepthbuf_pars_fragment:xs,logdepthbuf_pars_vertex:vs,logdepthbuf_vertex:Ms,map_fragment:ys,map_pars_fragment:Ss,map_particle_fragment:bs,map_particle_pars_fragment:ws,metalnessmap_fragment:Ts,metalnessmap_pars_fragment:As,morphnormal_vertex:Es,morphtarget_pars_vertex:Ls,morphtarget_vertex:Cs,normal_fragment_begin:Rs,normal_fragment_maps:Ds,normal_pars_fragment:Ps,normal_pars_vertex:Fs,normal_vertex:Is,normalmap_pars_fragment:Ns,clearcoat_normal_fragment_begin:Bs,clearcoat_normal_fragment_maps:zs,clearcoat_pars_fragment:Us,output_fragment:Gs,packing:Os,premultiplied_alpha_fragment:Vs,project_vertex:ks,dithering_fragment:Ws,dithering_pars_fragment:Hs,roughnessmap_fragment:qs,roughnessmap_pars_fragment:Xs,shadowmap_pars_fragment:Ys,shadowmap_pars_vertex:Zs,shadowmap_vertex:js,shadowmask_pars_fragment:Js,skinbase_vertex:$s,skinning_pars_vertex:Qs,skinning_vertex:Ks,skinnormal_vertex:eo,specularmap_fragment:to,specularmap_pars_fragment:io,tonemapping_fragment:no,tonemapping_pars_fragment:ro,transmission_fragment:ao,transmission_pars_fragment:so,uv_pars_fragment:oo,uv_pars_vertex:lo,uv_vertex:co,uv2_pars_fragment:uo,uv2_pars_vertex:ho,uv2_vertex:fo,worldpos_vertex:po,background_vert:mo,background_frag:go,cube_vert:_o,cube_frag:xo,depth_vert:vo,depth_frag:Mo,distanceRGBA_vert:yo,distanceRGBA_frag:So,equirect_vert:bo,equirect_frag:wo,linedashed_vert:To,linedashed_frag:Ao,meshbasic_vert:Eo,meshbasic_frag:Lo,meshlambert_vert:Co,meshlambert_frag:Ro,meshmatcap_vert:Do,meshmatcap_frag:Po,meshnormal_vert:Fo,meshnormal_frag:Io,meshphong_vert:No,meshphong_frag:Bo,meshphysical_vert:zo,meshphysical_frag:Uo,meshtoon_vert:Go,meshtoon_frag:Oo,points_vert:Vo,points_frag:ko,shadow_vert:Wo,shadow_frag:Ho,sprite_vert:qo,sprite_frag:Xo},Z={common:{diffuse:{value:new Ee(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new nt},uv2Transform:{value:new nt},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Re(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Ee(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Ee(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new nt}},sprite:{diffuse:{value:new Ee(16777215)},opacity:{value:1},center:{value:new Re(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new nt}}},ot={basic:{uniforms:Oe([Z.common,Z.specularmap,Z.envmap,Z.aomap,Z.lightmap,Z.fog]),vertexShader:Me.meshbasic_vert,fragmentShader:Me.meshbasic_frag},lambert:{uniforms:Oe([Z.common,Z.specularmap,Z.envmap,Z.aomap,Z.lightmap,Z.emissivemap,Z.fog,Z.lights,{emissive:{value:new Ee(0)}}]),vertexShader:Me.meshlambert_vert,fragmentShader:Me.meshlambert_frag},phong:{uniforms:Oe([Z.common,Z.specularmap,Z.envmap,Z.aomap,Z.lightmap,Z.emissivemap,Z.bumpmap,Z.normalmap,Z.displacementmap,Z.fog,Z.lights,{emissive:{value:new Ee(0)},specular:{value:new Ee(1118481)},shininess:{value:30}}]),vertexShader:Me.meshphong_vert,fragmentShader:Me.meshphong_frag},standard:{uniforms:Oe([Z.common,Z.envmap,Z.aomap,Z.lightmap,Z.emissivemap,Z.bumpmap,Z.normalmap,Z.displacementmap,Z.roughnessmap,Z.metalnessmap,Z.fog,Z.lights,{emissive:{value:new Ee(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Me.meshphysical_vert,fragmentShader:Me.meshphysical_frag},toon:{uniforms:Oe([Z.common,Z.aomap,Z.lightmap,Z.emissivemap,Z.bumpmap,Z.normalmap,Z.displacementmap,Z.gradientmap,Z.fog,Z.lights,{emissive:{value:new Ee(0)}}]),vertexShader:Me.meshtoon_vert,fragmentShader:Me.meshtoon_frag},matcap:{uniforms:Oe([Z.common,Z.bumpmap,Z.normalmap,Z.displacementmap,Z.fog,{matcap:{value:null}}]),vertexShader:Me.meshmatcap_vert,fragmentShader:Me.meshmatcap_frag},points:{uniforms:Oe([Z.points,Z.fog]),vertexShader:Me.points_vert,fragmentShader:Me.points_frag},dashed:{uniforms:Oe([Z.common,Z.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Me.linedashed_vert,fragmentShader:Me.linedashed_frag},depth:{uniforms:Oe([Z.common,Z.displacementmap]),vertexShader:Me.depth_vert,fragmentShader:Me.depth_frag},normal:{uniforms:Oe([Z.common,Z.bumpmap,Z.normalmap,Z.displacementmap,{opacity:{value:1}}]),vertexShader:Me.meshnormal_vert,fragmentShader:Me.meshnormal_frag},sprite:{uniforms:Oe([Z.sprite,Z.fog]),vertexShader:Me.sprite_vert,fragmentShader:Me.sprite_frag},background:{uniforms:{uvTransform:{value:new nt},t2D:{value:null}},vertexShader:Me.background_vert,fragmentShader:Me.background_frag},cube:{uniforms:Oe([Z.envmap,{opacity:{value:1}}]),vertexShader:Me.cube_vert,fragmentShader:Me.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Me.equirect_vert,fragmentShader:Me.equirect_frag},distanceRGBA:{uniforms:Oe([Z.common,Z.displacementmap,{referencePosition:{value:new C},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Me.distanceRGBA_vert,fragmentShader:Me.distanceRGBA_frag},shadow:{uniforms:Oe([Z.lights,Z.fog,{color:{value:new Ee(0)},opacity:{value:1}}]),vertexShader:Me.shadow_vert,fragmentShader:Me.shadow_frag}};ot.physical={uniforms:Oe([ot.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new Re(1,1)},clearcoatNormalMap:{value:null},sheen:{value:0},sheenTint:{value:new Ee(0)},sheenRoughness:{value:0},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new Re},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationTint:{value:new Ee(0)},specularIntensity:{value:0},specularIntensityMap:{value:null},specularTint:{value:new Ee(1,1,1)},specularTintMap:{value:null}}]),vertexShader:Me.meshphysical_vert,fragmentShader:Me.meshphysical_frag};function Yo(a,e,t,i,n){const r=new Ee(0);let s=0,o,c,l=null,h=0,p=null;function f(_,g){let b=!1,u=g.isScene===!0?g.background:null;u&&u.isTexture&&(u=e.get(u));const d=a.xr,T=d.getSession&&d.getSession();T&&T.environmentBlendMode==="additive"&&(u=null),u===null?m(r,s):u&&u.isColor&&(m(u,1),b=!0),(a.autoClear||b)&&a.clear(a.autoClearColor,a.autoClearDepth,a.autoClearStencil),u&&(u.isCubeTexture||u.mapping===306)?(c===void 0&&(c=new lt(new ui(1,1,1),new ai({name:"BackgroundCubeMaterial",uniforms:ri(ot.cube.uniforms),vertexShader:ot.cube.vertexShader,fragmentShader:ot.cube.fragmentShader,side:1,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),c.geometry.deleteAttribute("uv"),c.onBeforeRender=function(M,w,E){this.matrixWorld.copyPosition(E.matrixWorld)},Object.defineProperty(c.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(c)),c.material.uniforms.envMap.value=u,c.material.uniforms.flipEnvMap.value=u.isCubeTexture&&u.isRenderTargetTexture===!1?-1:1,(l!==u||h!==u.version||p!==a.toneMapping)&&(c.material.needsUpdate=!0,l=u,h=u.version,p=a.toneMapping),_.unshift(c,c.geometry,c.material,0,0,null)):u&&u.isTexture&&(o===void 0&&(o=new lt(new Ln(2,2),new ai({name:"BackgroundMaterial",uniforms:ri(ot.background.uniforms),vertexShader:ot.background.vertexShader,fragmentShader:ot.background.fragmentShader,side:0,depthTest:!1,depthWrite:!1,fog:!1})),o.geometry.deleteAttribute("normal"),Object.defineProperty(o.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(o)),o.material.uniforms.t2D.value=u,u.matrixAutoUpdate===!0&&u.updateMatrix(),o.material.uniforms.uvTransform.value.copy(u.matrix),(l!==u||h!==u.version||p!==a.toneMapping)&&(o.material.needsUpdate=!0,l=u,h=u.version,p=a.toneMapping),_.unshift(o,o.geometry,o.material,0,0,null))}function m(_,g){t.buffers.color.setClear(_.r,_.g,_.b,g,n)}return{getClearColor:function(){return r},setClearColor:function(_,g=1){r.set(_),s=g,m(r,s)},getClearAlpha:function(){return s},setClearAlpha:function(_){s=_,m(r,s)},render:f}}function Zo(a,e,t,i){const n=a.getParameter(34921),r=i.isWebGL2?null:e.get("OES_vertex_array_object"),s=i.isWebGL2||r!==null,o={},c=g(null);let l=c;function h(I,z,G,N,B){let Y=!1;if(s){const ne=_(N,G,z);l!==ne&&(l=ne,f(l.object)),Y=b(N,B),Y&&u(N,B)}else{const ne=z.wireframe===!0;(l.geometry!==N.id||l.program!==G.id||l.wireframe!==ne)&&(l.geometry=N.id,l.program=G.id,l.wireframe=ne,Y=!0)}I.isInstancedMesh===!0&&(Y=!0),B!==null&&t.update(B,34963),Y&&(v(I,z,G,N),B!==null&&a.bindBuffer(34963,t.get(B).buffer))}function p(){return i.isWebGL2?a.createVertexArray():r.createVertexArrayOES()}function f(I){return i.isWebGL2?a.bindVertexArray(I):r.bindVertexArrayOES(I)}function m(I){return i.isWebGL2?a.deleteVertexArray(I):r.deleteVertexArrayOES(I)}function _(I,z,G){const N=G.wireframe===!0;let B=o[I.id];B===void 0&&(B={},o[I.id]=B);let Y=B[z.id];Y===void 0&&(Y={},B[z.id]=Y);let ne=Y[N];return ne===void 0&&(ne=g(p()),Y[N]=ne),ne}function g(I){const z=[],G=[],N=[];for(let B=0;B<n;B++)z[B]=0,G[B]=0,N[B]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:z,enabledAttributes:G,attributeDivisors:N,object:I,attributes:{},index:null}}function b(I,z){const G=l.attributes,N=I.attributes;let B=0;for(const Y in N){const ne=G[Y],oe=N[Y];if(ne===void 0||ne.attribute!==oe||ne.data!==oe.data)return!0;B++}return l.attributesNum!==B||l.index!==z}function u(I,z){const G={},N=I.attributes;let B=0;for(const Y in N){const ne=N[Y],oe={};oe.attribute=ne,ne.data&&(oe.data=ne.data),G[Y]=oe,B++}l.attributes=G,l.attributesNum=B,l.index=z}function d(){const I=l.newAttributes;for(let z=0,G=I.length;z<G;z++)I[z]=0}function T(I){M(I,0)}function M(I,z){const G=l.newAttributes,N=l.enabledAttributes,B=l.attributeDivisors;G[I]=1,N[I]===0&&(a.enableVertexAttribArray(I),N[I]=1),B[I]!==z&&((i.isWebGL2?a:e.get("ANGLE_instanced_arrays"))[i.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](I,z),B[I]=z)}function w(){const I=l.newAttributes,z=l.enabledAttributes;for(let G=0,N=z.length;G<N;G++)z[G]!==I[G]&&(a.disableVertexAttribArray(G),z[G]=0)}function E(I,z,G,N,B,Y){i.isWebGL2===!0&&(G===5124||G===5125)?a.vertexAttribIPointer(I,z,G,B,Y):a.vertexAttribPointer(I,z,G,N,B,Y)}function v(I,z,G,N){if(i.isWebGL2===!1&&(I.isInstancedMesh||N.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;d();const B=N.attributes,Y=G.getAttributes(),ne=z.defaultAttributeValues;for(const oe in Y){const te=Y[oe];if(te.location>=0){let xe=B[oe];if(xe===void 0&&(oe==="instanceMatrix"&&I.instanceMatrix&&(xe=I.instanceMatrix),oe==="instanceColor"&&I.instanceColor&&(xe=I.instanceColor)),xe!==void 0){const H=xe.normalized,X=xe.itemSize,re=t.get(xe);if(re===void 0)continue;const F=re.buffer,me=re.type,_e=re.bytesPerElement;if(xe.isInterleavedBufferAttribute){const K=xe.data,ue=K.stride,be=xe.offset;if(K&&K.isInstancedInterleavedBuffer){for(let he=0;he<te.locationSize;he++)M(te.location+he,K.meshPerAttribute);I.isInstancedMesh!==!0&&N._maxInstanceCount===void 0&&(N._maxInstanceCount=K.meshPerAttribute*K.count)}else for(let he=0;he<te.locationSize;he++)T(te.location+he);a.bindBuffer(34962,F);for(let he=0;he<te.locationSize;he++)E(te.location+he,X/te.locationSize,me,H,ue*_e,(be+X/te.locationSize*he)*_e)}else{if(xe.isInstancedBufferAttribute){for(let K=0;K<te.locationSize;K++)M(te.location+K,xe.meshPerAttribute);I.isInstancedMesh!==!0&&N._maxInstanceCount===void 0&&(N._maxInstanceCount=xe.meshPerAttribute*xe.count)}else for(let K=0;K<te.locationSize;K++)T(te.location+K);a.bindBuffer(34962,F);for(let K=0;K<te.locationSize;K++)E(te.location+K,X/te.locationSize,me,H,X*_e,X/te.locationSize*K*_e)}}else if(ne!==void 0){const H=ne[oe];if(H!==void 0)switch(H.length){case 2:a.vertexAttrib2fv(te.location,H);break;case 3:a.vertexAttrib3fv(te.location,H);break;case 4:a.vertexAttrib4fv(te.location,H);break;default:a.vertexAttrib1fv(te.location,H)}}}}w()}function U(){L();for(const I in o){const z=o[I];for(const G in z){const N=z[G];for(const B in N)m(N[B].object),delete N[B];delete z[G]}delete o[I]}}function q(I){if(o[I.id]===void 0)return;const z=o[I.id];for(const G in z){const N=z[G];for(const B in N)m(N[B].object),delete N[B];delete z[G]}delete o[I.id]}function O(I){for(const z in o){const G=o[z];if(G[I.id]===void 0)continue;const N=G[I.id];for(const B in N)m(N[B].object),delete N[B];delete G[I.id]}}function L(){j(),l!==c&&(l=c,f(l.object))}function j(){c.geometry=null,c.program=null,c.wireframe=!1}return{setup:h,reset:L,resetDefaultState:j,dispose:U,releaseStatesOfGeometry:q,releaseStatesOfProgram:O,initAttributes:d,enableAttribute:T,disableUnusedAttributes:w}}function jo(a,e,t,i){const n=i.isWebGL2;let r;function s(l){r=l}function o(l,h){a.drawArrays(r,l,h),t.update(h,r,1)}function c(l,h,p){if(p===0)return;let f,m;if(n)f=a,m="drawArraysInstanced";else if(f=e.get("ANGLE_instanced_arrays"),m="drawArraysInstancedANGLE",f===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}f[m](r,l,h,p),t.update(h,r,p)}this.setMode=s,this.render=o,this.renderInstances=c}function Jo(a,e,t){let i;function n(){if(i!==void 0)return i;if(e.has("EXT_texture_filter_anisotropic")===!0){const v=e.get("EXT_texture_filter_anisotropic");i=a.getParameter(v.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i}function r(v){if(v==="highp"){if(a.getShaderPrecisionFormat(35633,36338).precision>0&&a.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";v="mediump"}return v==="mediump"&&a.getShaderPrecisionFormat(35633,36337).precision>0&&a.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const s=typeof WebGL2RenderingContext!="undefined"&&a instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext!="undefined"&&a instanceof WebGL2ComputeRenderingContext;let o=t.precision!==void 0?t.precision:"highp";const c=r(o);c!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",c,"instead."),o=c);const l=s||e.has("WEBGL_draw_buffers"),h=t.logarithmicDepthBuffer===!0,p=a.getParameter(34930),f=a.getParameter(35660),m=a.getParameter(3379),_=a.getParameter(34076),g=a.getParameter(34921),b=a.getParameter(36347),u=a.getParameter(36348),d=a.getParameter(36349),T=f>0,M=s||e.has("OES_texture_float"),w=T&&M,E=s?a.getParameter(36183):0;return{isWebGL2:s,drawBuffers:l,getMaxAnisotropy:n,getMaxPrecision:r,precision:o,logarithmicDepthBuffer:h,maxTextures:p,maxVertexTextures:f,maxTextureSize:m,maxCubemapSize:_,maxAttributes:g,maxVertexUniforms:b,maxVaryings:u,maxFragmentUniforms:d,vertexTextures:T,floatFragmentTextures:M,floatVertexTextures:w,maxSamples:E}}function $o(a){const e=this;let t=null,i=0,n=!1,r=!1;const s=new Lt,o=new nt,c={value:null,needsUpdate:!1};this.uniform=c,this.numPlanes=0,this.numIntersection=0,this.init=function(p,f,m){const _=p.length!==0||f||i!==0||n;return n=f,t=h(p,m,0),i=p.length,_},this.beginShadows=function(){r=!0,h(null)},this.endShadows=function(){r=!1,l()},this.setState=function(p,f,m){const _=p.clippingPlanes,g=p.clipIntersection,b=p.clipShadows,u=a.get(p);if(!n||_===null||_.length===0||r&&!b)r?h(null):l();else{const d=r?0:i,T=d*4;let M=u.clippingState||null;c.value=M,M=h(_,f,T,m);for(let w=0;w!==T;++w)M[w]=t[w];u.clippingState=M,this.numIntersection=g?this.numPlanes:0,this.numPlanes+=d}};function l(){c.value!==t&&(c.value=t,c.needsUpdate=i>0),e.numPlanes=i,e.numIntersection=0}function h(p,f,m,_){const g=p!==null?p.length:0;let b=null;if(g!==0){if(b=c.value,_!==!0||b===null){const u=m+g*4,d=f.matrixWorldInverse;o.getNormalMatrix(d),(b===null||b.length<u)&&(b=new Float32Array(u));for(let T=0,M=m;T!==g;++T,M+=4)s.copy(p[T]).applyMatrix4(d,o),s.normal.toArray(b,M),b[M+3]=s.constant}c.value=b,c.needsUpdate=!0}return e.numPlanes=g,e.numIntersection=0,b}}function Qo(a){let e=new WeakMap;function t(s,o){return o===303?s.mapping=301:o===304&&(s.mapping=302),s}function i(s){if(s&&s.isTexture&&s.isRenderTargetTexture===!1){const o=s.mapping;if(o===303||o===304)if(e.has(s)){const c=e.get(s).texture;return t(c,s.mapping)}else{const c=s.image;if(c&&c.height>0){const l=a.getRenderTarget(),h=new Tr(c.height/2);return h.fromEquirectangularTexture(a,s),e.set(s,h),a.setRenderTarget(l),s.addEventListener("dispose",n),t(h.texture,s.mapping)}else return null}}return s}function n(s){const o=s.target;o.removeEventListener("dispose",n);const c=e.get(o);c!==void 0&&(e.delete(o),c.dispose())}function r(){e=new WeakMap}return{get:i,dispose:r}}class Lr extends An{constructor(e=-1,t=1,i=1,n=-1,r=.1,s=2e3){super(),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=i,this.bottom=n,this.near=r,this.far=s,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,i,n,r,s){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=i,this.view.offsetY=n,this.view.width=r,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),i=(this.right+this.left)/2,n=(this.top+this.bottom)/2;let r=i-e,s=i+e,o=n+t,c=n-t;if(this.view!==null&&this.view.enabled){const l=(this.right-this.left)/this.view.fullWidth/this.zoom,h=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=l*this.view.offsetX,s=r+l*this.view.width,o-=h*this.view.offsetY,c=o-h*this.view.height}this.projectionMatrix.makeOrthographic(r,s,o,c,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}Lr.prototype.isOrthographicCamera=!0;class Hi extends ai{constructor(e){super(e),this.type="RawShaderMaterial"}}Hi.prototype.isRawShaderMaterial=!0;const ni=4,Rt=8,at=Math.pow(2,Rt),Cr=[.125,.215,.35,.446,.526,.582],Rr=Rt-ni+1+Cr.length,ei=20,Pt={[3e3]:0,[3001]:1,[3002]:2,[3004]:3,[3005]:4,[3006]:5,[3007]:6},vn=new Lr,{_lodPlanes:xi,_sizeLods:Qn,_sigmas:Vi}=tl(),Kn=new Ee;let Mn=null;const Ot=(1+Math.sqrt(5))/2,ti=1/Ot,er=[new C(1,1,1),new C(-1,1,1),new C(1,1,-1),new C(-1,1,-1),new C(0,Ot,ti),new C(0,Ot,-ti),new C(ti,0,Ot),new C(-ti,0,Ot),new C(Ot,ti,0),new C(-Ot,ti,0)];class Ko{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._blurMaterial=il(ei),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,i=.1,n=100){Mn=this._renderer.getRenderTarget();const r=this._allocateTargets();return this._sceneToCubeUV(e,i,n,r),t>0&&this._blur(r,0,0,t),this._applyPMREM(r),this._cleanup(r),r}fromEquirectangular(e){return this._fromTexture(e)}fromCubemap(e){return this._fromTexture(e)}compileCubemapShader(){this._cubemapShader===null&&(this._cubemapShader=nr(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){this._equirectShader===null&&(this._equirectShader=ir(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),this._cubemapShader!==null&&this._cubemapShader.dispose(),this._equirectShader!==null&&this._equirectShader.dispose();for(let e=0;e<xi.length;e++)xi[e].dispose()}_cleanup(e){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(Mn),e.scissorTest=!1,ki(e,0,0,e.width,e.height)}_fromTexture(e){Mn=this._renderer.getRenderTarget();const t=this._allocateTargets(e);return this._textureToCubeUV(e,t),this._applyPMREM(t),this._cleanup(t),t}_allocateTargets(e){const t={magFilter:1003,minFilter:1003,generateMipmaps:!1,type:1009,format:1023,encoding:el(e)?e.encoding:3002,depthBuffer:!1},i=tr(t);return i.depthBuffer=!e,this._pingPongRenderTarget=tr(t),i}_compileMaterial(e){const t=new lt(xi[0],e);this._renderer.compile(t,vn)}_sceneToCubeUV(e,t,i,n){const o=new it(90,1,t,i),c=[1,-1,1,1,1,1],l=[1,1,1,-1,-1,-1],h=this._renderer,p=h.autoClear,f=h.outputEncoding,m=h.toneMapping;h.getClearColor(Kn),h.toneMapping=0,h.outputEncoding=3e3,h.autoClear=!1;const _=new Wi({name:"PMREM.Background",side:1,depthWrite:!1,depthTest:!1}),g=new lt(new ui,_);let b=!1;const u=e.background;u?u.isColor&&(_.color.copy(u),e.background=null,b=!0):(_.color.copy(Kn),b=!0);for(let d=0;d<6;d++){const T=d%3;T==0?(o.up.set(0,c[d],0),o.lookAt(l[d],0,0)):T==1?(o.up.set(0,0,c[d]),o.lookAt(0,l[d],0)):(o.up.set(0,c[d],0),o.lookAt(0,0,l[d])),ki(n,T*at,d>2?at:0,at,at),h.setRenderTarget(n),b&&h.render(g,o),h.render(e,o)}g.geometry.dispose(),g.material.dispose(),h.toneMapping=m,h.outputEncoding=f,h.autoClear=p,e.background=u}_setEncoding(e,t){this._renderer.capabilities.isWebGL2===!0&&t.format===1023&&t.type===1009&&t.encoding===3001?e.value=Pt[3e3]:e.value=Pt[t.encoding]}_textureToCubeUV(e,t){const i=this._renderer;e.isCubeTexture?this._cubemapShader==null&&(this._cubemapShader=nr()):this._equirectShader==null&&(this._equirectShader=ir());const n=e.isCubeTexture?this._cubemapShader:this._equirectShader,r=new lt(xi[0],n),s=n.uniforms;s.envMap.value=e,e.isCubeTexture||s.texelSize.value.set(1/e.image.width,1/e.image.height),this._setEncoding(s.inputEncoding,e),this._setEncoding(s.outputEncoding,t.texture),ki(t,0,0,3*at,2*at),i.setRenderTarget(t),i.render(r,vn)}_applyPMREM(e){const t=this._renderer,i=t.autoClear;t.autoClear=!1;for(let n=1;n<Rr;n++){const r=Math.sqrt(Vi[n]*Vi[n]-Vi[n-1]*Vi[n-1]),s=er[(n-1)%er.length];this._blur(e,n-1,n,r,s)}t.autoClear=i}_blur(e,t,i,n,r){const s=this._pingPongRenderTarget;this._halfBlur(e,s,t,i,n,"latitudinal",r),this._halfBlur(s,e,i,i,n,"longitudinal",r)}_halfBlur(e,t,i,n,r,s,o){const c=this._renderer,l=this._blurMaterial;s!=="latitudinal"&&s!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const h=3,p=new lt(xi[n],l),f=l.uniforms,m=Qn[i]-1,_=isFinite(r)?Math.PI/(2*m):2*Math.PI/(2*ei-1),g=r/_,b=isFinite(r)?1+Math.floor(h*g):ei;b>ei&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${b} samples when the maximum is set to ${ei}`);const u=[];let d=0;for(let E=0;E<ei;++E){const v=E/g,U=Math.exp(-v*v/2);u.push(U),E==0?d+=U:E<b&&(d+=2*U)}for(let E=0;E<u.length;E++)u[E]=u[E]/d;f.envMap.value=e.texture,f.samples.value=b,f.weights.value=u,f.latitudinal.value=s==="latitudinal",o&&(f.poleAxis.value=o),f.dTheta.value=_,f.mipInt.value=Rt-i,this._setEncoding(f.inputEncoding,e.texture),this._setEncoding(f.outputEncoding,e.texture);const T=Qn[n],M=3*Math.max(0,at-2*T),w=(n===0?0:2*at)+2*T*(n>Rt-ni?n-Rt+ni:0);ki(t,M,w,3*T,2*T),c.setRenderTarget(t),c.render(p,vn)}}function el(a){return a===void 0||a.type!==1009?!1:a.encoding===3e3||a.encoding===3001||a.encoding===3007}function tl(){const a=[],e=[],t=[];let i=Rt;for(let n=0;n<Rr;n++){const r=Math.pow(2,i);e.push(r);let s=1/r;n>Rt-ni?s=Cr[n-Rt+ni-1]:n==0&&(s=0),t.push(s);const o=1/(r-1),c=-o/2,l=1+o/2,h=[c,c,l,c,l,l,c,c,l,l,c,l],p=6,f=6,m=3,_=2,g=1,b=new Float32Array(m*f*p),u=new Float32Array(_*f*p),d=new Float32Array(g*f*p);for(let M=0;M<p;M++){const w=M%3*2/3-1,E=M>2?0:-1,v=[w,E,0,w+2/3,E,0,w+2/3,E+1,0,w,E,0,w+2/3,E+1,0,w,E+1,0];b.set(v,m*f*M),u.set(h,_*f*M);const U=[M,M,M,M,M,M];d.set(U,g*f*M)}const T=new xt;T.setAttribute("position",new je(b,m)),T.setAttribute("uv",new je(u,_)),T.setAttribute("faceIndex",new je(d,g)),a.push(T),i>ni&&i--}return{_lodPlanes:a,_sizeLods:e,_sigmas:t}}function tr(a){const e=new Ct(3*at,3*at,a);return e.texture.mapping=306,e.texture.name="PMREM.cubeUv",e.scissorTest=!0,e}function ki(a,e,t,i,n){a.viewport.set(e,t,i,n),a.scissor.set(e,t,i,n)}function il(a){const e=new Float32Array(a),t=new C(0,1,0);return new Hi({name:"SphericalGaussianBlur",defines:{n:a},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:e},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:t},inputEncoding:{value:Pt[3e3]},outputEncoding:{value:Pt[3e3]}},vertexShader:Cn(),fragmentShader:`precision mediump float;precision mediump int;varying vec3 vOutputDirection;uniform sampler2D envMap;uniform int samples;uniform float weights[n];uniform bool latitudinal;uniform float dTheta;uniform float mipInt;uniform vec3 poleAxis;
${Rn()}
#define ENVMAP_TYPE_CUBE_UV
#include <cube_uv_reflection_fragment>
vec3 getSample(float theta,vec3 axis){float cosTheta=cos(theta);vec3 sampleDirection=vOutputDirection*cosTheta+cross(axis,vOutputDirection)*sin(theta)+axis*dot(axis,vOutputDirection)*(1.0-cosTheta);return bilinearCubeUV(envMap,sampleDirection,mipInt);}void main(){vec3 axis=latitudinal?poleAxis:cross(poleAxis,vOutputDirection);if(all(equal(axis,vec3(0.0)))){axis=vec3(vOutputDirection.z,0.0,-vOutputDirection.x);}axis=normalize(axis);gl_FragColor=vec4(0.0,0.0,0.0,1.0);gl_FragColor.rgb+=weights[0]*getSample(0.0,axis);for(int i=1;i<n;i++){if(i>=samples){break;}float theta=dTheta*float(i);gl_FragColor.rgb+=weights[i]*getSample(-1.0*theta,axis);gl_FragColor.rgb+=weights[i]*getSample(theta,axis);}gl_FragColor=linearToOutputTexel(gl_FragColor);}`,blending:0,depthTest:!1,depthWrite:!1})}function ir(){const a=new Re(1,1);return new Hi({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:a},inputEncoding:{value:Pt[3e3]},outputEncoding:{value:Pt[3e3]}},vertexShader:Cn(),fragmentShader:`precision mediump float;precision mediump int;varying vec3 vOutputDirection;uniform sampler2D envMap;uniform vec2 texelSize;
${Rn()}
#include <common>
void main(){gl_FragColor=vec4(0.0,0.0,0.0,1.0);vec3 outputDirection=normalize(vOutputDirection);vec2 uv=equirectUv(outputDirection);vec2 f=fract(uv/texelSize-0.5);uv-=f*texelSize;vec3 tl=envMapTexelToLinear(texture2D(envMap,uv)).rgb;uv.x+=texelSize.x;vec3 tr=envMapTexelToLinear(texture2D(envMap,uv)).rgb;uv.y+=texelSize.y;vec3 br=envMapTexelToLinear(texture2D(envMap,uv)).rgb;uv.x-=texelSize.x;vec3 bl=envMapTexelToLinear(texture2D(envMap,uv)).rgb;vec3 tm=mix(tl,tr,f.x);vec3 bm=mix(bl,br,f.x);gl_FragColor.rgb=mix(tm,bm,f.y);gl_FragColor=linearToOutputTexel(gl_FragColor);}`,blending:0,depthTest:!1,depthWrite:!1})}function nr(){return new Hi({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:Pt[3e3]},outputEncoding:{value:Pt[3e3]}},vertexShader:Cn(),fragmentShader:`precision mediump float;precision mediump int;varying vec3 vOutputDirection;uniform samplerCube envMap;
${Rn()}
void main(){gl_FragColor=vec4(0.0,0.0,0.0,1.0);gl_FragColor.rgb=envMapTexelToLinear(textureCube(envMap,vec3(-vOutputDirection.x,vOutputDirection.yz))).rgb;gl_FragColor=linearToOutputTexel(gl_FragColor);}`,blending:0,depthTest:!1,depthWrite:!1})}function Cn(){return"precision mediump float;precision mediump int;attribute vec3 position;attribute vec2 uv;attribute float faceIndex;varying vec3 vOutputDirection;vec3 getDirection(vec2 uv,float face){uv=2.0*uv-1.0;vec3 direction=vec3(uv,1.0);if(face==0.0){direction=direction.zyx;}else if(face==1.0){direction=direction.xzy;direction.xz*=-1.0;}else if(face==2.0){direction.x*=-1.0;}else if(face==3.0){direction=direction.zyx;direction.xz*=-1.0;}else if(face==4.0){direction=direction.xzy;direction.xy*=-1.0;}else if(face==5.0){direction.z*=-1.0;}return direction;}void main(){vOutputDirection=getDirection(uv,faceIndex);gl_Position=vec4(position,1.0);}"}function Rn(){return`uniform int inputEncoding;uniform int outputEncoding;
#include <encodings_pars_fragment>
vec4 inputTexelToLinear(vec4 value){if(inputEncoding==0){return value;}else if(inputEncoding==1){return sRGBToLinear(value);}else if(inputEncoding==2){return RGBEToLinear(value);}else if(inputEncoding==3){return RGBMToLinear(value,7.0);}else if(inputEncoding==4){return RGBMToLinear(value,16.0);}else if(inputEncoding==5){return RGBDToLinear(value,256.0);}else{return GammaToLinear(value,2.2);}}vec4 linearToOutputTexel(vec4 value){if(outputEncoding==0){return value;}else if(outputEncoding==1){return LinearTosRGB(value);}else if(outputEncoding==2){return LinearToRGBE(value);}else if(outputEncoding==3){return LinearToRGBM(value,7.0);}else if(outputEncoding==4){return LinearToRGBM(value,16.0);}else if(outputEncoding==5){return LinearToRGBD(value,256.0);}else{return LinearToGamma(value,2.2);}}vec4 envMapTexelToLinear(vec4 color){return inputTexelToLinear(color);}`}function nl(a){let e=new WeakMap,t=null;function i(o){if(o&&o.isTexture&&o.isRenderTargetTexture===!1){const c=o.mapping,l=c===303||c===304,h=c===301||c===302;if(l||h){if(e.has(o))return e.get(o).texture;{const p=o.image;if(l&&p&&p.height>0||h&&p&&n(p)){const f=a.getRenderTarget();t===null&&(t=new Ko(a));const m=l?t.fromEquirectangular(o):t.fromCubemap(o);return e.set(o,m),a.setRenderTarget(f),o.addEventListener("dispose",r),m.texture}else return null}}}return o}function n(o){let c=0;const l=6;for(let h=0;h<l;h++)o[h]!==void 0&&c++;return c===l}function r(o){const c=o.target;c.removeEventListener("dispose",r);const l=e.get(c);l!==void 0&&(e.delete(c),l.dispose())}function s(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:i,dispose:s}}function rl(a){const e={};function t(i){if(e[i]!==void 0)return e[i];let n;switch(i){case"WEBGL_depth_texture":n=a.getExtension("WEBGL_depth_texture")||a.getExtension("MOZ_WEBGL_depth_texture")||a.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":n=a.getExtension("EXT_texture_filter_anisotropic")||a.getExtension("MOZ_EXT_texture_filter_anisotropic")||a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":n=a.getExtension("WEBGL_compressed_texture_s3tc")||a.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":n=a.getExtension("WEBGL_compressed_texture_pvrtc")||a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:n=a.getExtension(i)}return e[i]=n,n}return{has:function(i){return t(i)!==null},init:function(i){i.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float")},get:function(i){const n=t(i);return n===null&&console.warn("THREE.WebGLRenderer: "+i+" extension not supported."),n}}}function al(a,e,t,i){const n={},r=new WeakMap;function s(p){const f=p.target;f.index!==null&&e.remove(f.index);for(const _ in f.attributes)e.remove(f.attributes[_]);f.removeEventListener("dispose",s),delete n[f.id];const m=r.get(f);m&&(e.remove(m),r.delete(f)),i.releaseStatesOfGeometry(f),f.isInstancedBufferGeometry===!0&&delete f._maxInstanceCount,t.memory.geometries--}function o(p,f){return n[f.id]===!0||(f.addEventListener("dispose",s),n[f.id]=!0,t.memory.geometries++),f}function c(p){const f=p.attributes;for(const _ in f)e.update(f[_],34962);const m=p.morphAttributes;for(const _ in m){const g=m[_];for(let b=0,u=g.length;b<u;b++)e.update(g[b],34962)}}function l(p){const f=[],m=p.index,_=p.attributes.position;let g=0;if(m!==null){const d=m.array;g=m.version;for(let T=0,M=d.length;T<M;T+=3){const w=d[T+0],E=d[T+1],v=d[T+2];f.push(w,E,E,v,v,w)}}else{const d=_.array;g=_.version;for(let T=0,M=d.length/3-1;T<M;T+=3){const w=T+0,E=T+1,v=T+2;f.push(w,E,E,v,v,w)}}const b=new(Mr(f)>65535?wr:br)(f,1);b.version=g;const u=r.get(p);u&&e.remove(u),r.set(p,b)}function h(p){const f=r.get(p);if(f){const m=p.index;m!==null&&f.version<m.version&&l(p)}else l(p);return r.get(p)}return{get:o,update:c,getWireframeAttribute:h}}function sl(a,e,t,i){const n=i.isWebGL2;let r;function s(f){r=f}let o,c;function l(f){o=f.type,c=f.bytesPerElement}function h(f,m){a.drawElements(r,m,o,f*c),t.update(m,r,1)}function p(f,m,_){if(_===0)return;let g,b;if(n)g=a,b="drawElementsInstanced";else if(g=e.get("ANGLE_instanced_arrays"),b="drawElementsInstancedANGLE",g===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}g[b](r,m,o,f*c,_),t.update(m,r,_)}this.setMode=s,this.setIndex=l,this.render=h,this.renderInstances=p}function ol(a){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function i(r,s,o){switch(t.calls++,s){case 4:t.triangles+=o*(r/3);break;case 1:t.lines+=o*(r/2);break;case 3:t.lines+=o*(r-1);break;case 2:t.lines+=o*r;break;case 0:t.points+=o*r;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",s);break}}function n(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:n,update:i}}class Dn extends rt{constructor(e=null,t=1,i=1,n=1){super(null),this.image={data:e,width:t,height:i,depth:n},this.magFilter=1003,this.minFilter=1003,this.wrapR=1001,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Dn.prototype.isDataTexture2DArray=!0;function ll(a,e){return a[0]-e[0]}function cl(a,e){return Math.abs(e[1])-Math.abs(a[1])}function rr(a,e){let t=1;const i=e.isInterleavedBufferAttribute?e.data.array:e.array;i instanceof Int8Array?t=127:i instanceof Int16Array?t=32767:i instanceof Int32Array?t=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",i),a.divideScalar(t)}function ul(a,e,t){const i={},n=new Float32Array(8),r=new WeakMap,s=new C,o=[];for(let l=0;l<8;l++)o[l]=[l,0];function c(l,h,p,f){const m=l.morphTargetInfluences;if(e.isWebGL2===!0){const _=h.morphAttributes.position.length;let g=r.get(h);if(g===void 0||g.count!==_){g!==void 0&&g.texture.dispose();const d=h.morphAttributes.normal!==void 0,T=h.morphAttributes.position,M=h.morphAttributes.normal||[],w=h.attributes.position.count,E=d===!0?2:1;let v=w*E,U=1;v>e.maxTextureSize&&(U=Math.ceil(v/e.maxTextureSize),v=e.maxTextureSize);const q=new Float32Array(v*U*4*_),O=new Dn(q,v,U,_);O.format=1023,O.type=1015;const L=E*4;for(let j=0;j<_;j++){const I=T[j],z=M[j],G=v*U*4*j;for(let N=0;N<I.count;N++){s.fromBufferAttribute(I,N),I.normalized===!0&&rr(s,I);const B=N*L;q[G+B+0]=s.x,q[G+B+1]=s.y,q[G+B+2]=s.z,q[G+B+3]=0,d===!0&&(s.fromBufferAttribute(z,N),z.normalized===!0&&rr(s,z),q[G+B+4]=s.x,q[G+B+5]=s.y,q[G+B+6]=s.z,q[G+B+7]=0)}}g={count:_,texture:O,size:new Re(v,U)},r.set(h,g)}let b=0;for(let d=0;d<m.length;d++)b+=m[d];const u=h.morphTargetsRelative?1:1-b;f.getUniforms().setValue(a,"morphTargetBaseInfluence",u),f.getUniforms().setValue(a,"morphTargetInfluences",m),f.getUniforms().setValue(a,"morphTargetsTexture",g.texture,t),f.getUniforms().setValue(a,"morphTargetsTextureSize",g.size)}else{const _=m===void 0?0:m.length;let g=i[h.id];if(g===void 0||g.length!==_){g=[];for(let M=0;M<_;M++)g[M]=[M,0];i[h.id]=g}for(let M=0;M<_;M++){const w=g[M];w[0]=M,w[1]=m[M]}g.sort(cl);for(let M=0;M<8;M++)M<_&&g[M][1]?(o[M][0]=g[M][0],o[M][1]=g[M][1]):(o[M][0]=Number.MAX_SAFE_INTEGER,o[M][1]=0);o.sort(ll);const b=h.morphAttributes.position,u=h.morphAttributes.normal;let d=0;for(let M=0;M<8;M++){const w=o[M],E=w[0],v=w[1];E!==Number.MAX_SAFE_INTEGER&&v?(b&&h.getAttribute("morphTarget"+M)!==b[E]&&h.setAttribute("morphTarget"+M,b[E]),u&&h.getAttribute("morphNormal"+M)!==u[E]&&h.setAttribute("morphNormal"+M,u[E]),n[M]=v,d+=v):(b&&h.hasAttribute("morphTarget"+M)===!0&&h.deleteAttribute("morphTarget"+M),u&&h.hasAttribute("morphNormal"+M)===!0&&h.deleteAttribute("morphNormal"+M),n[M]=0)}const T=h.morphTargetsRelative?1:1-d;f.getUniforms().setValue(a,"morphTargetBaseInfluence",T),f.getUniforms().setValue(a,"morphTargetInfluences",n)}}return{update:c}}function hl(a,e,t,i){let n=new WeakMap;function r(c){const l=i.render.frame,h=c.geometry,p=e.get(c,h);return n.get(p)!==l&&(e.update(p),n.set(p,l)),c.isInstancedMesh&&(c.hasEventListener("dispose",o)===!1&&c.addEventListener("dispose",o),t.update(c.instanceMatrix,34962),c.instanceColor!==null&&t.update(c.instanceColor,34962)),p}function s(){n=new WeakMap}function o(c){const l=c.target;l.removeEventListener("dispose",o),t.remove(l.instanceMatrix),l.instanceColor!==null&&t.remove(l.instanceColor)}return{update:r,dispose:s}}class Dr extends rt{constructor(e=null,t=1,i=1,n=1){super(null),this.image={data:e,width:t,height:i,depth:n},this.magFilter=1003,this.minFilter=1003,this.wrapR=1001,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Dr.prototype.isDataTexture3D=!0;const Pr=new rt,dl=new Dn,fl=new Dr,Fr=new En,ar=[],sr=[],or=new Float32Array(16),lr=new Float32Array(9),cr=new Float32Array(4);function hi(a,e,t){const i=a[0];if(i<=0||i>0)return a;const n=e*t;let r=ar[n];if(r===void 0&&(r=new Float32Array(n),ar[n]=r),e!==0){i.toArray(r,0);for(let s=1,o=0;s!==e;++s)o+=t,a[s].toArray(r,o)}return r}function He(a,e){if(a.length!==e.length)return!1;for(let t=0,i=a.length;t<i;t++)if(a[t]!==e[t])return!1;return!0}function Ve(a,e){for(let t=0,i=e.length;t<i;t++)a[t]=e[t]}function Ir(a,e){let t=sr[e];t===void 0&&(t=new Int32Array(e),sr[e]=t);for(let i=0;i!==e;++i)t[i]=a.allocateTextureUnit();return t}function pl(a,e){const t=this.cache;t[0]!==e&&(a.uniform1f(this.addr,e),t[0]=e)}function ml(a,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(a.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(He(t,e))return;a.uniform2fv(this.addr,e),Ve(t,e)}}function gl(a,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(a.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(a.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(He(t,e))return;a.uniform3fv(this.addr,e),Ve(t,e)}}function _l(a,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(a.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(He(t,e))return;a.uniform4fv(this.addr,e),Ve(t,e)}}function xl(a,e){const t=this.cache,i=e.elements;if(i===void 0){if(He(t,e))return;a.uniformMatrix2fv(this.addr,!1,e),Ve(t,e)}else{if(He(t,i))return;cr.set(i),a.uniformMatrix2fv(this.addr,!1,cr),Ve(t,i)}}function vl(a,e){const t=this.cache,i=e.elements;if(i===void 0){if(He(t,e))return;a.uniformMatrix3fv(this.addr,!1,e),Ve(t,e)}else{if(He(t,i))return;lr.set(i),a.uniformMatrix3fv(this.addr,!1,lr),Ve(t,i)}}function Ml(a,e){const t=this.cache,i=e.elements;if(i===void 0){if(He(t,e))return;a.uniformMatrix4fv(this.addr,!1,e),Ve(t,e)}else{if(He(t,i))return;or.set(i),a.uniformMatrix4fv(this.addr,!1,or),Ve(t,i)}}function yl(a,e){const t=this.cache;t[0]!==e&&(a.uniform1i(this.addr,e),t[0]=e)}function Sl(a,e){const t=this.cache;He(t,e)||(a.uniform2iv(this.addr,e),Ve(t,e))}function bl(a,e){const t=this.cache;He(t,e)||(a.uniform3iv(this.addr,e),Ve(t,e))}function wl(a,e){const t=this.cache;He(t,e)||(a.uniform4iv(this.addr,e),Ve(t,e))}function Tl(a,e){const t=this.cache;t[0]!==e&&(a.uniform1ui(this.addr,e),t[0]=e)}function Al(a,e){const t=this.cache;He(t,e)||(a.uniform2uiv(this.addr,e),Ve(t,e))}function El(a,e){const t=this.cache;He(t,e)||(a.uniform3uiv(this.addr,e),Ve(t,e))}function Ll(a,e){const t=this.cache;He(t,e)||(a.uniform4uiv(this.addr,e),Ve(t,e))}function Cl(a,e,t){const i=this.cache,n=t.allocateTextureUnit();i[0]!==n&&(a.uniform1i(this.addr,n),i[0]=n),t.safeSetTexture2D(e||Pr,n)}function Rl(a,e,t){const i=this.cache,n=t.allocateTextureUnit();i[0]!==n&&(a.uniform1i(this.addr,n),i[0]=n),t.setTexture3D(e||fl,n)}function Dl(a,e,t){const i=this.cache,n=t.allocateTextureUnit();i[0]!==n&&(a.uniform1i(this.addr,n),i[0]=n),t.safeSetTextureCube(e||Fr,n)}function Pl(a,e,t){const i=this.cache,n=t.allocateTextureUnit();i[0]!==n&&(a.uniform1i(this.addr,n),i[0]=n),t.setTexture2DArray(e||dl,n)}function Fl(a){switch(a){case 5126:return pl;case 35664:return ml;case 35665:return gl;case 35666:return _l;case 35674:return xl;case 35675:return vl;case 35676:return Ml;case 5124:case 35670:return yl;case 35667:case 35671:return Sl;case 35668:case 35672:return bl;case 35669:case 35673:return wl;case 5125:return Tl;case 36294:return Al;case 36295:return El;case 36296:return Ll;case 35678:case 36198:case 36298:case 36306:case 35682:return Cl;case 35679:case 36299:case 36307:return Rl;case 35680:case 36300:case 36308:case 36293:return Dl;case 36289:case 36303:case 36311:case 36292:return Pl}}function Il(a,e){a.uniform1fv(this.addr,e)}function Nl(a,e){const t=hi(e,this.size,2);a.uniform2fv(this.addr,t)}function Bl(a,e){const t=hi(e,this.size,3);a.uniform3fv(this.addr,t)}function zl(a,e){const t=hi(e,this.size,4);a.uniform4fv(this.addr,t)}function Ul(a,e){const t=hi(e,this.size,4);a.uniformMatrix2fv(this.addr,!1,t)}function Gl(a,e){const t=hi(e,this.size,9);a.uniformMatrix3fv(this.addr,!1,t)}function Ol(a,e){const t=hi(e,this.size,16);a.uniformMatrix4fv(this.addr,!1,t)}function Vl(a,e){a.uniform1iv(this.addr,e)}function kl(a,e){a.uniform2iv(this.addr,e)}function Wl(a,e){a.uniform3iv(this.addr,e)}function Hl(a,e){a.uniform4iv(this.addr,e)}function ql(a,e){a.uniform1uiv(this.addr,e)}function Xl(a,e){a.uniform2uiv(this.addr,e)}function Yl(a,e){a.uniform3uiv(this.addr,e)}function Zl(a,e){a.uniform4uiv(this.addr,e)}function jl(a,e,t){const i=e.length,n=Ir(t,i);a.uniform1iv(this.addr,n);for(let r=0;r!==i;++r)t.safeSetTexture2D(e[r]||Pr,n[r])}function Jl(a,e,t){const i=e.length,n=Ir(t,i);a.uniform1iv(this.addr,n);for(let r=0;r!==i;++r)t.safeSetTextureCube(e[r]||Fr,n[r])}function $l(a){switch(a){case 5126:return Il;case 35664:return Nl;case 35665:return Bl;case 35666:return zl;case 35674:return Ul;case 35675:return Gl;case 35676:return Ol;case 5124:case 35670:return Vl;case 35667:case 35671:return kl;case 35668:case 35672:return Wl;case 35669:case 35673:return Hl;case 5125:return ql;case 36294:return Xl;case 36295:return Yl;case 36296:return Zl;case 35678:case 36198:case 36298:case 36306:case 35682:return jl;case 35680:case 36300:case 36308:case 36293:return Jl}}function Ql(a,e,t){this.id=a,this.addr=t,this.cache=[],this.setValue=Fl(e.type)}function Nr(a,e,t){this.id=a,this.addr=t,this.cache=[],this.size=e.size,this.setValue=$l(e.type)}Nr.prototype.updateCache=function(a){const e=this.cache;a instanceof Float32Array&&e.length!==a.length&&(this.cache=new Float32Array(a.length)),Ve(e,a)};function Br(a){this.id=a,this.seq=[],this.map={}}Br.prototype.setValue=function(a,e,t){const i=this.seq;for(let n=0,r=i.length;n!==r;++n){const s=i[n];s.setValue(a,e[s.id],t)}};const yn=/(\w+)(\])?(\[|\.)?/g;function ur(a,e){a.seq.push(e),a.map[e.id]=e}function Kl(a,e,t){const i=a.name,n=i.length;for(yn.lastIndex=0;;){const r=yn.exec(i),s=yn.lastIndex;let o=r[1];const c=r[2]==="]",l=r[3];if(c&&(o=o|0),l===void 0||l==="["&&s+2===n){ur(t,l===void 0?new Ql(o,a,e):new Nr(o,a,e));break}else{let p=t.map[o];p===void 0&&(p=new Br(o),ur(t,p)),t=p}}}function Dt(a,e){this.seq=[],this.map={};const t=a.getProgramParameter(e,35718);for(let i=0;i<t;++i){const n=a.getActiveUniform(e,i),r=a.getUniformLocation(e,n.name);Kl(n,r,this)}}Dt.prototype.setValue=function(a,e,t,i){const n=this.map[e];n!==void 0&&n.setValue(a,t,i)};Dt.prototype.setOptional=function(a,e,t){const i=e[t];i!==void 0&&this.setValue(a,t,i)};Dt.upload=function(a,e,t,i){for(let n=0,r=e.length;n!==r;++n){const s=e[n],o=t[s.id];o.needsUpdate!==!1&&s.setValue(a,o.value,i)}};Dt.seqWithValue=function(a,e){const t=[];for(let i=0,n=a.length;i!==n;++i){const r=a[i];r.id in e&&t.push(r)}return t};function hr(a,e,t){const i=a.createShader(e);return a.shaderSource(i,t),a.compileShader(i),i}let ec=0;function tc(a){const e=a.split(`
`);for(let t=0;t<e.length;t++)e[t]=t+1+": "+e[t];return e.join(`
`)}function zr(a){switch(a){case 3e3:return["Linear","( value )"];case 3001:return["sRGB","( value )"];case 3002:return["RGBE","( value )"];case 3004:return["RGBM","( value, 7.0 )"];case 3005:return["RGBM","( value, 16.0 )"];case 3006:return["RGBD","( value, 256.0 )"];case 3007:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case 3003:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",a),["Linear","( value )"]}}function dr(a,e,t){const i=a.getShaderParameter(e,35713),n=a.getShaderInfoLog(e).trim();return i&&n===""?"":t.toUpperCase()+`

`+n+`

`+tc(a.getShaderSource(e))}function ii(a,e){const t=zr(e);return"vec4 "+a+"( vec4 value ) { return "+t[0]+"ToLinear"+t[1]+"; }"}function ic(a,e){const t=zr(e);return"vec4 "+a+"( vec4 value ) { return LinearTo"+t[0]+t[1]+"; }"}function nc(a,e){let t;switch(e){case 1:t="Linear";break;case 2:t="Reinhard";break;case 3:t="OptimizedCineon";break;case 4:t="ACESFilmic";break;case 5:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+a+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function rc(a){return[a.extensionDerivatives||a.envMapCubeUV||a.bumpMap||a.tangentSpaceNormalMap||a.clearcoatNormalMap||a.flatShading||a.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(a.extensionFragDepth||a.logarithmicDepthBuffer)&&a.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",a.extensionDrawBuffers&&a.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(a.extensionShaderTextureLOD||a.envMap||a.transmission)&&a.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(vi).join(`
`)}function ac(a){const e=[];for(const t in a){const i=a[t];i!==!1&&e.push("#define "+t+" "+i)}return e.join(`
`)}function sc(a,e){const t={},i=a.getProgramParameter(e,35721);for(let n=0;n<i;n++){const r=a.getActiveAttrib(e,n),s=r.name;let o=1;r.type===35674&&(o=2),r.type===35675&&(o=3),r.type===35676&&(o=4),t[s]={type:r.type,location:a.getAttribLocation(e,s),locationSize:o}}return t}function vi(a){return a!==""}function fr(a,e){return a.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function pr(a,e){return a.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const oc=/^[ \t]*#include +<([\w\d./]+)>/gm;function bn(a){return a.replace(oc,lc)}function lc(a,e){const t=Me[e];if(t===void 0)throw new Error("Can not resolve #include <"+e+">");return bn(t)}const cc=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,uc=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function mr(a){return a.replace(uc,Ur).replace(cc,hc)}function hc(a,e,t,i){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),Ur(a,e,t,i)}function Ur(a,e,t,i){let n="";for(let r=parseInt(e);r<parseInt(t);r++)n+=i.replace(/\[\s*i\s*\]/g,"[ "+r+" ]").replace(/UNROLLED_LOOP_INDEX/g,r);return n}function gr(a){let e="precision "+a.precision+` float;
precision `+a.precision+" int;";return a.precision==="highp"?e+=`
#define HIGH_PRECISION`:a.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:a.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function dc(a){let e="SHADOWMAP_TYPE_BASIC";return a.shadowMapType===1?e="SHADOWMAP_TYPE_PCF":a.shadowMapType===2?e="SHADOWMAP_TYPE_PCF_SOFT":a.shadowMapType===3&&(e="SHADOWMAP_TYPE_VSM"),e}function fc(a){let e="ENVMAP_TYPE_CUBE";if(a.envMap)switch(a.envMapMode){case 301:case 302:e="ENVMAP_TYPE_CUBE";break;case 306:case 307:e="ENVMAP_TYPE_CUBE_UV";break}return e}function pc(a){let e="ENVMAP_MODE_REFLECTION";if(a.envMap)switch(a.envMapMode){case 302:case 307:e="ENVMAP_MODE_REFRACTION";break}return e}function mc(a){let e="ENVMAP_BLENDING_NONE";if(a.envMap)switch(a.combine){case 0:e="ENVMAP_BLENDING_MULTIPLY";break;case 1:e="ENVMAP_BLENDING_MIX";break;case 2:e="ENVMAP_BLENDING_ADD";break}return e}function gc(a,e,t,i){const n=a.getContext(),r=t.defines;let s=t.vertexShader,o=t.fragmentShader;const c=dc(t),l=fc(t),h=pc(t),p=mc(t),f=a.gammaFactor>0?a.gammaFactor:1,m=t.isWebGL2?"":rc(t),_=ac(r),g=n.createProgram();let b,u,d=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(b=[_].filter(vi).join(`
`),b.length>0&&(b+=`
`),u=[m,_].filter(vi).join(`
`),u.length>0&&(u+=`
`)):(b=[gr(t),"#define SHADER_NAME "+t.shaderName,_,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+f,"#define MAX_BONES "+t.maxBones,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+h:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.displacementMap&&t.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularTintMap?"#define USE_SPECULARTINTMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.useVertexTexture?"#define BONE_TEXTURE":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphTargets&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",t.morphTargets&&t.isWebGL2?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+c:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(vi).join(`
`),u=[m,gr(t),"#define SHADER_NAME "+t.shaderName,_,"#define GAMMA_FACTOR "+f,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+l:"",t.envMap?"#define "+h:"",t.envMap?"#define "+p:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularTintMap?"#define USE_SPECULARTINTMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.sheen?"#define USE_SHEEN":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+c:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(t.extensionShaderTextureLOD||t.envMap)&&t.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==0?"#define TONE_MAPPING":"",t.toneMapping!==0?Me.tonemapping_pars_fragment:"",t.toneMapping!==0?nc("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.format===1022?"#define OPAQUE":"",Me.encodings_pars_fragment,t.map?ii("mapTexelToLinear",t.mapEncoding):"",t.matcap?ii("matcapTexelToLinear",t.matcapEncoding):"",t.envMap?ii("envMapTexelToLinear",t.envMapEncoding):"",t.emissiveMap?ii("emissiveMapTexelToLinear",t.emissiveMapEncoding):"",t.specularTintMap?ii("specularTintMapTexelToLinear",t.specularTintMapEncoding):"",t.lightMap?ii("lightMapTexelToLinear",t.lightMapEncoding):"",ic("linearToOutputTexel",t.outputEncoding),t.depthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(vi).join(`
`)),s=bn(s),s=fr(s,t),s=pr(s,t),o=bn(o),o=fr(o,t),o=pr(o,t),s=mr(s),o=mr(o),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(d=`#version 300 es
`,b=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+b,u=["#define varying in",t.glslVersion===Un?"":"out highp vec4 pc_fragColor;",t.glslVersion===Un?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+u);const T=d+b+s,M=d+u+o,w=hr(n,35633,T),E=hr(n,35632,M);if(n.attachShader(g,w),n.attachShader(g,E),t.index0AttributeName!==void 0?n.bindAttribLocation(g,0,t.index0AttributeName):t.morphTargets===!0&&n.bindAttribLocation(g,0,"position"),n.linkProgram(g),a.debug.checkShaderErrors){const q=n.getProgramInfoLog(g).trim(),O=n.getShaderInfoLog(w).trim(),L=n.getShaderInfoLog(E).trim();let j=!0,I=!0;if(n.getProgramParameter(g,35714)===!1){j=!1;const z=dr(n,w,"vertex"),G=dr(n,E,"fragment");console.error("THREE.WebGLProgram: Shader Error "+n.getError()+" - VALIDATE_STATUS "+n.getProgramParameter(g,35715)+`

Program Info Log: `+q+`
`+z+`
`+G)}else q!==""?console.warn("THREE.WebGLProgram: Program Info Log:",q):(O===""||L==="")&&(I=!1);I&&(this.diagnostics={runnable:j,programLog:q,vertexShader:{log:O,prefix:b},fragmentShader:{log:L,prefix:u}})}n.deleteShader(w),n.deleteShader(E);let v;this.getUniforms=function(){return v===void 0&&(v=new Dt(n,g)),v};let U;return this.getAttributes=function(){return U===void 0&&(U=sc(n,g)),U},this.destroy=function(){i.releaseStatesOfProgram(this),n.deleteProgram(g),this.program=void 0},this.name=t.shaderName,this.id=ec++,this.cacheKey=e,this.usedTimes=1,this.program=g,this.vertexShader=w,this.fragmentShader=E,this}function _c(a,e,t,i,n,r,s){const o=[],c=n.isWebGL2,l=n.logarithmicDepthBuffer,h=n.floatVertexTextures,p=n.maxVertexUniforms,f=n.vertexTextures;let m=n.precision;const _={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},g=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoat","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","specularIntensityMap","specularTintMap","specularTintMapEncoding","roughnessMap","metalnessMap","gradientMap","alphaMap","alphaTest","combine","vertexColors","vertexAlphas","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","morphTargetsCount","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","format","sheen","transmission","transmissionMap","thicknessMap"];function b(v){const q=v.skeleton.bones;if(h)return 1024;{const L=Math.floor((p-20)/4),j=Math.min(L,q.length);return j<q.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+q.length+" bones. This GPU supports "+j+"."),0):j}}function u(v){let U;return v&&v.isTexture?U=v.encoding:v&&v.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),U=v.texture.encoding):U=3e3,c&&v&&v.isTexture&&v.format===1023&&v.type===1009&&v.encoding===3001&&(U=3e3),U}function d(v,U,q,O,L){const j=O.fog,I=v.isMeshStandardMaterial?O.environment:null,z=(v.isMeshStandardMaterial?t:e).get(v.envMap||I),G=_[v.type],N=L.isSkinnedMesh?b(L):0;v.precision!==null&&(m=n.getMaxPrecision(v.precision),m!==v.precision&&console.warn("THREE.WebGLProgram.getParameters:",v.precision,"not supported, using",m,"instead."));let B,Y;if(G){const H=ot[G];B=H.vertexShader,Y=H.fragmentShader}else B=v.vertexShader,Y=v.fragmentShader;const ne=a.getRenderTarget(),oe=v.alphaTest>0,te=v.clearcoat>0;return{isWebGL2:c,shaderID:G,shaderName:v.type,vertexShader:B,fragmentShader:Y,defines:v.defines,isRawShaderMaterial:v.isRawShaderMaterial===!0,glslVersion:v.glslVersion,precision:m,instancing:L.isInstancedMesh===!0,instancingColor:L.isInstancedMesh===!0&&L.instanceColor!==null,supportsVertexTextures:f,outputEncoding:ne!==null?u(ne.texture):a.outputEncoding,map:!!v.map,mapEncoding:u(v.map),matcap:!!v.matcap,matcapEncoding:u(v.matcap),envMap:!!z,envMapMode:z&&z.mapping,envMapEncoding:u(z),envMapCubeUV:!!z&&(z.mapping===306||z.mapping===307),lightMap:!!v.lightMap,lightMapEncoding:u(v.lightMap),aoMap:!!v.aoMap,emissiveMap:!!v.emissiveMap,emissiveMapEncoding:u(v.emissiveMap),bumpMap:!!v.bumpMap,normalMap:!!v.normalMap,objectSpaceNormalMap:v.normalMapType===1,tangentSpaceNormalMap:v.normalMapType===0,clearcoat:te,clearcoatMap:te&&!!v.clearcoatMap,clearcoatRoughnessMap:te&&!!v.clearcoatRoughnessMap,clearcoatNormalMap:te&&!!v.clearcoatNormalMap,displacementMap:!!v.displacementMap,roughnessMap:!!v.roughnessMap,metalnessMap:!!v.metalnessMap,specularMap:!!v.specularMap,specularIntensityMap:!!v.specularIntensityMap,specularTintMap:!!v.specularTintMap,specularTintMapEncoding:u(v.specularTintMap),alphaMap:!!v.alphaMap,alphaTest:oe,gradientMap:!!v.gradientMap,sheen:v.sheen>0,transmission:v.transmission>0,transmissionMap:!!v.transmissionMap,thicknessMap:!!v.thicknessMap,combine:v.combine,vertexTangents:!!v.normalMap&&!!L.geometry&&!!L.geometry.attributes.tangent,vertexColors:v.vertexColors,vertexAlphas:v.vertexColors===!0&&!!L.geometry&&!!L.geometry.attributes.color&&L.geometry.attributes.color.itemSize===4,vertexUvs:!!v.map||!!v.bumpMap||!!v.normalMap||!!v.specularMap||!!v.alphaMap||!!v.emissiveMap||!!v.roughnessMap||!!v.metalnessMap||!!v.clearcoatMap||!!v.clearcoatRoughnessMap||!!v.clearcoatNormalMap||!!v.displacementMap||!!v.transmissionMap||!!v.thicknessMap||!!v.specularIntensityMap||!!v.specularTintMap,uvsVertexOnly:!(!!v.map||!!v.bumpMap||!!v.normalMap||!!v.specularMap||!!v.alphaMap||!!v.emissiveMap||!!v.roughnessMap||!!v.metalnessMap||!!v.clearcoatNormalMap||v.transmission>0||!!v.transmissionMap||!!v.thicknessMap||!!v.specularIntensityMap||!!v.specularTintMap)&&!!v.displacementMap,fog:!!j,useFog:v.fog,fogExp2:j&&j.isFogExp2,flatShading:!!v.flatShading,sizeAttenuation:v.sizeAttenuation,logarithmicDepthBuffer:l,skinning:L.isSkinnedMesh===!0&&N>0,maxBones:N,useVertexTexture:h,morphTargets:!!L.geometry&&!!L.geometry.morphAttributes.position,morphNormals:!!L.geometry&&!!L.geometry.morphAttributes.normal,morphTargetsCount:!!L.geometry&&!!L.geometry.morphAttributes.position?L.geometry.morphAttributes.position.length:0,numDirLights:U.directional.length,numPointLights:U.point.length,numSpotLights:U.spot.length,numRectAreaLights:U.rectArea.length,numHemiLights:U.hemi.length,numDirLightShadows:U.directionalShadowMap.length,numPointLightShadows:U.pointShadowMap.length,numSpotLightShadows:U.spotShadowMap.length,numClippingPlanes:s.numPlanes,numClipIntersection:s.numIntersection,format:v.format,dithering:v.dithering,shadowMapEnabled:a.shadowMap.enabled&&q.length>0,shadowMapType:a.shadowMap.type,toneMapping:v.toneMapped?a.toneMapping:0,physicallyCorrectLights:a.physicallyCorrectLights,premultipliedAlpha:v.premultipliedAlpha,doubleSided:v.side===2,flipSided:v.side===1,depthPacking:v.depthPacking!==void 0?v.depthPacking:!1,index0AttributeName:v.index0AttributeName,extensionDerivatives:v.extensions&&v.extensions.derivatives,extensionFragDepth:v.extensions&&v.extensions.fragDepth,extensionDrawBuffers:v.extensions&&v.extensions.drawBuffers,extensionShaderTextureLOD:v.extensions&&v.extensions.shaderTextureLOD,rendererExtensionFragDepth:c||i.has("EXT_frag_depth"),rendererExtensionDrawBuffers:c||i.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:c||i.has("EXT_shader_texture_lod"),customProgramCacheKey:v.customProgramCacheKey()}}function T(v){const U=[];if(v.shaderID?U.push(v.shaderID):(U.push(v.fragmentShader),U.push(v.vertexShader)),v.defines!==void 0)for(const q in v.defines)U.push(q),U.push(v.defines[q]);if(v.isRawShaderMaterial===!1){for(let q=0;q<g.length;q++)U.push(v[g[q]]);U.push(a.outputEncoding),U.push(a.gammaFactor)}return U.push(v.customProgramCacheKey),U.join()}function M(v){const U=_[v.type];let q;if(U){const O=ot[U];q=fa.clone(O.uniforms)}else q=v.uniforms;return q}function w(v,U){let q;for(let O=0,L=o.length;O<L;O++){const j=o[O];if(j.cacheKey===U){q=j,++q.usedTimes;break}}return q===void 0&&(q=new gc(a,U,v,r),o.push(q)),q}function E(v){if(--v.usedTimes===0){const U=o.indexOf(v);o[U]=o[o.length-1],o.pop(),v.destroy()}}return{getParameters:d,getProgramCacheKey:T,getUniforms:M,acquireProgram:w,releaseProgram:E,programs:o}}function xc(){let a=new WeakMap;function e(r){let s=a.get(r);return s===void 0&&(s={},a.set(r,s)),s}function t(r){a.delete(r)}function i(r,s,o){a.get(r)[s]=o}function n(){a=new WeakMap}return{get:e,remove:t,update:i,dispose:n}}function vc(a,e){return a.groupOrder!==e.groupOrder?a.groupOrder-e.groupOrder:a.renderOrder!==e.renderOrder?a.renderOrder-e.renderOrder:a.program!==e.program?a.program.id-e.program.id:a.material.id!==e.material.id?a.material.id-e.material.id:a.z!==e.z?a.z-e.z:a.id-e.id}function _r(a,e){return a.groupOrder!==e.groupOrder?a.groupOrder-e.groupOrder:a.renderOrder!==e.renderOrder?a.renderOrder-e.renderOrder:a.z!==e.z?e.z-a.z:a.id-e.id}function xr(a){const e=[];let t=0;const i=[],n=[],r=[],s={id:-1};function o(){t=0,i.length=0,n.length=0,r.length=0}function c(m,_,g,b,u,d){let T=e[t];const M=a.get(g);return T===void 0?(T={id:m.id,object:m,geometry:_,material:g,program:M.program||s,groupOrder:b,renderOrder:m.renderOrder,z:u,group:d},e[t]=T):(T.id=m.id,T.object=m,T.geometry=_,T.material=g,T.program=M.program||s,T.groupOrder=b,T.renderOrder=m.renderOrder,T.z=u,T.group=d),t++,T}function l(m,_,g,b,u,d){const T=c(m,_,g,b,u,d);g.transmission>0?n.push(T):g.transparent===!0?r.push(T):i.push(T)}function h(m,_,g,b,u,d){const T=c(m,_,g,b,u,d);g.transmission>0?n.unshift(T):g.transparent===!0?r.unshift(T):i.unshift(T)}function p(m,_){i.length>1&&i.sort(m||vc),n.length>1&&n.sort(_||_r),r.length>1&&r.sort(_||_r)}function f(){for(let m=t,_=e.length;m<_;m++){const g=e[m];if(g.id===null)break;g.id=null,g.object=null,g.geometry=null,g.material=null,g.program=null,g.group=null}}return{opaque:i,transmissive:n,transparent:r,init:o,push:l,unshift:h,finish:f,sort:p}}function Mc(a){let e=new WeakMap;function t(n,r){let s;return e.has(n)===!1?(s=new xr(a),e.set(n,[s])):r>=e.get(n).length?(s=new xr(a),e.get(n).push(s)):s=e.get(n)[r],s}function i(){e=new WeakMap}return{get:t,dispose:i}}function yc(){const a={};return{get:function(e){if(a[e.id]!==void 0)return a[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new C,color:new Ee};break;case"SpotLight":t={position:new C,direction:new C,color:new Ee,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new C,color:new Ee,distance:0,decay:0};break;case"HemisphereLight":t={direction:new C,skyColor:new Ee,groundColor:new Ee};break;case"RectAreaLight":t={color:new Ee,position:new C,halfWidth:new C,halfHeight:new C};break}return a[e.id]=t,t}}}function Sc(){const a={};return{get:function(e){if(a[e.id]!==void 0)return a[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Re};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Re};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Re,shadowCameraNear:1,shadowCameraFar:1e3};break}return a[e.id]=t,t}}}let bc=0;function wc(a,e){return(e.castShadow?1:0)-(a.castShadow?1:0)}function Tc(a,e){const t=new yc,i=Sc(),n={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let h=0;h<9;h++)n.probe.push(new C);const r=new C,s=new ze,o=new ze;function c(h,p){let f=0,m=0,_=0;for(let q=0;q<9;q++)n.probe[q].set(0,0,0);let g=0,b=0,u=0,d=0,T=0,M=0,w=0,E=0;h.sort(wc);const v=p!==!0?Math.PI:1;for(let q=0,O=h.length;q<O;q++){const L=h[q],j=L.color,I=L.intensity,z=L.distance,G=L.shadow&&L.shadow.map?L.shadow.map.texture:null;if(L.isAmbientLight)f+=j.r*I*v,m+=j.g*I*v,_+=j.b*I*v;else if(L.isLightProbe)for(let N=0;N<9;N++)n.probe[N].addScaledVector(L.sh.coefficients[N],I);else if(L.isDirectionalLight){const N=t.get(L);if(N.color.copy(L.color).multiplyScalar(L.intensity*v),L.castShadow){const B=L.shadow,Y=i.get(L);Y.shadowBias=B.bias,Y.shadowNormalBias=B.normalBias,Y.shadowRadius=B.radius,Y.shadowMapSize=B.mapSize,n.directionalShadow[g]=Y,n.directionalShadowMap[g]=G,n.directionalShadowMatrix[g]=L.shadow.matrix,M++}n.directional[g]=N,g++}else if(L.isSpotLight){const N=t.get(L);if(N.position.setFromMatrixPosition(L.matrixWorld),N.color.copy(j).multiplyScalar(I*v),N.distance=z,N.coneCos=Math.cos(L.angle),N.penumbraCos=Math.cos(L.angle*(1-L.penumbra)),N.decay=L.decay,L.castShadow){const B=L.shadow,Y=i.get(L);Y.shadowBias=B.bias,Y.shadowNormalBias=B.normalBias,Y.shadowRadius=B.radius,Y.shadowMapSize=B.mapSize,n.spotShadow[u]=Y,n.spotShadowMap[u]=G,n.spotShadowMatrix[u]=L.shadow.matrix,E++}n.spot[u]=N,u++}else if(L.isRectAreaLight){const N=t.get(L);N.color.copy(j).multiplyScalar(I),N.halfWidth.set(L.width*.5,0,0),N.halfHeight.set(0,L.height*.5,0),n.rectArea[d]=N,d++}else if(L.isPointLight){const N=t.get(L);if(N.color.copy(L.color).multiplyScalar(L.intensity*v),N.distance=L.distance,N.decay=L.decay,L.castShadow){const B=L.shadow,Y=i.get(L);Y.shadowBias=B.bias,Y.shadowNormalBias=B.normalBias,Y.shadowRadius=B.radius,Y.shadowMapSize=B.mapSize,Y.shadowCameraNear=B.camera.near,Y.shadowCameraFar=B.camera.far,n.pointShadow[b]=Y,n.pointShadowMap[b]=G,n.pointShadowMatrix[b]=L.shadow.matrix,w++}n.point[b]=N,b++}else if(L.isHemisphereLight){const N=t.get(L);N.skyColor.copy(L.color).multiplyScalar(I*v),N.groundColor.copy(L.groundColor).multiplyScalar(I*v),n.hemi[T]=N,T++}}d>0&&(e.isWebGL2||a.has("OES_texture_float_linear")===!0?(n.rectAreaLTC1=Z.LTC_FLOAT_1,n.rectAreaLTC2=Z.LTC_FLOAT_2):a.has("OES_texture_half_float_linear")===!0?(n.rectAreaLTC1=Z.LTC_HALF_1,n.rectAreaLTC2=Z.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),n.ambient[0]=f,n.ambient[1]=m,n.ambient[2]=_;const U=n.hash;(U.directionalLength!==g||U.pointLength!==b||U.spotLength!==u||U.rectAreaLength!==d||U.hemiLength!==T||U.numDirectionalShadows!==M||U.numPointShadows!==w||U.numSpotShadows!==E)&&(n.directional.length=g,n.spot.length=u,n.rectArea.length=d,n.point.length=b,n.hemi.length=T,n.directionalShadow.length=M,n.directionalShadowMap.length=M,n.pointShadow.length=w,n.pointShadowMap.length=w,n.spotShadow.length=E,n.spotShadowMap.length=E,n.directionalShadowMatrix.length=M,n.pointShadowMatrix.length=w,n.spotShadowMatrix.length=E,U.directionalLength=g,U.pointLength=b,U.spotLength=u,U.rectAreaLength=d,U.hemiLength=T,U.numDirectionalShadows=M,U.numPointShadows=w,U.numSpotShadows=E,n.version=bc++)}function l(h,p){let f=0,m=0,_=0,g=0,b=0;const u=p.matrixWorldInverse;for(let d=0,T=h.length;d<T;d++){const M=h[d];if(M.isDirectionalLight){const w=n.directional[f];w.direction.setFromMatrixPosition(M.matrixWorld),r.setFromMatrixPosition(M.target.matrixWorld),w.direction.sub(r),w.direction.transformDirection(u),f++}else if(M.isSpotLight){const w=n.spot[_];w.position.setFromMatrixPosition(M.matrixWorld),w.position.applyMatrix4(u),w.direction.setFromMatrixPosition(M.matrixWorld),r.setFromMatrixPosition(M.target.matrixWorld),w.direction.sub(r),w.direction.transformDirection(u),_++}else if(M.isRectAreaLight){const w=n.rectArea[g];w.position.setFromMatrixPosition(M.matrixWorld),w.position.applyMatrix4(u),o.identity(),s.copy(M.matrixWorld),s.premultiply(u),o.extractRotation(s),w.halfWidth.set(M.width*.5,0,0),w.halfHeight.set(0,M.height*.5,0),w.halfWidth.applyMatrix4(o),w.halfHeight.applyMatrix4(o),g++}else if(M.isPointLight){const w=n.point[m];w.position.setFromMatrixPosition(M.matrixWorld),w.position.applyMatrix4(u),m++}else if(M.isHemisphereLight){const w=n.hemi[b];w.direction.setFromMatrixPosition(M.matrixWorld),w.direction.transformDirection(u),w.direction.normalize(),b++}}}return{setup:c,setupView:l,state:n}}function vr(a,e){const t=new Tc(a,e),i=[],n=[];function r(){i.length=0,n.length=0}function s(p){i.push(p)}function o(p){n.push(p)}function c(p){t.setup(i,p)}function l(p){t.setupView(i,p)}return{init:r,state:{lightsArray:i,shadowsArray:n,lights:t},setupLights:c,setupLightsView:l,pushLight:s,pushShadow:o}}function Ac(a,e){let t=new WeakMap;function i(r,s=0){let o;return t.has(r)===!1?(o=new vr(a,e),t.set(r,[o])):s>=t.get(r).length?(o=new vr(a,e),t.get(r).push(o)):o=t.get(r)[s],o}function n(){t=new WeakMap}return{get:i,dispose:n}}class Gr extends Si{constructor(e){super(),this.type="MeshDepthMaterial",this.depthPacking=3200,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}Gr.prototype.isMeshDepthMaterial=!0;class Or extends Si{constructor(e){super(),this.type="MeshDistanceMaterial",this.referencePosition=new C,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(e)}copy(e){return super.copy(e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}Or.prototype.isMeshDistanceMaterial=!0;const Ec="void main(){gl_Position=vec4(position,1.0);}",Lc=`uniform sampler2D shadow_pass;uniform vec2 resolution;uniform float radius;uniform float samples;
#include <packing>
void main(){float mean=0.0;float squared_mean=0.0;float uvStride=samples<=1.0?0.0:2.0/(samples-1.0);float uvStart=samples<=1.0?0.0:-1.0;for(float i=0.0;i<samples;i++){float uvOffset=uvStart+i*uvStride;
#ifdef HORIZONTAL_PASS
vec2 distribution=unpackRGBATo2Half(texture2D(shadow_pass,(gl_FragCoord.xy+vec2(uvOffset,0.0)*radius)/resolution));mean+=distribution.x;squared_mean+=distribution.y*distribution.y+distribution.x*distribution.x;
#else
float depth=unpackRGBAToDepth(texture2D(shadow_pass,(gl_FragCoord.xy+vec2(0.0,uvOffset)*radius)/resolution));mean+=depth;squared_mean+=depth*depth;
#endif
}mean=mean/samples;squared_mean=squared_mean/samples;float std_dev=sqrt(squared_mean-mean*mean);gl_FragColor=pack2HalfToRGBA(vec2(mean,std_dev));}`;function Cc(a,e,t){let i=new Ar;const n=new Re,r=new Re,s=new We,o=new Gr({depthPacking:3201}),c=new Or,l={},h=t.maxTextureSize,p={0:1,1:0,2:2},f=new ai({uniforms:{shadow_pass:{value:null},resolution:{value:new Re},radius:{value:4},samples:{value:8}},vertexShader:Ec,fragmentShader:Lc}),m=f.clone();m.defines.HORIZONTAL_PASS=1;const _=new xt;_.setAttribute("position",new je(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const g=new lt(_,f),b=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=1,this.render=function(M,w,E){if(b.enabled===!1||b.autoUpdate===!1&&b.needsUpdate===!1||M.length===0)return;const v=a.getRenderTarget(),U=a.getActiveCubeFace(),q=a.getActiveMipmapLevel(),O=a.state;O.setBlending(0),O.buffers.color.setClear(1,1,1,1),O.buffers.depth.setTest(!0),O.setScissorTest(!1);for(let L=0,j=M.length;L<j;L++){const I=M[L],z=I.shadow;if(z===void 0){console.warn("THREE.WebGLShadowMap:",I,"has no shadow.");continue}if(z.autoUpdate===!1&&z.needsUpdate===!1)continue;n.copy(z.mapSize);const G=z.getFrameExtents();if(n.multiply(G),r.copy(z.mapSize),(n.x>h||n.y>h)&&(n.x>h&&(r.x=Math.floor(h/G.x),n.x=r.x*G.x,z.mapSize.x=r.x),n.y>h&&(r.y=Math.floor(h/G.y),n.y=r.y*G.y,z.mapSize.y=r.y)),z.map===null&&!z.isPointLightShadow&&this.type===3){const B={minFilter:1006,magFilter:1006,format:1023};z.map=new Ct(n.x,n.y,B),z.map.texture.name=I.name+".shadowMap",z.mapPass=new Ct(n.x,n.y,B),z.camera.updateProjectionMatrix()}if(z.map===null){const B={minFilter:1003,magFilter:1003,format:1023};z.map=new Ct(n.x,n.y,B),z.map.texture.name=I.name+".shadowMap",z.camera.updateProjectionMatrix()}a.setRenderTarget(z.map),a.clear();const N=z.getViewportCount();for(let B=0;B<N;B++){const Y=z.getViewport(B);s.set(r.x*Y.x,r.y*Y.y,r.x*Y.z,r.y*Y.w),O.viewport(s),z.updateMatrices(I,B),i=z.getFrustum(),T(w,E,z.camera,I,this.type)}!z.isPointLightShadow&&this.type===3&&u(z,E),z.needsUpdate=!1}b.needsUpdate=!1,a.setRenderTarget(v,U,q)};function u(M,w){const E=e.update(g);f.uniforms.shadow_pass.value=M.map.texture,f.uniforms.resolution.value=M.mapSize,f.uniforms.radius.value=M.radius,f.uniforms.samples.value=M.blurSamples,a.setRenderTarget(M.mapPass),a.clear(),a.renderBufferDirect(w,null,E,f,g,null),m.uniforms.shadow_pass.value=M.mapPass.texture,m.uniforms.resolution.value=M.mapSize,m.uniforms.radius.value=M.radius,m.uniforms.samples.value=M.blurSamples,a.setRenderTarget(M.map),a.clear(),a.renderBufferDirect(w,null,E,m,g,null)}function d(M,w,E,v,U,q,O){let L=null;const j=v.isPointLight===!0?M.customDistanceMaterial:M.customDepthMaterial;if(j!==void 0?L=j:L=v.isPointLight===!0?c:o,a.localClippingEnabled&&E.clipShadows===!0&&E.clippingPlanes.length!==0||E.displacementMap&&E.displacementScale!==0||E.alphaMap&&E.alphaTest>0){const I=L.uuid,z=E.uuid;let G=l[I];G===void 0&&(G={},l[I]=G);let N=G[z];N===void 0&&(N=L.clone(),G[z]=N),L=N}return L.visible=E.visible,L.wireframe=E.wireframe,O===3?L.side=E.shadowSide!==null?E.shadowSide:E.side:L.side=E.shadowSide!==null?E.shadowSide:p[E.side],L.alphaMap=E.alphaMap,L.alphaTest=E.alphaTest,L.clipShadows=E.clipShadows,L.clippingPlanes=E.clippingPlanes,L.clipIntersection=E.clipIntersection,L.displacementMap=E.displacementMap,L.displacementScale=E.displacementScale,L.displacementBias=E.displacementBias,L.wireframeLinewidth=E.wireframeLinewidth,L.linewidth=E.linewidth,v.isPointLight===!0&&L.isMeshDistanceMaterial===!0&&(L.referencePosition.setFromMatrixPosition(v.matrixWorld),L.nearDistance=U,L.farDistance=q),L}function T(M,w,E,v,U){if(M.visible===!1)return;if(M.layers.test(w.layers)&&(M.isMesh||M.isLine||M.isPoints)&&(M.castShadow||M.receiveShadow&&U===3)&&(!M.frustumCulled||i.intersectsObject(M))){M.modelViewMatrix.multiplyMatrices(E.matrixWorldInverse,M.matrixWorld);const L=e.update(M),j=M.material;if(Array.isArray(j)){const I=L.groups;for(let z=0,G=I.length;z<G;z++){const N=I[z],B=j[N.materialIndex];if(B&&B.visible){const Y=d(M,L,B,v,E.near,E.far,U);a.renderBufferDirect(E,null,L,Y,M,N)}}}else if(j.visible){const I=d(M,L,j,v,E.near,E.far,U);a.renderBufferDirect(E,null,L,I,M,null)}}const O=M.children;for(let L=0,j=O.length;L<j;L++)T(O[L],w,E,v,U)}}function Rc(a,e,t){const i=t.isWebGL2;function n(){let A=!1;const Q=new We;let k=null;const ee=new We(0,0,0,0);return{setMask:function(ae){k!==ae&&!A&&(a.colorMask(ae,ae,ae,ae),k=ae)},setLocked:function(ae){A=ae},setClear:function(ae,ye,Ue,Ge,vt){vt===!0&&(ae*=Ge,ye*=Ge,Ue*=Ge),Q.set(ae,ye,Ue,Ge),ee.equals(Q)===!1&&(a.clearColor(ae,ye,Ue,Ge),ee.copy(Q))},reset:function(){A=!1,k=null,ee.set(-1,0,0,0)}}}function r(){let A=!1,Q=null,k=null,ee=null;return{setTest:function(ae){ae?X(2929):re(2929)},setMask:function(ae){Q!==ae&&!A&&(a.depthMask(ae),Q=ae)},setFunc:function(ae){if(k!==ae){if(ae)switch(ae){case 0:a.depthFunc(512);break;case 1:a.depthFunc(519);break;case 2:a.depthFunc(513);break;case 3:a.depthFunc(515);break;case 4:a.depthFunc(514);break;case 5:a.depthFunc(518);break;case 6:a.depthFunc(516);break;case 7:a.depthFunc(517);break;default:a.depthFunc(515)}else a.depthFunc(515);k=ae}},setLocked:function(ae){A=ae},setClear:function(ae){ee!==ae&&(a.clearDepth(ae),ee=ae)},reset:function(){A=!1,Q=null,k=null,ee=null}}}function s(){let A=!1,Q=null,k=null,ee=null,ae=null,ye=null,Ue=null,Ge=null,vt=null;return{setTest:function(Ie){A||(Ie?X(2960):re(2960))},setMask:function(Ie){Q!==Ie&&!A&&(a.stencilMask(Ie),Q=Ie)},setFunc:function(Ie,ut,ht){(k!==Ie||ee!==ut||ae!==ht)&&(a.stencilFunc(Ie,ut,ht),k=Ie,ee=ut,ae=ht)},setOp:function(Ie,ut,ht){(ye!==Ie||Ue!==ut||Ge!==ht)&&(a.stencilOp(Ie,ut,ht),ye=Ie,Ue=ut,Ge=ht)},setLocked:function(Ie){A=Ie},setClear:function(Ie){vt!==Ie&&(a.clearStencil(Ie),vt=Ie)},reset:function(){A=!1,Q=null,k=null,ee=null,ae=null,ye=null,Ue=null,Ge=null,vt=null}}}const o=new n,c=new r,l=new s;let h={},p=null,f={},m=null,_=!1,g=null,b=null,u=null,d=null,T=null,M=null,w=null,E=!1,v=null,U=null,q=null,O=null,L=null;const j=a.getParameter(35661);let I=!1,z=0;const G=a.getParameter(7938);G.indexOf("WebGL")!==-1?(z=parseFloat(/^WebGL (\d)/.exec(G)[1]),I=z>=1):G.indexOf("OpenGL ES")!==-1&&(z=parseFloat(/^OpenGL ES (\d)/.exec(G)[1]),I=z>=2);let N=null,B={};const Y=a.getParameter(3088),ne=a.getParameter(2978),oe=new We().fromArray(Y),te=new We().fromArray(ne);function xe(A,Q,k){const ee=new Uint8Array(4),ae=a.createTexture();a.bindTexture(A,ae),a.texParameteri(A,10241,9728),a.texParameteri(A,10240,9728);for(let ye=0;ye<k;ye++)a.texImage2D(Q+ye,0,6408,1,1,0,6408,5121,ee);return ae}const H={};H[3553]=xe(3553,3553,1),H[34067]=xe(34067,34069,6),o.setClear(0,0,0,1),c.setClear(1),l.setClear(0),X(2929),c.setFunc(3),Le(!1),ke(1),X(2884),be(0);function X(A){h[A]!==!0&&(a.enable(A),h[A]=!0)}function re(A){h[A]!==!1&&(a.disable(A),h[A]=!1)}function F(A){A!==p&&(a.bindFramebuffer(36160,A),p=A)}function me(A,Q){return Q===null&&p!==null&&(Q=p),f[A]!==Q?(a.bindFramebuffer(A,Q),f[A]=Q,i&&(A===36009&&(f[36160]=Q),A===36160&&(f[36009]=Q)),!0):!1}function _e(A){return m!==A?(a.useProgram(A),m=A,!0):!1}const K={[100]:32774,[101]:32778,[102]:32779};if(i)K[103]=32775,K[104]=32776;else{const A=e.get("EXT_blend_minmax");A!==null&&(K[103]=A.MIN_EXT,K[104]=A.MAX_EXT)}const ue={[200]:0,[201]:1,[202]:768,[204]:770,[210]:776,[208]:774,[206]:772,[203]:769,[205]:771,[209]:775,[207]:773};function be(A,Q,k,ee,ae,ye,Ue,Ge){if(A===0){_===!0&&(re(3042),_=!1);return}if(_===!1&&(X(3042),_=!0),A!==5){if(A!==g||Ge!==E){if((b!==100||T!==100)&&(a.blendEquation(32774),b=100,T=100),Ge)switch(A){case 1:a.blendFuncSeparate(1,771,1,771);break;case 2:a.blendFunc(1,1);break;case 3:a.blendFuncSeparate(0,0,769,771);break;case 4:a.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",A);break}else switch(A){case 1:a.blendFuncSeparate(770,771,1,771);break;case 2:a.blendFunc(770,1);break;case 3:a.blendFunc(0,769);break;case 4:a.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",A);break}u=null,d=null,M=null,w=null,g=A,E=Ge}return}ae=ae||Q,ye=ye||k,Ue=Ue||ee,(Q!==b||ae!==T)&&(a.blendEquationSeparate(K[Q],K[ae]),b=Q,T=ae),(k!==u||ee!==d||ye!==M||Ue!==w)&&(a.blendFuncSeparate(ue[k],ue[ee],ue[ye],ue[Ue]),u=k,d=ee,M=ye,w=Ue),g=A,E=null}function he(A,Q){A.side===2?re(2884):X(2884);let k=A.side===1;Q&&(k=!k),Le(k),A.blending===1&&A.transparent===!1?be(0):be(A.blending,A.blendEquation,A.blendSrc,A.blendDst,A.blendEquationAlpha,A.blendSrcAlpha,A.blendDstAlpha,A.premultipliedAlpha),c.setFunc(A.depthFunc),c.setTest(A.depthTest),c.setMask(A.depthWrite),o.setMask(A.colorWrite);const ee=A.stencilWrite;l.setTest(ee),ee&&(l.setMask(A.stencilWriteMask),l.setFunc(A.stencilFunc,A.stencilRef,A.stencilFuncMask),l.setOp(A.stencilFail,A.stencilZFail,A.stencilZPass)),Ye(A.polygonOffset,A.polygonOffsetFactor,A.polygonOffsetUnits),A.alphaToCoverage===!0?X(32926):re(32926)}function Le(A){v!==A&&(A?a.frontFace(2304):a.frontFace(2305),v=A)}function ke(A){A!==0?(X(2884),A!==U&&(A===1?a.cullFace(1029):A===2?a.cullFace(1028):a.cullFace(1032))):re(2884),U=A}function $e(A){A!==q&&(I&&a.lineWidth(A),q=A)}function Ye(A,Q,k){A?(X(32823),(O!==Q||L!==k)&&(a.polygonOffset(Q,k),O=Q,L=k)):re(32823)}function S(A){A?X(3089):re(3089)}function y(A){A===void 0&&(A=33984+j-1),N!==A&&(a.activeTexture(A),N=A)}function W(A,Q){N===null&&y();let k=B[N];k===void 0&&(k={type:void 0,texture:void 0},B[N]=k),(k.type!==A||k.texture!==Q)&&(a.bindTexture(A,Q||H[A]),k.type=A,k.texture=Q)}function J(){const A=B[N];A!==void 0&&A.type!==void 0&&(a.bindTexture(A.type,null),A.type=void 0,A.texture=void 0)}function $(){try{a.compressedTexImage2D.apply(a,arguments)}catch(A){console.error("THREE.WebGLState:",A)}}function ie(){try{a.texImage2D.apply(a,arguments)}catch(A){console.error("THREE.WebGLState:",A)}}function pe(){try{a.texImage3D.apply(a,arguments)}catch(A){console.error("THREE.WebGLState:",A)}}function de(A){oe.equals(A)===!1&&(a.scissor(A.x,A.y,A.z,A.w),oe.copy(A))}function ge(A){te.equals(A)===!1&&(a.viewport(A.x,A.y,A.z,A.w),te.copy(A))}function se(){a.disable(3042),a.disable(2884),a.disable(2929),a.disable(32823),a.disable(3089),a.disable(2960),a.disable(32926),a.blendEquation(32774),a.blendFunc(1,0),a.blendFuncSeparate(1,0,1,0),a.colorMask(!0,!0,!0,!0),a.clearColor(0,0,0,0),a.depthMask(!0),a.depthFunc(513),a.clearDepth(1),a.stencilMask(4294967295),a.stencilFunc(519,0,4294967295),a.stencilOp(7680,7680,7680),a.clearStencil(0),a.cullFace(1029),a.frontFace(2305),a.polygonOffset(0,0),a.activeTexture(33984),a.bindFramebuffer(36160,null),i===!0&&(a.bindFramebuffer(36009,null),a.bindFramebuffer(36008,null)),a.useProgram(null),a.lineWidth(1),a.scissor(0,0,a.canvas.width,a.canvas.height),a.viewport(0,0,a.canvas.width,a.canvas.height),h={},N=null,B={},p=null,f={},m=null,_=!1,g=null,b=null,u=null,d=null,T=null,M=null,w=null,E=!1,v=null,U=null,q=null,O=null,L=null,oe.set(0,0,a.canvas.width,a.canvas.height),te.set(0,0,a.canvas.width,a.canvas.height),o.reset(),c.reset(),l.reset()}return{buffers:{color:o,depth:c,stencil:l},enable:X,disable:re,bindFramebuffer:me,bindXRFramebuffer:F,useProgram:_e,setBlending:be,setMaterial:he,setFlipSided:Le,setCullFace:ke,setLineWidth:$e,setPolygonOffset:Ye,setScissorTest:S,activeTexture:y,bindTexture:W,unbindTexture:J,compressedTexImage2D:$,texImage2D:ie,texImage3D:pe,scissor:de,viewport:ge,reset:se}}function Dc(a,e,t,i,n,r,s){const o=n.isWebGL2,c=n.maxTextures,l=n.maxCubemapSize,h=n.maxTextureSize,p=n.maxSamples,f=new WeakMap;let m,_=!1;try{_=typeof OffscreenCanvas!="undefined"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function g(S,y){return _?new OffscreenCanvas(S,y):wn("canvas")}function b(S,y,W,J){let $=1;if((S.width>J||S.height>J)&&($=J/Math.max(S.width,S.height)),$<1||y===!0)if(typeof HTMLImageElement!="undefined"&&S instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&S instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&S instanceof ImageBitmap){const ie=y?$r:Math.floor,pe=ie($*S.width),de=ie($*S.height);m===void 0&&(m=g(pe,de));const ge=W?g(pe,de):m;return ge.width=pe,ge.height=de,ge.getContext("2d").drawImage(S,0,0,pe,de),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+S.width+"x"+S.height+") to ("+pe+"x"+de+")."),ge}else return"data"in S&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+S.width+"x"+S.height+")."),S;return S}function u(S){return On(S.width)&&On(S.height)}function d(S){return o?!1:S.wrapS!==1001||S.wrapT!==1001||S.minFilter!==1003&&S.minFilter!==1006}function T(S,y){return S.generateMipmaps&&y&&S.minFilter!==1003&&S.minFilter!==1006}function M(S,y,W,J,$=1){a.generateMipmap(S);const ie=i.get(y);ie.__maxMipLevel=Math.log2(Math.max(W,J,$))}function w(S,y,W,J){if(o===!1)return y;if(S!==null){if(a[S]!==void 0)return a[S];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+S+"'")}let $=y;return y===6403&&(W===5126&&($=33326),W===5131&&($=33325),W===5121&&($=33321)),y===6407&&(W===5126&&($=34837),W===5131&&($=34843),W===5121&&($=32849)),y===6408&&(W===5126&&($=34836),W===5131&&($=34842),W===5121&&($=J===3001?35907:32856)),($===33325||$===33326||$===34842||$===34836)&&e.get("EXT_color_buffer_float"),$}function E(S){return S===1003||S===1004||S===1005?9728:9729}function v(S){const y=S.target;y.removeEventListener("dispose",v),q(y),y.isVideoTexture&&f.delete(y),s.memory.textures--}function U(S){const y=S.target;y.removeEventListener("dispose",U),O(y)}function q(S){const y=i.get(S);y.__webglInit!==void 0&&(a.deleteTexture(y.__webglTexture),i.remove(S))}function O(S){const y=S.texture,W=i.get(S),J=i.get(y);if(!!S){if(J.__webglTexture!==void 0&&(a.deleteTexture(J.__webglTexture),s.memory.textures--),S.depthTexture&&S.depthTexture.dispose(),S.isWebGLCubeRenderTarget)for(let $=0;$<6;$++)a.deleteFramebuffer(W.__webglFramebuffer[$]),W.__webglDepthbuffer&&a.deleteRenderbuffer(W.__webglDepthbuffer[$]);else a.deleteFramebuffer(W.__webglFramebuffer),W.__webglDepthbuffer&&a.deleteRenderbuffer(W.__webglDepthbuffer),W.__webglMultisampledFramebuffer&&a.deleteFramebuffer(W.__webglMultisampledFramebuffer),W.__webglColorRenderbuffer&&a.deleteRenderbuffer(W.__webglColorRenderbuffer),W.__webglDepthRenderbuffer&&a.deleteRenderbuffer(W.__webglDepthRenderbuffer);if(S.isWebGLMultipleRenderTargets)for(let $=0,ie=y.length;$<ie;$++){const pe=i.get(y[$]);pe.__webglTexture&&(a.deleteTexture(pe.__webglTexture),s.memory.textures--),i.remove(y[$])}i.remove(y),i.remove(S)}}let L=0;function j(){L=0}function I(){const S=L;return S>=c&&console.warn("THREE.WebGLTextures: Trying to use "+S+" texture units while this GPU supports only "+c),L+=1,S}function z(S,y){const W=i.get(S);if(S.isVideoTexture&&he(S),S.version>0&&W.__version!==S.version){const J=S.image;if(J===void 0)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else if(J.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{xe(W,S,y);return}}t.activeTexture(33984+y),t.bindTexture(3553,W.__webglTexture)}function G(S,y){const W=i.get(S);if(S.version>0&&W.__version!==S.version){xe(W,S,y);return}t.activeTexture(33984+y),t.bindTexture(35866,W.__webglTexture)}function N(S,y){const W=i.get(S);if(S.version>0&&W.__version!==S.version){xe(W,S,y);return}t.activeTexture(33984+y),t.bindTexture(32879,W.__webglTexture)}function B(S,y){const W=i.get(S);if(S.version>0&&W.__version!==S.version){H(W,S,y);return}t.activeTexture(33984+y),t.bindTexture(34067,W.__webglTexture)}const Y={[1e3]:10497,[1001]:33071,[1002]:33648},ne={[1003]:9728,[1004]:9984,[1005]:9986,[1006]:9729,[1007]:9985,[1008]:9987};function oe(S,y,W){if(W?(a.texParameteri(S,10242,Y[y.wrapS]),a.texParameteri(S,10243,Y[y.wrapT]),(S===32879||S===35866)&&a.texParameteri(S,32882,Y[y.wrapR]),a.texParameteri(S,10240,ne[y.magFilter]),a.texParameteri(S,10241,ne[y.minFilter])):(a.texParameteri(S,10242,33071),a.texParameteri(S,10243,33071),(S===32879||S===35866)&&a.texParameteri(S,32882,33071),(y.wrapS!==1001||y.wrapT!==1001)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),a.texParameteri(S,10240,E(y.magFilter)),a.texParameteri(S,10241,E(y.minFilter)),y.minFilter!==1003&&y.minFilter!==1006&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),e.has("EXT_texture_filter_anisotropic")===!0){const J=e.get("EXT_texture_filter_anisotropic");if(y.type===1015&&e.has("OES_texture_float_linear")===!1||o===!1&&y.type===1016&&e.has("OES_texture_half_float_linear")===!1)return;(y.anisotropy>1||i.get(y).__currentAnisotropy)&&(a.texParameterf(S,J.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(y.anisotropy,n.getMaxAnisotropy())),i.get(y).__currentAnisotropy=y.anisotropy)}}function te(S,y){S.__webglInit===void 0&&(S.__webglInit=!0,y.addEventListener("dispose",v),S.__webglTexture=a.createTexture(),s.memory.textures++)}function xe(S,y,W){let J=3553;y.isDataTexture2DArray&&(J=35866),y.isDataTexture3D&&(J=32879),te(S,y),t.activeTexture(33984+W),t.bindTexture(J,S.__webglTexture),a.pixelStorei(37440,y.flipY),a.pixelStorei(37441,y.premultiplyAlpha),a.pixelStorei(3317,y.unpackAlignment),a.pixelStorei(37443,0);const $=d(y)&&u(y.image)===!1,ie=b(y.image,$,!1,h),pe=u(ie)||o,de=r.convert(y.format);let ge=r.convert(y.type),se=w(y.internalFormat,de,ge,y.encoding);oe(J,y,pe);let A;const Q=y.mipmaps;if(y.isDepthTexture)se=6402,o?y.type===1015?se=36012:y.type===1014?se=33190:y.type===1020?se=35056:se=33189:y.type===1015&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),y.format===1026&&se===6402&&y.type!==1012&&y.type!==1014&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),y.type=1012,ge=r.convert(y.type)),y.format===1027&&se===6402&&(se=34041,y.type!==1020&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),y.type=1020,ge=r.convert(y.type))),t.texImage2D(3553,0,se,ie.width,ie.height,0,de,ge,null);else if(y.isDataTexture)if(Q.length>0&&pe){for(let k=0,ee=Q.length;k<ee;k++)A=Q[k],t.texImage2D(3553,k,se,A.width,A.height,0,de,ge,A.data);y.generateMipmaps=!1,S.__maxMipLevel=Q.length-1}else t.texImage2D(3553,0,se,ie.width,ie.height,0,de,ge,ie.data),S.__maxMipLevel=0;else if(y.isCompressedTexture){for(let k=0,ee=Q.length;k<ee;k++)A=Q[k],y.format!==1023&&y.format!==1022?de!==null?t.compressedTexImage2D(3553,k,se,A.width,A.height,0,A.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):t.texImage2D(3553,k,se,A.width,A.height,0,de,ge,A.data);S.__maxMipLevel=Q.length-1}else if(y.isDataTexture2DArray)t.texImage3D(35866,0,se,ie.width,ie.height,ie.depth,0,de,ge,ie.data),S.__maxMipLevel=0;else if(y.isDataTexture3D)t.texImage3D(32879,0,se,ie.width,ie.height,ie.depth,0,de,ge,ie.data),S.__maxMipLevel=0;else if(Q.length>0&&pe){for(let k=0,ee=Q.length;k<ee;k++)A=Q[k],t.texImage2D(3553,k,se,de,ge,A);y.generateMipmaps=!1,S.__maxMipLevel=Q.length-1}else t.texImage2D(3553,0,se,de,ge,ie),S.__maxMipLevel=0;T(y,pe)&&M(J,y,ie.width,ie.height),S.__version=y.version,y.onUpdate&&y.onUpdate(y)}function H(S,y,W){if(y.image.length!==6)return;te(S,y),t.activeTexture(33984+W),t.bindTexture(34067,S.__webglTexture),a.pixelStorei(37440,y.flipY),a.pixelStorei(37441,y.premultiplyAlpha),a.pixelStorei(3317,y.unpackAlignment),a.pixelStorei(37443,0);const J=y&&(y.isCompressedTexture||y.image[0].isCompressedTexture),$=y.image[0]&&y.image[0].isDataTexture,ie=[];for(let k=0;k<6;k++)!J&&!$?ie[k]=b(y.image[k],!1,!0,l):ie[k]=$?y.image[k].image:y.image[k];const pe=ie[0],de=u(pe)||o,ge=r.convert(y.format),se=r.convert(y.type),A=w(y.internalFormat,ge,se,y.encoding);oe(34067,y,de);let Q;if(J){for(let k=0;k<6;k++){Q=ie[k].mipmaps;for(let ee=0;ee<Q.length;ee++){const ae=Q[ee];y.format!==1023&&y.format!==1022?ge!==null?t.compressedTexImage2D(34069+k,ee,A,ae.width,ae.height,0,ae.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):t.texImage2D(34069+k,ee,A,ae.width,ae.height,0,ge,se,ae.data)}}S.__maxMipLevel=Q.length-1}else{Q=y.mipmaps;for(let k=0;k<6;k++)if($){t.texImage2D(34069+k,0,A,ie[k].width,ie[k].height,0,ge,se,ie[k].data);for(let ee=0;ee<Q.length;ee++){const ye=Q[ee].image[k].image;t.texImage2D(34069+k,ee+1,A,ye.width,ye.height,0,ge,se,ye.data)}}else{t.texImage2D(34069+k,0,A,ge,se,ie[k]);for(let ee=0;ee<Q.length;ee++){const ae=Q[ee];t.texImage2D(34069+k,ee+1,A,ge,se,ae.image[k])}}S.__maxMipLevel=Q.length}T(y,de)&&M(34067,y,pe.width,pe.height),S.__version=y.version,y.onUpdate&&y.onUpdate(y)}function X(S,y,W,J,$){const ie=r.convert(W.format),pe=r.convert(W.type),de=w(W.internalFormat,ie,pe,W.encoding);$===32879||$===35866?t.texImage3D($,0,de,y.width,y.height,y.depth,0,ie,pe,null):t.texImage2D($,0,de,y.width,y.height,0,ie,pe,null),t.bindFramebuffer(36160,S),a.framebufferTexture2D(36160,J,$,i.get(W).__webglTexture,0),t.bindFramebuffer(36160,null)}function re(S,y,W){if(a.bindRenderbuffer(36161,S),y.depthBuffer&&!y.stencilBuffer){let J=33189;if(W){const $=y.depthTexture;$&&$.isDepthTexture&&($.type===1015?J=36012:$.type===1014&&(J=33190));const ie=be(y);a.renderbufferStorageMultisample(36161,ie,J,y.width,y.height)}else a.renderbufferStorage(36161,J,y.width,y.height);a.framebufferRenderbuffer(36160,36096,36161,S)}else if(y.depthBuffer&&y.stencilBuffer){if(W){const J=be(y);a.renderbufferStorageMultisample(36161,J,35056,y.width,y.height)}else a.renderbufferStorage(36161,34041,y.width,y.height);a.framebufferRenderbuffer(36160,33306,36161,S)}else{const J=y.isWebGLMultipleRenderTargets===!0?y.texture[0]:y.texture,$=r.convert(J.format),ie=r.convert(J.type),pe=w(J.internalFormat,$,ie,J.encoding);if(W){const de=be(y);a.renderbufferStorageMultisample(36161,de,pe,y.width,y.height)}else a.renderbufferStorage(36161,pe,y.width,y.height)}a.bindRenderbuffer(36161,null)}function F(S,y){if(y&&y.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(36160,S),!(y.depthTexture&&y.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!i.get(y.depthTexture).__webglTexture||y.depthTexture.image.width!==y.width||y.depthTexture.image.height!==y.height)&&(y.depthTexture.image.width=y.width,y.depthTexture.image.height=y.height,y.depthTexture.needsUpdate=!0),z(y.depthTexture,0);const J=i.get(y.depthTexture).__webglTexture;if(y.depthTexture.format===1026)a.framebufferTexture2D(36160,36096,3553,J,0);else if(y.depthTexture.format===1027)a.framebufferTexture2D(36160,33306,3553,J,0);else throw new Error("Unknown depthTexture format")}function me(S){const y=i.get(S),W=S.isWebGLCubeRenderTarget===!0;if(S.depthTexture){if(W)throw new Error("target.depthTexture not supported in Cube render targets");F(y.__webglFramebuffer,S)}else if(W){y.__webglDepthbuffer=[];for(let J=0;J<6;J++)t.bindFramebuffer(36160,y.__webglFramebuffer[J]),y.__webglDepthbuffer[J]=a.createRenderbuffer(),re(y.__webglDepthbuffer[J],S,!1)}else t.bindFramebuffer(36160,y.__webglFramebuffer),y.__webglDepthbuffer=a.createRenderbuffer(),re(y.__webglDepthbuffer,S,!1);t.bindFramebuffer(36160,null)}function _e(S){const y=S.texture,W=i.get(S),J=i.get(y);S.addEventListener("dispose",U),S.isWebGLMultipleRenderTargets!==!0&&(J.__webglTexture=a.createTexture(),J.__version=y.version,s.memory.textures++);const $=S.isWebGLCubeRenderTarget===!0,ie=S.isWebGLMultipleRenderTargets===!0,pe=S.isWebGLMultisampleRenderTarget===!0,de=y.isDataTexture3D||y.isDataTexture2DArray,ge=u(S)||o;if(o&&y.format===1022&&(y.type===1015||y.type===1016)&&(y.format=1023,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),$){W.__webglFramebuffer=[];for(let se=0;se<6;se++)W.__webglFramebuffer[se]=a.createFramebuffer()}else if(W.__webglFramebuffer=a.createFramebuffer(),ie)if(n.drawBuffers){const se=S.texture;for(let A=0,Q=se.length;A<Q;A++){const k=i.get(se[A]);k.__webglTexture===void 0&&(k.__webglTexture=a.createTexture(),s.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");else if(pe)if(o){W.__webglMultisampledFramebuffer=a.createFramebuffer(),W.__webglColorRenderbuffer=a.createRenderbuffer(),a.bindRenderbuffer(36161,W.__webglColorRenderbuffer);const se=r.convert(y.format),A=r.convert(y.type),Q=w(y.internalFormat,se,A,y.encoding),k=be(S);a.renderbufferStorageMultisample(36161,k,Q,S.width,S.height),t.bindFramebuffer(36160,W.__webglMultisampledFramebuffer),a.framebufferRenderbuffer(36160,36064,36161,W.__webglColorRenderbuffer),a.bindRenderbuffer(36161,null),S.depthBuffer&&(W.__webglDepthRenderbuffer=a.createRenderbuffer(),re(W.__webglDepthRenderbuffer,S,!0)),t.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if($){t.bindTexture(34067,J.__webglTexture),oe(34067,y,ge);for(let se=0;se<6;se++)X(W.__webglFramebuffer[se],S,y,36064,34069+se);T(y,ge)&&M(34067,y,S.width,S.height),t.unbindTexture()}else if(ie){const se=S.texture;for(let A=0,Q=se.length;A<Q;A++){const k=se[A],ee=i.get(k);t.bindTexture(3553,ee.__webglTexture),oe(3553,k,ge),X(W.__webglFramebuffer,S,k,36064+A,3553),T(k,ge)&&M(3553,k,S.width,S.height)}t.unbindTexture()}else{let se=3553;de&&(o?se=y.isDataTexture3D?32879:35866:console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")),t.bindTexture(se,J.__webglTexture),oe(se,y,ge),X(W.__webglFramebuffer,S,y,36064,se),T(y,ge)&&M(se,y,S.width,S.height,S.depth),t.unbindTexture()}S.depthBuffer&&me(S)}function K(S){const y=u(S)||o,W=S.isWebGLMultipleRenderTargets===!0?S.texture:[S.texture];for(let J=0,$=W.length;J<$;J++){const ie=W[J];if(T(ie,y)){const pe=S.isWebGLCubeRenderTarget?34067:3553,de=i.get(ie).__webglTexture;t.bindTexture(pe,de),M(pe,ie,S.width,S.height),t.unbindTexture()}}}function ue(S){if(S.isWebGLMultisampleRenderTarget)if(o){const y=S.width,W=S.height;let J=16384;S.depthBuffer&&(J|=256),S.stencilBuffer&&(J|=1024);const $=i.get(S);t.bindFramebuffer(36008,$.__webglMultisampledFramebuffer),t.bindFramebuffer(36009,$.__webglFramebuffer),a.blitFramebuffer(0,0,y,W,0,0,y,W,J,9728),t.bindFramebuffer(36008,null),t.bindFramebuffer(36009,$.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}function be(S){return o&&S.isWebGLMultisampleRenderTarget?Math.min(p,S.samples):0}function he(S){const y=s.render.frame;f.get(S)!==y&&(f.set(S,y),S.update())}let Le=!1,ke=!1;function $e(S,y){S&&S.isWebGLRenderTarget&&(Le===!1&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),Le=!0),S=S.texture),z(S,y)}function Ye(S,y){S&&S.isWebGLCubeRenderTarget&&(ke===!1&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),ke=!0),S=S.texture),B(S,y)}this.allocateTextureUnit=I,this.resetTextureUnits=j,this.setTexture2D=z,this.setTexture2DArray=G,this.setTexture3D=N,this.setTextureCube=B,this.setupRenderTarget=_e,this.updateRenderTargetMipmap=K,this.updateMultisampleRenderTarget=ue,this.safeSetTexture2D=$e,this.safeSetTextureCube=Ye}function Pc(a,e,t){const i=t.isWebGL2;function n(r){let s;if(r===1009)return 5121;if(r===1017)return 32819;if(r===1018)return 32820;if(r===1019)return 33635;if(r===1010)return 5120;if(r===1011)return 5122;if(r===1012)return 5123;if(r===1013)return 5124;if(r===1014)return 5125;if(r===1015)return 5126;if(r===1016)return i?5131:(s=e.get("OES_texture_half_float"),s!==null?s.HALF_FLOAT_OES:null);if(r===1021)return 6406;if(r===1022)return 6407;if(r===1023)return 6408;if(r===1024)return 6409;if(r===1025)return 6410;if(r===1026)return 6402;if(r===1027)return 34041;if(r===1028)return 6403;if(r===1029)return 36244;if(r===1030)return 33319;if(r===1031)return 33320;if(r===1032)return 36248;if(r===1033)return 36249;if(r===33776||r===33777||r===33778||r===33779)if(s=e.get("WEBGL_compressed_texture_s3tc"),s!==null){if(r===33776)return s.COMPRESSED_RGB_S3TC_DXT1_EXT;if(r===33777)return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(r===33778)return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(r===33779)return s.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(r===35840||r===35841||r===35842||r===35843)if(s=e.get("WEBGL_compressed_texture_pvrtc"),s!==null){if(r===35840)return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(r===35841)return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(r===35842)return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(r===35843)return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(r===36196)return s=e.get("WEBGL_compressed_texture_etc1"),s!==null?s.COMPRESSED_RGB_ETC1_WEBGL:null;if((r===37492||r===37496)&&(s=e.get("WEBGL_compressed_texture_etc"),s!==null)){if(r===37492)return s.COMPRESSED_RGB8_ETC2;if(r===37496)return s.COMPRESSED_RGBA8_ETC2_EAC}if(r===37808||r===37809||r===37810||r===37811||r===37812||r===37813||r===37814||r===37815||r===37816||r===37817||r===37818||r===37819||r===37820||r===37821||r===37840||r===37841||r===37842||r===37843||r===37844||r===37845||r===37846||r===37847||r===37848||r===37849||r===37850||r===37851||r===37852||r===37853)return s=e.get("WEBGL_compressed_texture_astc"),s!==null?r:null;if(r===36492)return s=e.get("EXT_texture_compression_bptc"),s!==null?r:null;if(r===1020)return i?34042:(s=e.get("WEBGL_depth_texture"),s!==null?s.UNSIGNED_INT_24_8_WEBGL:null)}return{convert:n}}class Vr extends it{constructor(e=[]){super(),this.cameras=e}}Vr.prototype.isArrayCamera=!0;class Mi extends Je{constructor(){super(),this.type="Group"}}Mi.prototype.isGroup=!0;const Fc={type:"move"};class Sn{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Mi,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Mi,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new C,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new C),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Mi,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new C,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new C),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,i){let n=null,r=null,s=null;const o=this._targetRay,c=this._grip,l=this._hand;if(e&&t.session.visibilityState!=="visible-blurred")if(o!==null&&(n=t.getPose(e.targetRaySpace,i),n!==null&&(o.matrix.fromArray(n.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),n.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(n.linearVelocity)):o.hasLinearVelocity=!1,n.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(n.angularVelocity)):o.hasAngularVelocity=!1,this.dispatchEvent(Fc))),l&&e.hand){s=!0;for(const g of e.hand.values()){const b=t.getJointPose(g,i);if(l.joints[g.jointName]===void 0){const d=new Mi;d.matrixAutoUpdate=!1,d.visible=!1,l.joints[g.jointName]=d,l.add(d)}const u=l.joints[g.jointName];b!==null&&(u.matrix.fromArray(b.transform.matrix),u.matrix.decompose(u.position,u.rotation,u.scale),u.jointRadius=b.radius),u.visible=b!==null}const h=l.joints["index-finger-tip"],p=l.joints["thumb-tip"],f=h.position.distanceTo(p.position),m=.02,_=.005;l.inputState.pinching&&f>m+_?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!l.inputState.pinching&&f<=m-_&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else c!==null&&e.gripSpace&&(r=t.getPose(e.gripSpace,i),r!==null&&(c.matrix.fromArray(r.transform.matrix),c.matrix.decompose(c.position,c.rotation,c.scale),r.linearVelocity?(c.hasLinearVelocity=!0,c.linearVelocity.copy(r.linearVelocity)):c.hasLinearVelocity=!1,r.angularVelocity?(c.hasAngularVelocity=!0,c.angularVelocity.copy(r.angularVelocity)):c.hasAngularVelocity=!1));return o!==null&&(o.visible=n!==null),c!==null&&(c.visible=r!==null),l!==null&&(l.visible=s!==null),this}}class Ic extends si{constructor(e,t){super();const i=this,n=e.state;let r=null,s=1,o=null,c="local-floor",l=null,h=null,p=null,f=null,m=null,_=!1,g=null,b=null,u=null,d=null,T=null,M=null;const w=[],E=new Map,v=new it;v.layers.enable(1),v.viewport=new We;const U=new it;U.layers.enable(2),U.viewport=new We;const q=[v,U],O=new Vr;O.layers.enable(1),O.layers.enable(2);let L=null,j=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(H){let X=w[H];return X===void 0&&(X=new Sn,w[H]=X),X.getTargetRaySpace()},this.getControllerGrip=function(H){let X=w[H];return X===void 0&&(X=new Sn,w[H]=X),X.getGripSpace()},this.getHand=function(H){let X=w[H];return X===void 0&&(X=new Sn,w[H]=X),X.getHandSpace()};function I(H){const X=E.get(H.inputSource);X&&X.dispatchEvent({type:H.type,data:H.inputSource})}function z(){E.forEach(function(H,X){H.disconnect(X)}),E.clear(),L=null,j=null,n.bindXRFramebuffer(null),e.setRenderTarget(e.getRenderTarget()),p&&t.deleteFramebuffer(p),g&&t.deleteFramebuffer(g),b&&t.deleteRenderbuffer(b),u&&t.deleteRenderbuffer(u),p=null,g=null,b=null,u=null,m=null,f=null,h=null,r=null,xe.stop(),i.isPresenting=!1,i.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(H){s=H,i.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(H){c=H,i.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return o},this.getBaseLayer=function(){return f!==null?f:m},this.getBinding=function(){return h},this.getFrame=function(){return d},this.getSession=function(){return r},this.setSession=async function(H){if(r=H,r!==null){r.addEventListener("select",I),r.addEventListener("selectstart",I),r.addEventListener("selectend",I),r.addEventListener("squeeze",I),r.addEventListener("squeezestart",I),r.addEventListener("squeezeend",I),r.addEventListener("end",z),r.addEventListener("inputsourceschange",G);const X=t.getContextAttributes();if(X.xrCompatible!==!0&&await t.makeXRCompatible(),r.renderState.layers===void 0){const re={antialias:X.antialias,alpha:X.alpha,depth:X.depth,stencil:X.stencil,framebufferScaleFactor:s};m=new XRWebGLLayer(r,t,re),r.updateRenderState({baseLayer:m})}else if(t instanceof WebGLRenderingContext){const re={antialias:!0,alpha:X.alpha,depth:X.depth,stencil:X.stencil,framebufferScaleFactor:s};m=new XRWebGLLayer(r,t,re),r.updateRenderState({layers:[m]})}else{_=X.antialias;let re=null;X.depth&&(M=256,X.stencil&&(M|=1024),T=X.stencil?33306:36096,re=X.stencil?35056:33190);const F={colorFormat:X.alpha?32856:32849,depthFormat:re,scaleFactor:s};h=new XRWebGLBinding(r,t),f=h.createProjectionLayer(F),p=t.createFramebuffer(),r.updateRenderState({layers:[f]}),_&&(g=t.createFramebuffer(),b=t.createRenderbuffer(),t.bindRenderbuffer(36161,b),t.renderbufferStorageMultisample(36161,4,32856,f.textureWidth,f.textureHeight),n.bindFramebuffer(36160,g),t.framebufferRenderbuffer(36160,36064,36161,b),t.bindRenderbuffer(36161,null),re!==null&&(u=t.createRenderbuffer(),t.bindRenderbuffer(36161,u),t.renderbufferStorageMultisample(36161,4,re,f.textureWidth,f.textureHeight),t.framebufferRenderbuffer(36160,T,36161,u),t.bindRenderbuffer(36161,null)),n.bindFramebuffer(36160,null))}o=await r.requestReferenceSpace(c),xe.setContext(r),xe.start(),i.isPresenting=!0,i.dispatchEvent({type:"sessionstart"})}};function G(H){const X=r.inputSources;for(let re=0;re<w.length;re++)E.set(X[re],w[re]);for(let re=0;re<H.removed.length;re++){const F=H.removed[re],me=E.get(F);me&&(me.dispatchEvent({type:"disconnected",data:F}),E.delete(F))}for(let re=0;re<H.added.length;re++){const F=H.added[re],me=E.get(F);me&&me.dispatchEvent({type:"connected",data:F})}}const N=new C,B=new C;function Y(H,X,re){N.setFromMatrixPosition(X.matrixWorld),B.setFromMatrixPosition(re.matrixWorld);const F=N.distanceTo(B),me=X.projectionMatrix.elements,_e=re.projectionMatrix.elements,K=me[14]/(me[10]-1),ue=me[14]/(me[10]+1),be=(me[9]+1)/me[5],he=(me[9]-1)/me[5],Le=(me[8]-1)/me[0],ke=(_e[8]+1)/_e[0],$e=K*Le,Ye=K*ke,S=F/(-Le+ke),y=S*-Le;X.matrixWorld.decompose(H.position,H.quaternion,H.scale),H.translateX(y),H.translateZ(S),H.matrixWorld.compose(H.position,H.quaternion,H.scale),H.matrixWorldInverse.copy(H.matrixWorld).invert();const W=K+S,J=ue+S,$=$e-y,ie=Ye+(F-y),pe=be*ue/J*W,de=he*ue/J*W;H.projectionMatrix.makePerspective($,ie,pe,de,W,J)}function ne(H,X){X===null?H.matrixWorld.copy(H.matrix):H.matrixWorld.multiplyMatrices(X.matrixWorld,H.matrix),H.matrixWorldInverse.copy(H.matrixWorld).invert()}this.updateCamera=function(H){if(r===null)return;O.near=U.near=v.near=H.near,O.far=U.far=v.far=H.far,(L!==O.near||j!==O.far)&&(r.updateRenderState({depthNear:O.near,depthFar:O.far}),L=O.near,j=O.far);const X=H.parent,re=O.cameras;ne(O,X);for(let me=0;me<re.length;me++)ne(re[me],X);O.matrixWorld.decompose(O.position,O.quaternion,O.scale),H.position.copy(O.position),H.quaternion.copy(O.quaternion),H.scale.copy(O.scale),H.matrix.copy(O.matrix),H.matrixWorld.copy(O.matrixWorld);const F=H.children;for(let me=0,_e=F.length;me<_e;me++)F[me].updateMatrixWorld(!0);re.length===2?Y(O,v,U):O.projectionMatrix.copy(v.projectionMatrix)},this.getCamera=function(){return O},this.getFoveation=function(){if(f!==null)return f.fixedFoveation;if(m!==null)return m.fixedFoveation},this.setFoveation=function(H){f!==null&&(f.fixedFoveation=H),m!==null&&m.fixedFoveation!==void 0&&(m.fixedFoveation=H)};let oe=null;function te(H,X){if(l=X.getViewerPose(o),d=X,l!==null){const F=l.views;m!==null&&n.bindXRFramebuffer(m.framebuffer);let me=!1;F.length!==O.cameras.length&&(O.cameras.length=0,me=!0);for(let _e=0;_e<F.length;_e++){const K=F[_e];let ue=null;if(m!==null)ue=m.getViewport(K);else{const he=h.getViewSubImage(f,K);n.bindXRFramebuffer(p),he.depthStencilTexture!==void 0&&t.framebufferTexture2D(36160,T,3553,he.depthStencilTexture,0),t.framebufferTexture2D(36160,36064,3553,he.colorTexture,0),ue=he.viewport}const be=q[_e];be.matrix.fromArray(K.transform.matrix),be.projectionMatrix.fromArray(K.projectionMatrix),be.viewport.set(ue.x,ue.y,ue.width,ue.height),_e===0&&O.matrix.copy(be.matrix),me===!0&&O.cameras.push(be)}_&&(n.bindXRFramebuffer(g),M!==null&&t.clear(M))}const re=r.inputSources;for(let F=0;F<w.length;F++){const me=w[F],_e=re[F];me.update(_e,X,o)}if(oe&&oe(H,X),_){const F=f.textureWidth,me=f.textureHeight;n.bindFramebuffer(36008,g),n.bindFramebuffer(36009,p),t.invalidateFramebuffer(36008,[T]),t.invalidateFramebuffer(36009,[T]),t.blitFramebuffer(0,0,F,me,0,0,F,me,16384,9728),t.invalidateFramebuffer(36008,[36064]),n.bindFramebuffer(36008,null),n.bindFramebuffer(36009,null),n.bindFramebuffer(36160,g)}d=null}const xe=new Er;xe.setAnimationLoop(te),this.setAnimationLoop=function(H){oe=H},this.dispose=function(){}}}function Nc(a){function e(u,d){u.fogColor.value.copy(d.color),d.isFog?(u.fogNear.value=d.near,u.fogFar.value=d.far):d.isFogExp2&&(u.fogDensity.value=d.density)}function t(u,d,T,M,w){d.isMeshBasicMaterial?i(u,d):d.isMeshLambertMaterial?(i(u,d),c(u,d)):d.isMeshToonMaterial?(i(u,d),h(u,d)):d.isMeshPhongMaterial?(i(u,d),l(u,d)):d.isMeshStandardMaterial?(i(u,d),d.isMeshPhysicalMaterial?f(u,d,w):p(u,d)):d.isMeshMatcapMaterial?(i(u,d),m(u,d)):d.isMeshDepthMaterial?(i(u,d),_(u,d)):d.isMeshDistanceMaterial?(i(u,d),g(u,d)):d.isMeshNormalMaterial?(i(u,d),b(u,d)):d.isLineBasicMaterial?(n(u,d),d.isLineDashedMaterial&&r(u,d)):d.isPointsMaterial?s(u,d,T,M):d.isSpriteMaterial?o(u,d):d.isShadowMaterial?(u.color.value.copy(d.color),u.opacity.value=d.opacity):d.isShaderMaterial&&(d.uniformsNeedUpdate=!1)}function i(u,d){u.opacity.value=d.opacity,d.color&&u.diffuse.value.copy(d.color),d.emissive&&u.emissive.value.copy(d.emissive).multiplyScalar(d.emissiveIntensity),d.map&&(u.map.value=d.map),d.alphaMap&&(u.alphaMap.value=d.alphaMap),d.specularMap&&(u.specularMap.value=d.specularMap),d.alphaTest>0&&(u.alphaTest.value=d.alphaTest);const T=a.get(d).envMap;if(T){u.envMap.value=T,u.flipEnvMap.value=T.isCubeTexture&&T.isRenderTargetTexture===!1?-1:1,u.reflectivity.value=d.reflectivity,u.ior.value=d.ior,u.refractionRatio.value=d.refractionRatio;const E=a.get(T).__maxMipLevel;E!==void 0&&(u.maxMipLevel.value=E)}d.lightMap&&(u.lightMap.value=d.lightMap,u.lightMapIntensity.value=d.lightMapIntensity),d.aoMap&&(u.aoMap.value=d.aoMap,u.aoMapIntensity.value=d.aoMapIntensity);let M;d.map?M=d.map:d.specularMap?M=d.specularMap:d.displacementMap?M=d.displacementMap:d.normalMap?M=d.normalMap:d.bumpMap?M=d.bumpMap:d.roughnessMap?M=d.roughnessMap:d.metalnessMap?M=d.metalnessMap:d.alphaMap?M=d.alphaMap:d.emissiveMap?M=d.emissiveMap:d.clearcoatMap?M=d.clearcoatMap:d.clearcoatNormalMap?M=d.clearcoatNormalMap:d.clearcoatRoughnessMap?M=d.clearcoatRoughnessMap:d.specularIntensityMap?M=d.specularIntensityMap:d.specularTintMap?M=d.specularTintMap:d.transmissionMap?M=d.transmissionMap:d.thicknessMap&&(M=d.thicknessMap),M!==void 0&&(M.isWebGLRenderTarget&&(M=M.texture),M.matrixAutoUpdate===!0&&M.updateMatrix(),u.uvTransform.value.copy(M.matrix));let w;d.aoMap?w=d.aoMap:d.lightMap&&(w=d.lightMap),w!==void 0&&(w.isWebGLRenderTarget&&(w=w.texture),w.matrixAutoUpdate===!0&&w.updateMatrix(),u.uv2Transform.value.copy(w.matrix))}function n(u,d){u.diffuse.value.copy(d.color),u.opacity.value=d.opacity}function r(u,d){u.dashSize.value=d.dashSize,u.totalSize.value=d.dashSize+d.gapSize,u.scale.value=d.scale}function s(u,d,T,M){u.diffuse.value.copy(d.color),u.opacity.value=d.opacity,u.size.value=d.size*T,u.scale.value=M*.5,d.map&&(u.map.value=d.map),d.alphaMap&&(u.alphaMap.value=d.alphaMap),d.alphaTest>0&&(u.alphaTest.value=d.alphaTest);let w;d.map?w=d.map:d.alphaMap&&(w=d.alphaMap),w!==void 0&&(w.matrixAutoUpdate===!0&&w.updateMatrix(),u.uvTransform.value.copy(w.matrix))}function o(u,d){u.diffuse.value.copy(d.color),u.opacity.value=d.opacity,u.rotation.value=d.rotation,d.map&&(u.map.value=d.map),d.alphaMap&&(u.alphaMap.value=d.alphaMap),d.alphaTest>0&&(u.alphaTest.value=d.alphaTest);let T;d.map?T=d.map:d.alphaMap&&(T=d.alphaMap),T!==void 0&&(T.matrixAutoUpdate===!0&&T.updateMatrix(),u.uvTransform.value.copy(T.matrix))}function c(u,d){d.emissiveMap&&(u.emissiveMap.value=d.emissiveMap)}function l(u,d){u.specular.value.copy(d.specular),u.shininess.value=Math.max(d.shininess,1e-4),d.emissiveMap&&(u.emissiveMap.value=d.emissiveMap),d.bumpMap&&(u.bumpMap.value=d.bumpMap,u.bumpScale.value=d.bumpScale,d.side===1&&(u.bumpScale.value*=-1)),d.normalMap&&(u.normalMap.value=d.normalMap,u.normalScale.value.copy(d.normalScale),d.side===1&&u.normalScale.value.negate()),d.displacementMap&&(u.displacementMap.value=d.displacementMap,u.displacementScale.value=d.displacementScale,u.displacementBias.value=d.displacementBias)}function h(u,d){d.gradientMap&&(u.gradientMap.value=d.gradientMap),d.emissiveMap&&(u.emissiveMap.value=d.emissiveMap),d.bumpMap&&(u.bumpMap.value=d.bumpMap,u.bumpScale.value=d.bumpScale,d.side===1&&(u.bumpScale.value*=-1)),d.normalMap&&(u.normalMap.value=d.normalMap,u.normalScale.value.copy(d.normalScale),d.side===1&&u.normalScale.value.negate()),d.displacementMap&&(u.displacementMap.value=d.displacementMap,u.displacementScale.value=d.displacementScale,u.displacementBias.value=d.displacementBias)}function p(u,d){u.roughness.value=d.roughness,u.metalness.value=d.metalness,d.roughnessMap&&(u.roughnessMap.value=d.roughnessMap),d.metalnessMap&&(u.metalnessMap.value=d.metalnessMap),d.emissiveMap&&(u.emissiveMap.value=d.emissiveMap),d.bumpMap&&(u.bumpMap.value=d.bumpMap,u.bumpScale.value=d.bumpScale,d.side===1&&(u.bumpScale.value*=-1)),d.normalMap&&(u.normalMap.value=d.normalMap,u.normalScale.value.copy(d.normalScale),d.side===1&&u.normalScale.value.negate()),d.displacementMap&&(u.displacementMap.value=d.displacementMap,u.displacementScale.value=d.displacementScale,u.displacementBias.value=d.displacementBias),a.get(d).envMap&&(u.envMapIntensity.value=d.envMapIntensity)}function f(u,d,T){p(u,d),u.ior.value=d.ior,d.sheen>0&&(u.sheenTint.value.copy(d.sheenTint).multiplyScalar(d.sheen),u.sheenRoughness.value=d.sheenRoughness),d.clearcoat>0&&(u.clearcoat.value=d.clearcoat,u.clearcoatRoughness.value=d.clearcoatRoughness,d.clearcoatMap&&(u.clearcoatMap.value=d.clearcoatMap),d.clearcoatRoughnessMap&&(u.clearcoatRoughnessMap.value=d.clearcoatRoughnessMap),d.clearcoatNormalMap&&(u.clearcoatNormalScale.value.copy(d.clearcoatNormalScale),u.clearcoatNormalMap.value=d.clearcoatNormalMap,d.side===1&&u.clearcoatNormalScale.value.negate())),d.transmission>0&&(u.transmission.value=d.transmission,u.transmissionSamplerMap.value=T.texture,u.transmissionSamplerSize.value.set(T.width,T.height),d.transmissionMap&&(u.transmissionMap.value=d.transmissionMap),u.thickness.value=d.thickness,d.thicknessMap&&(u.thicknessMap.value=d.thicknessMap),u.attenuationDistance.value=d.attenuationDistance,u.attenuationTint.value.copy(d.attenuationTint)),u.specularIntensity.value=d.specularIntensity,u.specularTint.value.copy(d.specularTint),d.specularIntensityMap&&(u.specularIntensityMap.value=d.specularIntensityMap),d.specularTintMap&&(u.specularTintMap.value=d.specularTintMap)}function m(u,d){d.matcap&&(u.matcap.value=d.matcap),d.bumpMap&&(u.bumpMap.value=d.bumpMap,u.bumpScale.value=d.bumpScale,d.side===1&&(u.bumpScale.value*=-1)),d.normalMap&&(u.normalMap.value=d.normalMap,u.normalScale.value.copy(d.normalScale),d.side===1&&u.normalScale.value.negate()),d.displacementMap&&(u.displacementMap.value=d.displacementMap,u.displacementScale.value=d.displacementScale,u.displacementBias.value=d.displacementBias)}function _(u,d){d.displacementMap&&(u.displacementMap.value=d.displacementMap,u.displacementScale.value=d.displacementScale,u.displacementBias.value=d.displacementBias)}function g(u,d){d.displacementMap&&(u.displacementMap.value=d.displacementMap,u.displacementScale.value=d.displacementScale,u.displacementBias.value=d.displacementBias),u.referencePosition.value.copy(d.referencePosition),u.nearDistance.value=d.nearDistance,u.farDistance.value=d.farDistance}function b(u,d){d.bumpMap&&(u.bumpMap.value=d.bumpMap,u.bumpScale.value=d.bumpScale,d.side===1&&(u.bumpScale.value*=-1)),d.normalMap&&(u.normalMap.value=d.normalMap,u.normalScale.value.copy(d.normalScale),d.side===1&&u.normalScale.value.negate()),d.displacementMap&&(u.displacementMap.value=d.displacementMap,u.displacementScale.value=d.displacementScale,u.displacementBias.value=d.displacementBias)}return{refreshFogUniforms:e,refreshMaterialUniforms:t}}function Bc(){const a=wn("canvas");return a.style.display="block",a}function Uc(a={}){const e=a.canvas!==void 0?a.canvas:Bc(),t=a.context!==void 0?a.context:null,i=a.alpha!==void 0?a.alpha:!1,n=a.depth!==void 0?a.depth:!0,r=a.stencil!==void 0?a.stencil:!0,s=a.antialias!==void 0?a.antialias:!1,o=a.premultipliedAlpha!==void 0?a.premultipliedAlpha:!0,c=a.preserveDrawingBuffer!==void 0?a.preserveDrawingBuffer:!1,l=a.powerPreference!==void 0?a.powerPreference:"default",h=a.failIfMajorPerformanceCaveat!==void 0?a.failIfMajorPerformanceCaveat:!1;let p=null,f=null;const m=[],_=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=3e3,this.physicallyCorrectLights=!1,this.toneMapping=0,this.toneMappingExposure=1;const g=this;let b=!1,u=0,d=0,T=null,M=-1,w=null;const E=new We,v=new We;let U=null,q=e.width,O=e.height,L=1,j=null,I=null;const z=new We(0,0,q,O),G=new We(0,0,q,O);let N=!1;const B=[],Y=new Ar;let ne=!1,oe=!1,te=null;const xe=new ze,H=new C,X={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function re(){return T===null?L:1}let F=t;function me(x,R){for(let P=0;P<x.length;P++){const D=x[P],V=e.getContext(D,R);if(V!==null)return V}return null}try{const x={alpha:i,depth:n,stencil:r,antialias:s,premultipliedAlpha:o,preserveDrawingBuffer:c,powerPreference:l,failIfMajorPerformanceCaveat:h};if(e.addEventListener("webglcontextlost",Ue,!1),e.addEventListener("webglcontextrestored",Ge,!1),F===null){const R=["webgl2","webgl","experimental-webgl"];if(g.isWebGL1Renderer===!0&&R.shift(),F=me(R,x),F===null)throw me(R)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}F.getShaderPrecisionFormat===void 0&&(F.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(x){throw console.error("THREE.WebGLRenderer: "+x.message),x}let _e,K,ue,be,he,Le,ke,$e,Ye,S,y,W,J,$,ie,pe,de,ge,se,A,Q,k,ee;function ae(){_e=new rl(F),K=new Jo(F,_e,a),_e.init(K),k=new Pc(F,_e,K),ue=new Rc(F,_e,K),B[0]=1029,be=new ol,he=new xc,Le=new Dc(F,_e,ue,he,K,k,be),ke=new Qo(g),$e=new nl(g),Ye=new va(F,K),ee=new Zo(F,_e,Ye,K),S=new al(F,Ye,be,ee),y=new hl(F,S,Ye,be),se=new ul(F,K,Le),pe=new $o(he),W=new _c(g,ke,$e,_e,K,ee,pe),J=new Nc(he),$=new Mc(he),ie=new Ac(_e,K),ge=new Yo(g,ke,ue,y,o),de=new Cc(g,y,K),A=new jo(F,_e,be,K),Q=new sl(F,_e,be,K),be.programs=W.programs,g.capabilities=K,g.extensions=_e,g.properties=he,g.renderLists=$,g.shadowMap=de,g.state=ue,g.info=be}ae();const ye=new Ic(g,F);this.xr=ye,this.getContext=function(){return F},this.getContextAttributes=function(){return F.getContextAttributes()},this.forceContextLoss=function(){const x=_e.get("WEBGL_lose_context");x&&x.loseContext()},this.forceContextRestore=function(){const x=_e.get("WEBGL_lose_context");x&&x.restoreContext()},this.getPixelRatio=function(){return L},this.setPixelRatio=function(x){x!==void 0&&(L=x,this.setSize(q,O,!1))},this.getSize=function(x){return x.set(q,O)},this.setSize=function(x,R,P){if(ye.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}q=x,O=R,e.width=Math.floor(x*L),e.height=Math.floor(R*L),P!==!1&&(e.style.width=x+"px",e.style.height=R+"px"),this.setViewport(0,0,x,R)},this.getDrawingBufferSize=function(x){return x.set(q*L,O*L).floor()},this.setDrawingBufferSize=function(x,R,P){q=x,O=R,L=P,e.width=Math.floor(x*P),e.height=Math.floor(R*P),this.setViewport(0,0,x,R)},this.getCurrentViewport=function(x){return x.copy(E)},this.getViewport=function(x){return x.copy(z)},this.setViewport=function(x,R,P,D){x.isVector4?z.set(x.x,x.y,x.z,x.w):z.set(x,R,P,D),ue.viewport(E.copy(z).multiplyScalar(L).floor())},this.getScissor=function(x){return x.copy(G)},this.setScissor=function(x,R,P,D){x.isVector4?G.set(x.x,x.y,x.z,x.w):G.set(x,R,P,D),ue.scissor(v.copy(G).multiplyScalar(L).floor())},this.getScissorTest=function(){return N},this.setScissorTest=function(x){ue.setScissorTest(N=x)},this.setOpaqueSort=function(x){j=x},this.setTransparentSort=function(x){I=x},this.getClearColor=function(x){return x.copy(ge.getClearColor())},this.setClearColor=function(){ge.setClearColor.apply(ge,arguments)},this.getClearAlpha=function(){return ge.getClearAlpha()},this.setClearAlpha=function(){ge.setClearAlpha.apply(ge,arguments)},this.clear=function(x,R,P){let D=0;(x===void 0||x)&&(D|=16384),(R===void 0||R)&&(D|=256),(P===void 0||P)&&(D|=1024),F.clear(D)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",Ue,!1),e.removeEventListener("webglcontextrestored",Ge,!1),$.dispose(),ie.dispose(),he.dispose(),ke.dispose(),$e.dispose(),y.dispose(),ee.dispose(),ye.dispose(),ye.removeEventListener("sessionstart",Pn),ye.removeEventListener("sessionend",Fn),te&&(te.dispose(),te=null),Ft.stop()};function Ue(x){x.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),b=!0}function Ge(){console.log("THREE.WebGLRenderer: Context Restored."),b=!1;const x=be.autoReset,R=de.enabled,P=de.autoUpdate,D=de.needsUpdate,V=de.type;ae(),be.autoReset=x,de.enabled=R,de.autoUpdate=P,de.needsUpdate=D,de.type=V}function vt(x){const R=x.target;R.removeEventListener("dispose",vt),Ie(R)}function Ie(x){ut(x),he.remove(x)}function ut(x){const R=he.get(x).programs;R!==void 0&&R.forEach(function(P){W.releaseProgram(P)})}function ht(x,R){x.render(function(P){g.renderBufferImmediate(P,R)})}this.renderBufferImmediate=function(x,R){ee.initAttributes();const P=he.get(x);x.hasPositions&&!P.position&&(P.position=F.createBuffer()),x.hasNormals&&!P.normal&&(P.normal=F.createBuffer()),x.hasUvs&&!P.uv&&(P.uv=F.createBuffer()),x.hasColors&&!P.color&&(P.color=F.createBuffer());const D=R.getAttributes();x.hasPositions&&(F.bindBuffer(34962,P.position),F.bufferData(34962,x.positionArray,35048),ee.enableAttribute(D.position.location),F.vertexAttribPointer(D.position.location,3,5126,!1,0,0)),x.hasNormals&&(F.bindBuffer(34962,P.normal),F.bufferData(34962,x.normalArray,35048),ee.enableAttribute(D.normal.location),F.vertexAttribPointer(D.normal.location,3,5126,!1,0,0)),x.hasUvs&&(F.bindBuffer(34962,P.uv),F.bufferData(34962,x.uvArray,35048),ee.enableAttribute(D.uv.location),F.vertexAttribPointer(D.uv.location,2,5126,!1,0,0)),x.hasColors&&(F.bindBuffer(34962,P.color),F.bufferData(34962,x.colorArray,35048),ee.enableAttribute(D.color.location),F.vertexAttribPointer(D.color.location,3,5126,!1,0,0)),ee.disableUnusedAttributes(),F.drawArrays(4,0,x.count),x.count=0},this.renderBufferDirect=function(x,R,P,D,V,fe){R===null&&(R=X);const le=V.isMesh&&V.matrixWorld.determinant()<0,ce=zn(x,R,P,D,V);ue.setMaterial(D,le);let ve=P.index;const Ae=P.attributes.position;if(ve===null){if(Ae===void 0||Ae.count===0)return}else if(ve.count===0)return;let Se=1;D.wireframe===!0&&(ve=S.getWireframeAttribute(P),Se=2),ee.setup(V,D,ce,P,ve);let we,Pe=A;ve!==null&&(we=Ye.get(ve),Pe=Q,Pe.setIndex(we));const It=ve!==null?ve.count:Ae.count,Te=P.drawRange.start*Se,di=P.drawRange.count*Se,De=fe!==null?fe.start*Se:0,Nt=fe!==null?fe.count*Se:1/0,Bt=Math.max(Te,De),zt=Math.min(It,Te+di,De+Nt)-1,Mt=Math.max(0,zt-Bt+1);if(Mt!==0){if(V.isMesh)D.wireframe===!0?(ue.setLineWidth(D.wireframeLinewidth*re()),Pe.setMode(1)):Pe.setMode(4);else if(V.isLine){let Fe=D.linewidth;Fe===void 0&&(Fe=1),ue.setLineWidth(Fe*re()),V.isLineSegments?Pe.setMode(1):V.isLineLoop?Pe.setMode(2):Pe.setMode(3)}else V.isPoints?Pe.setMode(0):V.isSprite&&Pe.setMode(4);if(V.isInstancedMesh)Pe.renderInstances(Bt,Mt,V.count);else if(P.isInstancedBufferGeometry){const Fe=Math.min(P.instanceCount,P._maxInstanceCount);Pe.renderInstances(Bt,Mt,Fe)}else Pe.render(Bt,Mt)}},this.compile=function(x,R){f=ie.get(x),f.init(),_.push(f),x.traverseVisible(function(P){P.isLight&&P.layers.test(R.layers)&&(f.pushLight(P),P.castShadow&&f.pushShadow(P))}),f.setupLights(g.physicallyCorrectLights),x.traverse(function(P){const D=P.material;if(D)if(Array.isArray(D))for(let V=0;V<D.length;V++){const fe=D[V];Xi(fe,x,P)}else Xi(D,x,P)}),_.pop(),f=null};let qi=null;function Wr(x){qi&&qi(x)}function Pn(){Ft.stop()}function Fn(){Ft.start()}const Ft=new Er;Ft.setAnimationLoop(Wr),typeof window!="undefined"&&Ft.setContext(window),this.setAnimationLoop=function(x){qi=x,ye.setAnimationLoop(x),x===null?Ft.stop():Ft.start()},ye.addEventListener("sessionstart",Pn),ye.addEventListener("sessionend",Fn),this.render=function(x,R){if(R!==void 0&&R.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(b===!0)return;x.autoUpdate===!0&&x.updateMatrixWorld(),R.parent===null&&R.updateMatrixWorld(),ye.enabled===!0&&ye.isPresenting===!0&&(ye.cameraAutoUpdate===!0&&ye.updateCamera(R),R=ye.getCamera()),x.isScene===!0&&x.onBeforeRender(g,x,R,T),f=ie.get(x,_.length),f.init(),_.push(f),xe.multiplyMatrices(R.projectionMatrix,R.matrixWorldInverse),Y.setFromProjectionMatrix(xe),oe=this.localClippingEnabled,ne=pe.init(this.clippingPlanes,oe,R),p=$.get(x,m.length),p.init(),m.push(p),In(x,R,0,g.sortObjects),p.finish(),g.sortObjects===!0&&p.sort(j,I),ne===!0&&pe.beginShadows();const P=f.state.shadowsArray;if(de.render(P,x,R),ne===!0&&pe.endShadows(),this.info.autoReset===!0&&this.info.reset(),ge.render(p,x),f.setupLights(g.physicallyCorrectLights),R.isArrayCamera){const D=R.cameras;for(let V=0,fe=D.length;V<fe;V++){const le=D[V];Nn(p,x,le,le.viewport)}}else Nn(p,x,R);T!==null&&(Le.updateMultisampleRenderTarget(T),Le.updateRenderTargetMipmap(T)),x.isScene===!0&&x.onAfterRender(g,x,R),ue.buffers.depth.setTest(!0),ue.buffers.depth.setMask(!0),ue.buffers.color.setMask(!0),ue.setPolygonOffset(!1),ee.resetDefaultState(),M=-1,w=null,_.pop(),_.length>0?f=_[_.length-1]:f=null,m.pop(),m.length>0?p=m[m.length-1]:p=null};function In(x,R,P,D){if(x.visible===!1)return;if(x.layers.test(R.layers)){if(x.isGroup)P=x.renderOrder;else if(x.isLOD)x.autoUpdate===!0&&x.update(R);else if(x.isLight)f.pushLight(x),x.castShadow&&f.pushShadow(x);else if(x.isSprite){if(!x.frustumCulled||Y.intersectsSprite(x)){D&&H.setFromMatrixPosition(x.matrixWorld).applyMatrix4(xe);const le=y.update(x),ce=x.material;ce.visible&&p.push(x,le,ce,P,H.z,null)}}else if(x.isImmediateRenderObject)D&&H.setFromMatrixPosition(x.matrixWorld).applyMatrix4(xe),p.push(x,null,x.material,P,H.z,null);else if((x.isMesh||x.isLine||x.isPoints)&&(x.isSkinnedMesh&&x.skeleton.frame!==be.render.frame&&(x.skeleton.update(),x.skeleton.frame=be.render.frame),!x.frustumCulled||Y.intersectsObject(x))){D&&H.setFromMatrixPosition(x.matrixWorld).applyMatrix4(xe);const le=y.update(x),ce=x.material;if(Array.isArray(ce)){const ve=le.groups;for(let Ae=0,Se=ve.length;Ae<Se;Ae++){const we=ve[Ae],Pe=ce[we.materialIndex];Pe&&Pe.visible&&p.push(x,le,Pe,P,H.z,we)}}else ce.visible&&p.push(x,le,ce,P,H.z,null)}}const fe=x.children;for(let le=0,ce=fe.length;le<ce;le++)In(fe[le],R,P,D)}function Nn(x,R,P,D){const V=x.opaque,fe=x.transmissive,le=x.transparent;f.setupLightsView(P),fe.length>0&&Hr(V,R,P),D&&ue.viewport(E.copy(D)),V.length>0&&bi(V,R,P),fe.length>0&&bi(fe,R,P),le.length>0&&bi(le,R,P)}function Hr(x,R,P){if(te===null){const le=s===!0&&K.isWebGL2===!0?yr:Ct;te=new le(1024,1024,{generateMipmaps:!0,type:k.convert(1016)!==null?1016:1009,minFilter:1008,magFilter:1003,wrapS:1001,wrapT:1001})}const D=g.getRenderTarget();g.setRenderTarget(te),g.clear();const V=g.toneMapping;g.toneMapping=0,bi(x,R,P),g.toneMapping=V,Le.updateMultisampleRenderTarget(te),Le.updateRenderTargetMipmap(te),g.setRenderTarget(D)}function bi(x,R,P){const D=R.isScene===!0?R.overrideMaterial:null;for(let V=0,fe=x.length;V<fe;V++){const le=x[V],ce=le.object,ve=le.geometry,Ae=D===null?le.material:D,Se=le.group;ce.layers.test(P.layers)&&qr(ce,R,P,ve,Ae,Se)}}function qr(x,R,P,D,V,fe){if(x.onBeforeRender(g,R,P,D,V,fe),x.modelViewMatrix.multiplyMatrices(P.matrixWorldInverse,x.matrixWorld),x.normalMatrix.getNormalMatrix(x.modelViewMatrix),V.onBeforeRender(g,R,P,D,x,fe),x.isImmediateRenderObject){const le=zn(P,R,D,V,x);ue.setMaterial(V),ee.reset(),ht(x,le)}else V.transparent===!0&&V.side===2?(V.side=1,V.needsUpdate=!0,g.renderBufferDirect(P,R,D,V,x,fe),V.side=0,V.needsUpdate=!0,g.renderBufferDirect(P,R,D,V,x,fe),V.side=2):g.renderBufferDirect(P,R,D,V,x,fe);x.onAfterRender(g,R,P,D,V,fe)}function Xi(x,R,P){R.isScene!==!0&&(R=X);const D=he.get(x),V=f.state.lights,fe=f.state.shadowsArray,le=V.state.version,ce=W.getParameters(x,V.state,fe,R,P),ve=W.getProgramCacheKey(ce);let Ae=D.programs;D.environment=x.isMeshStandardMaterial?R.environment:null,D.fog=R.fog,D.envMap=(x.isMeshStandardMaterial?$e:ke).get(x.envMap||D.environment),Ae===void 0&&(x.addEventListener("dispose",vt),Ae=new Map,D.programs=Ae);let Se=Ae.get(ve);if(Se!==void 0){if(D.currentProgram===Se&&D.lightsStateVersion===le)return Bn(x,ce),Se}else ce.uniforms=W.getUniforms(x),x.onBuild(ce,g),x.onBeforeCompile(ce,g),Se=W.acquireProgram(ce,ve),Ae.set(ve,Se),D.uniforms=ce.uniforms;const we=D.uniforms;(!x.isShaderMaterial&&!x.isRawShaderMaterial||x.clipping===!0)&&(we.clippingPlanes=pe.uniform),Bn(x,ce),D.needsLights=Yr(x),D.lightsStateVersion=le,D.needsLights&&(we.ambientLightColor.value=V.state.ambient,we.lightProbe.value=V.state.probe,we.directionalLights.value=V.state.directional,we.directionalLightShadows.value=V.state.directionalShadow,we.spotLights.value=V.state.spot,we.spotLightShadows.value=V.state.spotShadow,we.rectAreaLights.value=V.state.rectArea,we.ltc_1.value=V.state.rectAreaLTC1,we.ltc_2.value=V.state.rectAreaLTC2,we.pointLights.value=V.state.point,we.pointLightShadows.value=V.state.pointShadow,we.hemisphereLights.value=V.state.hemi,we.directionalShadowMap.value=V.state.directionalShadowMap,we.directionalShadowMatrix.value=V.state.directionalShadowMatrix,we.spotShadowMap.value=V.state.spotShadowMap,we.spotShadowMatrix.value=V.state.spotShadowMatrix,we.pointShadowMap.value=V.state.pointShadowMap,we.pointShadowMatrix.value=V.state.pointShadowMatrix);const Pe=Se.getUniforms(),It=Dt.seqWithValue(Pe.seq,we);return D.currentProgram=Se,D.uniformsList=It,Se}function Bn(x,R){const P=he.get(x);P.outputEncoding=R.outputEncoding,P.instancing=R.instancing,P.skinning=R.skinning,P.morphTargets=R.morphTargets,P.morphNormals=R.morphNormals,P.morphTargetsCount=R.morphTargetsCount,P.numClippingPlanes=R.numClippingPlanes,P.numIntersection=R.numClipIntersection,P.vertexAlphas=R.vertexAlphas,P.vertexTangents=R.vertexTangents}function zn(x,R,P,D,V){R.isScene!==!0&&(R=X),Le.resetTextureUnits();const fe=R.fog,le=D.isMeshStandardMaterial?R.environment:null,ce=T===null?g.outputEncoding:T.texture.encoding,ve=(D.isMeshStandardMaterial?$e:ke).get(D.envMap||le),Ae=D.vertexColors===!0&&!!P&&!!P.attributes.color&&P.attributes.color.itemSize===4,Se=!!D.normalMap&&!!P&&!!P.attributes.tangent,we=!!P&&!!P.morphAttributes.position,Pe=!!P&&!!P.morphAttributes.normal,It=!!P&&!!P.morphAttributes.position?P.morphAttributes.position.length:0,Te=he.get(D),di=f.state.lights;if(ne===!0&&(oe===!0||x!==w)){const Qe=x===w&&D.id===M;pe.setState(D,x,Qe)}let De=!1;D.version===Te.__version?(Te.needsLights&&Te.lightsStateVersion!==di.state.version||Te.outputEncoding!==ce||V.isInstancedMesh&&Te.instancing===!1||!V.isInstancedMesh&&Te.instancing===!0||V.isSkinnedMesh&&Te.skinning===!1||!V.isSkinnedMesh&&Te.skinning===!0||Te.envMap!==ve||D.fog&&Te.fog!==fe||Te.numClippingPlanes!==void 0&&(Te.numClippingPlanes!==pe.numPlanes||Te.numIntersection!==pe.numIntersection)||Te.vertexAlphas!==Ae||Te.vertexTangents!==Se||Te.morphTargets!==we||Te.morphNormals!==Pe||K.isWebGL2===!0&&Te.morphTargetsCount!==It)&&(De=!0):(De=!0,Te.__version=D.version);let Nt=Te.currentProgram;De===!0&&(Nt=Xi(D,R,V));let Bt=!1,zt=!1,Mt=!1;const Fe=Nt.getUniforms(),fi=Te.uniforms;if(ue.useProgram(Nt.program)&&(Bt=!0,zt=!0,Mt=!0),D.id!==M&&(M=D.id,zt=!0),Bt||w!==x){if(Fe.setValue(F,"projectionMatrix",x.projectionMatrix),K.logarithmicDepthBuffer&&Fe.setValue(F,"logDepthBufFC",2/(Math.log(x.far+1)/Math.LN2)),w!==x&&(w=x,zt=!0,Mt=!0),D.isShaderMaterial||D.isMeshPhongMaterial||D.isMeshToonMaterial||D.isMeshStandardMaterial||D.envMap){const Qe=Fe.map.cameraPosition;Qe!==void 0&&Qe.setValue(F,H.setFromMatrixPosition(x.matrixWorld))}(D.isMeshPhongMaterial||D.isMeshToonMaterial||D.isMeshLambertMaterial||D.isMeshBasicMaterial||D.isMeshStandardMaterial||D.isShaderMaterial)&&Fe.setValue(F,"isOrthographic",x.isOrthographicCamera===!0),(D.isMeshPhongMaterial||D.isMeshToonMaterial||D.isMeshLambertMaterial||D.isMeshBasicMaterial||D.isMeshStandardMaterial||D.isShaderMaterial||D.isShadowMaterial||V.isSkinnedMesh)&&Fe.setValue(F,"viewMatrix",x.matrixWorldInverse)}if(V.isSkinnedMesh){Fe.setOptional(F,V,"bindMatrix"),Fe.setOptional(F,V,"bindMatrixInverse");const Qe=V.skeleton;Qe&&(K.floatVertexTextures?(Qe.boneTexture===null&&Qe.computeBoneTexture(),Fe.setValue(F,"boneTexture",Qe.boneTexture,Le),Fe.setValue(F,"boneTextureSize",Qe.boneTextureSize)):Fe.setOptional(F,Qe,"boneMatrices"))}return!!P&&(P.morphAttributes.position!==void 0||P.morphAttributes.normal!==void 0)&&se.update(V,P,D,Nt),(zt||Te.receiveShadow!==V.receiveShadow)&&(Te.receiveShadow=V.receiveShadow,Fe.setValue(F,"receiveShadow",V.receiveShadow)),zt&&(Fe.setValue(F,"toneMappingExposure",g.toneMappingExposure),Te.needsLights&&Xr(fi,Mt),fe&&D.fog&&J.refreshFogUniforms(fi,fe),J.refreshMaterialUniforms(fi,D,L,O,te),Dt.upload(F,Te.uniformsList,fi,Le)),D.isShaderMaterial&&D.uniformsNeedUpdate===!0&&(Dt.upload(F,Te.uniformsList,fi,Le),D.uniformsNeedUpdate=!1),D.isSpriteMaterial&&Fe.setValue(F,"center",V.center),Fe.setValue(F,"modelViewMatrix",V.modelViewMatrix),Fe.setValue(F,"normalMatrix",V.normalMatrix),Fe.setValue(F,"modelMatrix",V.matrixWorld),Nt}function Xr(x,R){x.ambientLightColor.needsUpdate=R,x.lightProbe.needsUpdate=R,x.directionalLights.needsUpdate=R,x.directionalLightShadows.needsUpdate=R,x.pointLights.needsUpdate=R,x.pointLightShadows.needsUpdate=R,x.spotLights.needsUpdate=R,x.spotLightShadows.needsUpdate=R,x.rectAreaLights.needsUpdate=R,x.hemisphereLights.needsUpdate=R}function Yr(x){return x.isMeshLambertMaterial||x.isMeshToonMaterial||x.isMeshPhongMaterial||x.isMeshStandardMaterial||x.isShadowMaterial||x.isShaderMaterial&&x.lights===!0}this.getActiveCubeFace=function(){return u},this.getActiveMipmapLevel=function(){return d},this.getRenderTarget=function(){return T},this.setRenderTarget=function(x,R=0,P=0){T=x,u=R,d=P,x&&he.get(x).__webglFramebuffer===void 0&&Le.setupRenderTarget(x);let D=null,V=!1,fe=!1;if(x){const ce=x.texture;(ce.isDataTexture3D||ce.isDataTexture2DArray)&&(fe=!0);const ve=he.get(x).__webglFramebuffer;x.isWebGLCubeRenderTarget?(D=ve[R],V=!0):x.isWebGLMultisampleRenderTarget?D=he.get(x).__webglMultisampledFramebuffer:D=ve,E.copy(x.viewport),v.copy(x.scissor),U=x.scissorTest}else E.copy(z).multiplyScalar(L).floor(),v.copy(G).multiplyScalar(L).floor(),U=N;if(ue.bindFramebuffer(36160,D)&&K.drawBuffers){let ce=!1;if(x)if(x.isWebGLMultipleRenderTargets){const ve=x.texture;if(B.length!==ve.length||B[0]!==36064){for(let Ae=0,Se=ve.length;Ae<Se;Ae++)B[Ae]=36064+Ae;B.length=ve.length,ce=!0}}else(B.length!==1||B[0]!==36064)&&(B[0]=36064,B.length=1,ce=!0);else(B.length!==1||B[0]!==1029)&&(B[0]=1029,B.length=1,ce=!0);ce&&(K.isWebGL2?F.drawBuffers(B):_e.get("WEBGL_draw_buffers").drawBuffersWEBGL(B))}if(ue.viewport(E),ue.scissor(v),ue.setScissorTest(U),V){const ce=he.get(x.texture);F.framebufferTexture2D(36160,36064,34069+R,ce.__webglTexture,P)}else if(fe){const ce=he.get(x.texture),ve=R||0;F.framebufferTextureLayer(36160,36064,ce.__webglTexture,P||0,ve)}M=-1},this.readRenderTargetPixels=function(x,R,P,D,V,fe,le){if(!(x&&x.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let ce=he.get(x).__webglFramebuffer;if(x.isWebGLCubeRenderTarget&&le!==void 0&&(ce=ce[le]),ce){ue.bindFramebuffer(36160,ce);try{const ve=x.texture,Ae=ve.format,Se=ve.type;if(Ae!==1023&&k.convert(Ae)!==F.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const we=Se===1016&&(_e.has("EXT_color_buffer_half_float")||K.isWebGL2&&_e.has("EXT_color_buffer_float"));if(Se!==1009&&k.convert(Se)!==F.getParameter(35738)&&!(Se===1015&&(K.isWebGL2||_e.has("OES_texture_float")||_e.has("WEBGL_color_buffer_float")))&&!we){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}F.checkFramebufferStatus(36160)===36053?R>=0&&R<=x.width-D&&P>=0&&P<=x.height-V&&F.readPixels(R,P,D,V,k.convert(Ae),k.convert(Se),fe):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{const ve=T!==null?he.get(T).__webglFramebuffer:null;ue.bindFramebuffer(36160,ve)}}},this.copyFramebufferToTexture=function(x,R,P=0){const D=Math.pow(2,-P),V=Math.floor(R.image.width*D),fe=Math.floor(R.image.height*D);let le=k.convert(R.format);K.isWebGL2&&(le===6407&&(le=32849),le===6408&&(le=32856)),Le.setTexture2D(R,0),F.copyTexImage2D(3553,P,le,x.x,x.y,V,fe,0),ue.unbindTexture()},this.copyTextureToTexture=function(x,R,P,D=0){const V=R.image.width,fe=R.image.height,le=k.convert(P.format),ce=k.convert(P.type);Le.setTexture2D(P,0),F.pixelStorei(37440,P.flipY),F.pixelStorei(37441,P.premultiplyAlpha),F.pixelStorei(3317,P.unpackAlignment),R.isDataTexture?F.texSubImage2D(3553,D,x.x,x.y,V,fe,le,ce,R.image.data):R.isCompressedTexture?F.compressedTexSubImage2D(3553,D,x.x,x.y,R.mipmaps[0].width,R.mipmaps[0].height,le,R.mipmaps[0].data):F.texSubImage2D(3553,D,x.x,x.y,le,ce,R.image),D===0&&P.generateMipmaps&&F.generateMipmap(3553),ue.unbindTexture()},this.copyTextureToTexture3D=function(x,R,P,D,V=0){if(g.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const fe=x.max.x-x.min.x+1,le=x.max.y-x.min.y+1,ce=x.max.z-x.min.z+1,ve=k.convert(D.format),Ae=k.convert(D.type);let Se;if(D.isDataTexture3D)Le.setTexture3D(D,0),Se=32879;else if(D.isDataTexture2DArray)Le.setTexture2DArray(D,0),Se=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}F.pixelStorei(37440,D.flipY),F.pixelStorei(37441,D.premultiplyAlpha),F.pixelStorei(3317,D.unpackAlignment);const we=F.getParameter(3314),Pe=F.getParameter(32878),It=F.getParameter(3316),Te=F.getParameter(3315),di=F.getParameter(32877),De=P.isCompressedTexture?P.mipmaps[0]:P.image;F.pixelStorei(3314,De.width),F.pixelStorei(32878,De.height),F.pixelStorei(3316,x.min.x),F.pixelStorei(3315,x.min.y),F.pixelStorei(32877,x.min.z),P.isDataTexture||P.isDataTexture3D?F.texSubImage3D(Se,V,R.x,R.y,R.z,fe,le,ce,ve,Ae,De.data):P.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),F.compressedTexSubImage3D(Se,V,R.x,R.y,R.z,fe,le,ce,ve,De.data)):F.texSubImage3D(Se,V,R.x,R.y,R.z,fe,le,ce,ve,Ae,De),F.pixelStorei(3314,we),F.pixelStorei(32878,Pe),F.pixelStorei(3316,It),F.pixelStorei(3315,Te),F.pixelStorei(32877,di),V===0&&D.generateMipmaps&&F.generateMipmap(Se),ue.unbindTexture()},this.initTexture=function(x){Le.setTexture2D(x,0),ue.unbindTexture()},this.resetState=function(){u=0,d=0,T=null,ue.reset(),ee.reset()},typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}class zc extends Je{constructor(){super(),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.autoUpdate=e.autoUpdate,this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),t}}zc.prototype.isScene=!0;class kr extends xt{constructor(e=1,t=32,i=16,n=0,r=Math.PI*2,s=0,o=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:i,phiStart:n,phiLength:r,thetaStart:s,thetaLength:o},t=Math.max(3,Math.floor(t)),i=Math.max(2,Math.floor(i));const c=Math.min(s+o,Math.PI);let l=0;const h=[],p=new C,f=new C,m=[],_=[],g=[],b=[];for(let u=0;u<=i;u++){const d=[],T=u/i;let M=0;u==0&&s==0?M=.5/t:u==i&&c==Math.PI&&(M=-.5/t);for(let w=0;w<=t;w++){const E=w/t;p.x=-e*Math.cos(n+E*r)*Math.sin(s+T*o),p.y=e*Math.cos(s+T*o),p.z=e*Math.sin(n+E*r)*Math.sin(s+T*o),_.push(p.x,p.y,p.z),f.copy(p).normalize(),g.push(f.x,f.y,f.z),b.push(E+M,1-T),d.push(l++)}h.push(d)}for(let u=0;u<i;u++)for(let d=0;d<t;d++){const T=h[u][d+1],M=h[u][d],w=h[u+1][d],E=h[u+1][d+1];(u!==0||s>0)&&m.push(T,M,E),(u!==i-1||c<Math.PI)&&m.push(M,w,E)}this.setIndex(m),this.setAttribute("position",new ct(_,3)),this.setAttribute("normal",new ct(g,3)),this.setAttribute("uv",new ct(b,2))}static fromJSON(e){return new kr(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}function Gc(a){const e=new ui(1,1,1),t=new Wi({color:16777215,wireframe:!0}),i=new lt(e,t),[n,r,s]=Array(3).fill().map(()=>Jr(500));i.position.set(n,r,s),i.userData.rx=Math.random()*.01-.005,i.userData.ry=Math.random()*.01-.005,i.userData.rz=Math.random()*.01-.005,a.add(i)}function Oc(a,e){window.addEventListener("resize",function(){a.setSize(window.innerWidth,window.innerHeight),e.aspect=window.innerWidth/window.innerHeight,e.updateProjectionMatrix()})}export{xt as B,ct as F,Mi as G,Wi as M,it as P,zc as S,C as V,Uc as W,lt as a,kr as b,Oc as c,Re as d,Gc as r};
