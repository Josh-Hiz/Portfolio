const na=function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))i(n);new MutationObserver(n=>{for(const r of n)if(r.type==="childList")for(const a of r.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&i(a)}).observe(document,{childList:!0,subtree:!0});function t(n){const r={};return n.integrity&&(r.integrity=n.integrity),n.referrerpolicy&&(r.referrerPolicy=n.referrerpolicy),n.crossorigin==="use-credentials"?r.credentials="include":n.crossorigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function i(n){if(n.ep)return;n.ep=!0;const r=t(n);fetch(n.href,r)}};na();const ra=0,Mr=1,sa=2,ys=1,aa=2,Fi=3,Bi=0,ze=1,gi=2,oa=1,Nt=0,Ni=1,yr=2,Sr=3,br=4,la=5,fi=100,ca=101,ua=102,wr=103,Tr=104,ha=200,da=201,fa=202,pa=203,Ss=204,bs=205,ma=206,ga=207,_a=208,xa=209,va=210,Ma=0,ya=1,Sa=2,Zn=3,ba=4,wa=5,Ta=6,Ea=7,ws=0,Aa=1,La=2,Jt=0,Ca=1,Da=2,Pa=3,Ra=4,Fa=5,Ts=300,un=301,hn=302,jn=303,Jn=304,dn=306,nr=307,$n=1e3,$e=1001,Qn=1002,Ze=1003,Er=1004,Ar=1005,ft=1006,Ia=1007,fn=1008,Ot=1009,za=1010,Na=1011,Kn=1012,Ua=1013,ln=1014,zt=1015,pi=1016,Ba=1017,Ga=1018,Oa=1019,cn=1020,Va=1021,Ui=1022,Xe=1023,ka=1024,Wa=1025,Ha=Xe,er=1026,tr=1027,Xa=1028,qa=1029,Ya=1030,Za=1031,ja=1032,Ja=1033,Lr=33776,Cr=33777,Dr=33778,Pr=33779,Rr=35840,Fr=35841,Ir=35842,zr=35843,$a=36196,Nr=37492,Ur=37496,Qa=37808,Ka=37809,eo=37810,to=37811,io=37812,no=37813,ro=37814,so=37815,ao=37816,oo=37817,lo=37818,co=37819,uo=37820,ho=37821,fo=36492,po=37840,mo=37841,go=37842,_o=37843,xo=37844,vo=37845,Mo=37846,yo=37847,So=37848,bo=37849,wo=37850,To=37851,Eo=37852,Ao=37853,qe=3e3,vi=3001,rr=3007,sr=3002,Lo=3003,Es=3004,As=3005,Ls=3006,Co=3200,Do=3201,Po=0,Ro=1,xn=7680,Fo=519,Br=35044,Gr="300 es";class Mi{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const i=this._listeners;i[e]===void 0&&(i[e]=[]),i[e].indexOf(t)===-1&&i[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const i=this._listeners;return i[e]!==void 0&&i[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const n=this._listeners[e];if(n!==void 0){const r=n.indexOf(t);r!==-1&&n.splice(r,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const i=this._listeners[e.type];if(i!==void 0){e.target=this;const n=i.slice(0);for(let r=0,a=n.length;r<a;r++)n[r].call(this,e);e.target=null}}}const vn=Math.PI/180,Or=180/Math.PI,Ue=[];for(let s=0;s<256;s++)Ue[s]=(s<16?"0":"")+s.toString(16);const Io=typeof crypto!="undefined"&&"randomUUID"in crypto;function Gi(){if(Io)return crypto.randomUUID().toUpperCase();const s=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,i=Math.random()*4294967295|0;return(Ue[s&255]+Ue[s>>8&255]+Ue[s>>16&255]+Ue[s>>24&255]+"-"+Ue[e&255]+Ue[e>>8&255]+"-"+Ue[e>>16&15|64]+Ue[e>>24&255]+"-"+Ue[t&63|128]+Ue[t>>8&255]+"-"+Ue[t>>16&255]+Ue[t>>24&255]+Ue[i&255]+Ue[i>>8&255]+Ue[i>>16&255]+Ue[i>>24&255]).toUpperCase()}function ht(s,e,t){return Math.max(e,Math.min(t,s))}function zo(s,e){return(s%e+e)%e}function Mn(s,e,t){return(1-t)*s+t*e}function No(s){return s*(.5-Math.random())}function Vr(s){return(s&s-1)===0&&s!==0}function Uo(s){return Math.pow(2,Math.floor(Math.log(s)/Math.LN2))}class De{constructor(e=0,t=0){this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this)}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this)}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,i=this.y,n=e.elements;return this.x=n[0]*t+n[3]*i+n[6],this.y=n[1]*t+n[4]*i+n[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(e,Math.min(t,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,i=this.y-e.y;return t*t+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t,i){return i!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const i=Math.cos(t),n=Math.sin(t),r=this.x-e.x,a=this.y-e.y;return this.x=r*i-a*n+e.x,this.y=r*n+a*i+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}De.prototype.isVector2=!0;class lt{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(e,t,i,n,r,a,o,c,l){const h=this.elements;return h[0]=e,h[1]=n,h[2]=o,h[3]=t,h[4]=r,h[5]=c,h[6]=i,h[7]=a,h[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,i=e.elements;return t[0]=i[0],t[1]=i[1],t[2]=i[2],t[3]=i[3],t[4]=i[4],t[5]=i[5],t[6]=i[6],t[7]=i[7],t[8]=i[8],this}extractBasis(e,t,i){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const i=e.elements,n=t.elements,r=this.elements,a=i[0],o=i[3],c=i[6],l=i[1],h=i[4],p=i[7],f=i[2],m=i[5],_=i[8],g=n[0],b=n[3],u=n[6],d=n[1],T=n[4],M=n[7],w=n[2],A=n[5],v=n[8];return r[0]=a*g+o*d+c*w,r[3]=a*b+o*T+c*A,r[6]=a*u+o*M+c*v,r[1]=l*g+h*d+p*w,r[4]=l*b+h*T+p*A,r[7]=l*u+h*M+p*v,r[2]=f*g+m*d+_*w,r[5]=f*b+m*T+_*A,r[8]=f*u+m*M+_*v,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],i=e[1],n=e[2],r=e[3],a=e[4],o=e[5],c=e[6],l=e[7],h=e[8];return t*a*h-t*o*l-i*r*h+i*o*c+n*r*l-n*a*c}invert(){const e=this.elements,t=e[0],i=e[1],n=e[2],r=e[3],a=e[4],o=e[5],c=e[6],l=e[7],h=e[8],p=h*a-o*l,f=o*c-h*r,m=l*r-a*c,_=t*p+i*f+n*m;if(_===0)return this.set(0,0,0,0,0,0,0,0,0);const g=1/_;return e[0]=p*g,e[1]=(n*l-h*i)*g,e[2]=(o*i-n*a)*g,e[3]=f*g,e[4]=(h*t-n*c)*g,e[5]=(n*r-o*t)*g,e[6]=m*g,e[7]=(i*c-l*t)*g,e[8]=(a*t-i*r)*g,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,i,n,r,a,o){const c=Math.cos(r),l=Math.sin(r);return this.set(i*c,i*l,-i*(c*a+l*o)+a+e,-n*l,n*c,-n*(-l*a+c*o)+o+t,0,0,1),this}scale(e,t){const i=this.elements;return i[0]*=e,i[3]*=e,i[6]*=e,i[1]*=t,i[4]*=t,i[7]*=t,this}rotate(e){const t=Math.cos(e),i=Math.sin(e),n=this.elements,r=n[0],a=n[3],o=n[6],c=n[1],l=n[4],h=n[7];return n[0]=t*r+i*c,n[3]=t*a+i*l,n[6]=t*o+i*h,n[1]=-i*r+t*c,n[4]=-i*a+t*l,n[7]=-i*o+t*h,this}translate(e,t){const i=this.elements;return i[0]+=e*i[2],i[3]+=e*i[5],i[6]+=e*i[8],i[1]+=t*i[2],i[4]+=t*i[5],i[7]+=t*i[8],this}equals(e){const t=this.elements,i=e.elements;for(let n=0;n<9;n++)if(t[n]!==i[n])return!1;return!0}fromArray(e,t=0){for(let i=0;i<9;i++)this.elements[i]=e[i+t];return this}toArray(e=[],t=0){const i=this.elements;return e[t]=i[0],e[t+1]=i[1],e[t+2]=i[2],e[t+3]=i[3],e[t+4]=i[4],e[t+5]=i[5],e[t+6]=i[6],e[t+7]=i[7],e[t+8]=i[8],e}clone(){return new this.constructor().fromArray(this.elements)}}lt.prototype.isMatrix3=!0;function Cs(s){if(s.length===0)return-1/0;let e=s[0];for(let t=1,i=s.length;t<i;++t)s[t]>e&&(e=s[t]);return e}function ar(s){return document.createElementNS("http://www.w3.org/1999/xhtml",s)}let $t;class Bo{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement=="undefined")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{$t===void 0&&($t=ar("canvas")),$t.width=e.width,$t.height=e.height;const i=$t.getContext("2d");e instanceof ImageData?i.putImageData(e,0,0):i.drawImage(e,0,0,e.width,e.height),t=$t}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}}let Go=0;class ct extends Mi{constructor(e=ct.DEFAULT_IMAGE,t=ct.DEFAULT_MAPPING,i=$e,n=$e,r=ft,a=fn,o=Xe,c=Ot,l=1,h=qe){super(),Object.defineProperty(this,"id",{value:Go++}),this.uuid=Gi(),this.name="",this.image=e,this.mipmaps=[],this.mapping=t,this.wrapS=i,this.wrapT=n,this.magFilter=r,this.minFilter=a,this.anisotropy=l,this.format=o,this.internalFormat=null,this.type=c,this.offset=new De(0,0),this.repeat=new De(1,1),this.center=new De(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new lt,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=h,this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.image=e.image,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const i={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==void 0){const n=this.image;if(n.uuid===void 0&&(n.uuid=Gi()),!t&&e.images[n.uuid]===void 0){let r;if(Array.isArray(n)){r=[];for(let a=0,o=n.length;a<o;a++)n[a].isDataTexture?r.push(yn(n[a].image)):r.push(yn(n[a]))}else r=yn(n);e.images[n.uuid]={uuid:n.uuid,url:r}}i.image=n.uuid}return t||(e.textures[this.uuid]=i),i}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==Ts)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case $n:e.x=e.x-Math.floor(e.x);break;case $e:e.x=e.x<0?0:1;break;case Qn:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case $n:e.y=e.y-Math.floor(e.y);break;case $e:e.y=e.y<0?0:1;break;case Qn:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&this.version++}}ct.DEFAULT_IMAGE=void 0;ct.DEFAULT_MAPPING=Ts;ct.prototype.isTexture=!0;function yn(s){return typeof HTMLImageElement!="undefined"&&s instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&s instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&s instanceof ImageBitmap?Bo.getDataURL(s):s.data?{data:Array.prototype.slice.call(s.data),width:s.width,height:s.height,type:s.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}class He{constructor(e=0,t=0,i=0,n=1){this.x=e,this.y=t,this.z=i,this.w=n}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,i,n){return this.x=e,this.y=t,this.z=i,this.w=n,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,i=this.y,n=this.z,r=this.w,a=e.elements;return this.x=a[0]*t+a[4]*i+a[8]*n+a[12]*r,this.y=a[1]*t+a[5]*i+a[9]*n+a[13]*r,this.z=a[2]*t+a[6]*i+a[10]*n+a[14]*r,this.w=a[3]*t+a[7]*i+a[11]*n+a[15]*r,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,i,n,r;const c=e.elements,l=c[0],h=c[4],p=c[8],f=c[1],m=c[5],_=c[9],g=c[2],b=c[6],u=c[10];if(Math.abs(h-f)<.01&&Math.abs(p-g)<.01&&Math.abs(_-b)<.01){if(Math.abs(h+f)<.1&&Math.abs(p+g)<.1&&Math.abs(_+b)<.1&&Math.abs(l+m+u-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const T=(l+1)/2,M=(m+1)/2,w=(u+1)/2,A=(h+f)/4,v=(p+g)/4,B=(_+b)/4;return T>M&&T>w?T<.01?(i=0,n=.707106781,r=.707106781):(i=Math.sqrt(T),n=A/i,r=v/i):M>w?M<.01?(i=.707106781,n=0,r=.707106781):(n=Math.sqrt(M),i=A/n,r=B/n):w<.01?(i=.707106781,n=.707106781,r=0):(r=Math.sqrt(w),i=v/r,n=B/r),this.set(i,n,r,t),this}let d=Math.sqrt((b-_)*(b-_)+(p-g)*(p-g)+(f-h)*(f-h));return Math.abs(d)<.001&&(d=1),this.x=(b-_)/d,this.y=(p-g)/d,this.z=(f-h)/d,this.w=Math.acos((l+m+u-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(e,Math.min(t,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this.z=e.z+(t.z-e.z)*i,this.w=e.w+(t.w-e.w)*i,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t,i){return i!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}He.prototype.isVector4=!0;class Ut extends Mi{constructor(e,t,i={}){super(),this.width=e,this.height=t,this.depth=1,this.scissor=new He(0,0,e,t),this.scissorTest=!1,this.viewport=new He(0,0,e,t),this.texture=new ct(void 0,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.encoding),this.texture.isRenderTargetTexture=!0,this.texture.image={width:e,height:t,depth:1},this.texture.generateMipmaps=i.generateMipmaps!==void 0?i.generateMipmaps:!1,this.texture.internalFormat=i.internalFormat!==void 0?i.internalFormat:null,this.texture.minFilter=i.minFilter!==void 0?i.minFilter:ft,this.depthBuffer=i.depthBuffer!==void 0?i.depthBuffer:!0,this.stencilBuffer=i.stencilBuffer!==void 0?i.stencilBuffer:!1,this.depthTexture=i.depthTexture!==void 0?i.depthTexture:null}setTexture(e){e.image={width:this.width,height:this.height,depth:this.depth},this.texture=e}setSize(e,t,i=1){(this.width!==e||this.height!==t||this.depth!==i)&&(this.width=e,this.height=t,this.depth=i,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=i,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.texture.image={...this.texture.image},this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}Ut.prototype.isWebGLRenderTarget=!0;class Ds extends Ut{constructor(e,t,i){super(e,t,i),this.samples=4}copy(e){return super.copy.call(this,e),this.samples=e.samples,this}}Ds.prototype.isWebGLMultisampleRenderTarget=!0;class yi{constructor(e=0,t=0,i=0,n=1){this._x=e,this._y=t,this._z=i,this._w=n}static slerp(e,t,i,n){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),i.slerpQuaternions(e,t,n)}static slerpFlat(e,t,i,n,r,a,o){let c=i[n+0],l=i[n+1],h=i[n+2],p=i[n+3];const f=r[a+0],m=r[a+1],_=r[a+2],g=r[a+3];if(o===0){e[t+0]=c,e[t+1]=l,e[t+2]=h,e[t+3]=p;return}if(o===1){e[t+0]=f,e[t+1]=m,e[t+2]=_,e[t+3]=g;return}if(p!==g||c!==f||l!==m||h!==_){let b=1-o;const u=c*f+l*m+h*_+p*g,d=u>=0?1:-1,T=1-u*u;if(T>Number.EPSILON){const w=Math.sqrt(T),A=Math.atan2(w,u*d);b=Math.sin(b*A)/w,o=Math.sin(o*A)/w}const M=o*d;if(c=c*b+f*M,l=l*b+m*M,h=h*b+_*M,p=p*b+g*M,b===1-o){const w=1/Math.sqrt(c*c+l*l+h*h+p*p);c*=w,l*=w,h*=w,p*=w}}e[t]=c,e[t+1]=l,e[t+2]=h,e[t+3]=p}static multiplyQuaternionsFlat(e,t,i,n,r,a){const o=i[n],c=i[n+1],l=i[n+2],h=i[n+3],p=r[a],f=r[a+1],m=r[a+2],_=r[a+3];return e[t]=o*_+h*p+c*m-l*f,e[t+1]=c*_+h*f+l*p-o*m,e[t+2]=l*_+h*m+o*f-c*p,e[t+3]=h*_-o*p-c*f-l*m,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,i,n){return this._x=e,this._y=t,this._z=i,this._w=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){if(!(e&&e.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const i=e._x,n=e._y,r=e._z,a=e._order,o=Math.cos,c=Math.sin,l=o(i/2),h=o(n/2),p=o(r/2),f=c(i/2),m=c(n/2),_=c(r/2);switch(a){case"XYZ":this._x=f*h*p+l*m*_,this._y=l*m*p-f*h*_,this._z=l*h*_+f*m*p,this._w=l*h*p-f*m*_;break;case"YXZ":this._x=f*h*p+l*m*_,this._y=l*m*p-f*h*_,this._z=l*h*_-f*m*p,this._w=l*h*p+f*m*_;break;case"ZXY":this._x=f*h*p-l*m*_,this._y=l*m*p+f*h*_,this._z=l*h*_+f*m*p,this._w=l*h*p-f*m*_;break;case"ZYX":this._x=f*h*p-l*m*_,this._y=l*m*p+f*h*_,this._z=l*h*_-f*m*p,this._w=l*h*p+f*m*_;break;case"YZX":this._x=f*h*p+l*m*_,this._y=l*m*p+f*h*_,this._z=l*h*_-f*m*p,this._w=l*h*p-f*m*_;break;case"XZY":this._x=f*h*p-l*m*_,this._y=l*m*p-f*h*_,this._z=l*h*_+f*m*p,this._w=l*h*p+f*m*_;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const i=t/2,n=Math.sin(i);return this._x=e.x*n,this._y=e.y*n,this._z=e.z*n,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,i=t[0],n=t[4],r=t[8],a=t[1],o=t[5],c=t[9],l=t[2],h=t[6],p=t[10],f=i+o+p;if(f>0){const m=.5/Math.sqrt(f+1);this._w=.25/m,this._x=(h-c)*m,this._y=(r-l)*m,this._z=(a-n)*m}else if(i>o&&i>p){const m=2*Math.sqrt(1+i-o-p);this._w=(h-c)/m,this._x=.25*m,this._y=(n+a)/m,this._z=(r+l)/m}else if(o>p){const m=2*Math.sqrt(1+o-i-p);this._w=(r-l)/m,this._x=(n+a)/m,this._y=.25*m,this._z=(c+h)/m}else{const m=2*Math.sqrt(1+p-i-o);this._w=(a-n)/m,this._x=(r+l)/m,this._y=(c+h)/m,this._z=.25*m}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let i=e.dot(t)+1;return i<Number.EPSILON?(i=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=i):(this._x=0,this._y=-e.z,this._z=e.y,this._w=i)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=i),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(ht(this.dot(e),-1,1)))}rotateTowards(e,t){const i=this.angleTo(e);if(i===0)return this;const n=Math.min(1,t/i);return this.slerp(e,n),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e,t){return t!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,t)):this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const i=e._x,n=e._y,r=e._z,a=e._w,o=t._x,c=t._y,l=t._z,h=t._w;return this._x=i*h+a*o+n*l-r*c,this._y=n*h+a*c+r*o-i*l,this._z=r*h+a*l+i*c-n*o,this._w=a*h-i*o-n*c-r*l,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const i=this._x,n=this._y,r=this._z,a=this._w;let o=a*e._w+i*e._x+n*e._y+r*e._z;if(o<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,o=-o):this.copy(e),o>=1)return this._w=a,this._x=i,this._y=n,this._z=r,this;const c=1-o*o;if(c<=Number.EPSILON){const m=1-t;return this._w=m*a+t*this._w,this._x=m*i+t*this._x,this._y=m*n+t*this._y,this._z=m*r+t*this._z,this.normalize(),this._onChangeCallback(),this}const l=Math.sqrt(c),h=Math.atan2(l,o),p=Math.sin((1-t)*h)/l,f=Math.sin(t*h)/l;return this._w=a*p+this._w*f,this._x=i*p+this._x*f,this._y=n*p+this._y*f,this._z=r*p+this._z*f,this._onChangeCallback(),this}slerpQuaternions(e,t,i){this.copy(e).slerp(t,i)}random(){const e=Math.random(),t=Math.sqrt(1-e),i=Math.sqrt(e),n=2*Math.PI*Math.random(),r=2*Math.PI*Math.random();return this.set(t*Math.cos(n),i*Math.sin(r),i*Math.cos(r),t*Math.sin(n))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}yi.prototype.isQuaternion=!0;class C{constructor(e=0,t=0,i=0){this.x=e,this.y=t,this.z=i}set(e,t,i){return i===void 0&&(i=this.z),this.x=e,this.y=t,this.z=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,t)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(kr.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(kr.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,i=this.y,n=this.z,r=e.elements;return this.x=r[0]*t+r[3]*i+r[6]*n,this.y=r[1]*t+r[4]*i+r[7]*n,this.z=r[2]*t+r[5]*i+r[8]*n,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,i=this.y,n=this.z,r=e.elements,a=1/(r[3]*t+r[7]*i+r[11]*n+r[15]);return this.x=(r[0]*t+r[4]*i+r[8]*n+r[12])*a,this.y=(r[1]*t+r[5]*i+r[9]*n+r[13])*a,this.z=(r[2]*t+r[6]*i+r[10]*n+r[14])*a,this}applyQuaternion(e){const t=this.x,i=this.y,n=this.z,r=e.x,a=e.y,o=e.z,c=e.w,l=c*t+a*n-o*i,h=c*i+o*t-r*n,p=c*n+r*i-a*t,f=-r*t-a*i-o*n;return this.x=l*c+f*-r+h*-o-p*-a,this.y=h*c+f*-a+p*-r-l*-o,this.z=p*c+f*-o+l*-a-h*-r,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,i=this.y,n=this.z,r=e.elements;return this.x=r[0]*t+r[4]*i+r[8]*n,this.y=r[1]*t+r[5]*i+r[9]*n,this.z=r[2]*t+r[6]*i+r[10]*n,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(e,Math.min(t,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this.z=e.z+(t.z-e.z)*i,this}cross(e,t){return t!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,t)):this.crossVectors(this,e)}crossVectors(e,t){const i=e.x,n=e.y,r=e.z,a=t.x,o=t.y,c=t.z;return this.x=n*c-r*o,this.y=r*a-i*c,this.z=i*o-n*a,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const i=e.dot(this)/t;return this.copy(e).multiplyScalar(i)}projectOnPlane(e){return Sn.copy(this).projectOnVector(e),this.sub(Sn)}reflect(e){return this.sub(Sn.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const i=this.dot(e)/t;return Math.acos(ht(i,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,i=this.y-e.y,n=this.z-e.z;return t*t+i*i+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,i){const n=Math.sin(t)*e;return this.x=n*Math.sin(i),this.y=Math.cos(t)*e,this.z=n*Math.cos(i),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,i){return this.x=e*Math.sin(t),this.y=i,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),i=this.setFromMatrixColumn(e,1).length(),n=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=i,this.z=n,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t,i){return i!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=(Math.random()-.5)*2,t=Math.random()*Math.PI*2,i=Math.sqrt(1-e**2);return this.x=i*Math.cos(t),this.y=i*Math.sin(t),this.z=e,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}C.prototype.isVector3=!0;const Sn=new C,kr=new yi;class Si{constructor(e=new C(1/0,1/0,1/0),t=new C(-1/0,-1/0,-1/0)){this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,i=1/0,n=1/0,r=-1/0,a=-1/0,o=-1/0;for(let c=0,l=e.length;c<l;c+=3){const h=e[c],p=e[c+1],f=e[c+2];h<t&&(t=h),p<i&&(i=p),f<n&&(n=f),h>r&&(r=h),p>a&&(a=p),f>o&&(o=f)}return this.min.set(t,i,n),this.max.set(r,a,o),this}setFromBufferAttribute(e){let t=1/0,i=1/0,n=1/0,r=-1/0,a=-1/0,o=-1/0;for(let c=0,l=e.count;c<l;c++){const h=e.getX(c),p=e.getY(c),f=e.getZ(c);h<t&&(t=h),p<i&&(i=p),f<n&&(n=f),h>r&&(r=h),p>a&&(a=p),f>o&&(o=f)}return this.min.set(t,i,n),this.max.set(r,a,o),this}setFromPoints(e){this.makeEmpty();for(let t=0,i=e.length;t<i;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const i=Li.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(i),this.max.copy(e).add(i),this}setFromObject(e){return this.makeEmpty(),this.expandByObject(e)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e){e.updateWorldMatrix(!1,!1);const t=e.geometry;t!==void 0&&(t.boundingBox===null&&t.computeBoundingBox(),bn.copy(t.boundingBox),bn.applyMatrix4(e.matrixWorld),this.union(bn));const i=e.children;for(let n=0,r=i.length;n<r;n++)this.expandByObject(i[n]);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,Li),Li.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,i;return e.normal.x>0?(t=e.normal.x*this.min.x,i=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,i=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,i+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,i+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,i+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,i+=e.normal.z*this.min.z),t<=-e.constant&&i>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(Ci),ki.subVectors(this.max,Ci),Qt.subVectors(e.a,Ci),Kt.subVectors(e.b,Ci),ei.subVectors(e.c,Ci),At.subVectors(Kt,Qt),Lt.subVectors(ei,Kt),Yt.subVectors(Qt,ei);let t=[0,-At.z,At.y,0,-Lt.z,Lt.y,0,-Yt.z,Yt.y,At.z,0,-At.x,Lt.z,0,-Lt.x,Yt.z,0,-Yt.x,-At.y,At.x,0,-Lt.y,Lt.x,0,-Yt.y,Yt.x,0];return!wn(t,Qt,Kt,ei,ki)||(t=[1,0,0,0,1,0,0,0,1],!wn(t,Qt,Kt,ei,ki))?!1:(Wi.crossVectors(At,Lt),t=[Wi.x,Wi.y,Wi.z],wn(t,Qt,Kt,ei,ki))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return Li.copy(e).clamp(this.min,this.max).sub(e).length()}getBoundingSphere(e){return this.getCenter(e.center),e.radius=this.getSize(Li).length()*.5,e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(xt[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),xt[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),xt[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),xt[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),xt[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),xt[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),xt[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),xt[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(xt),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}Si.prototype.isBox3=!0;const xt=[new C,new C,new C,new C,new C,new C,new C,new C],Li=new C,bn=new Si,Qt=new C,Kt=new C,ei=new C,At=new C,Lt=new C,Yt=new C,Ci=new C,ki=new C,Wi=new C,Zt=new C;function wn(s,e,t,i,n){for(let r=0,a=s.length-3;r<=a;r+=3){Zt.fromArray(s,r);const o=n.x*Math.abs(Zt.x)+n.y*Math.abs(Zt.y)+n.z*Math.abs(Zt.z),c=e.dot(Zt),l=t.dot(Zt),h=i.dot(Zt);if(Math.max(-Math.max(c,l,h),Math.min(c,l,h))>o)return!1}return!0}const Oo=new Si,Wr=new C,Tn=new C,En=new C;class or{constructor(e=new C,t=-1){this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const i=this.center;t!==void 0?i.copy(t):Oo.setFromPoints(e).getCenter(i);let n=0;for(let r=0,a=e.length;r<a;r++)n=Math.max(n,i.distanceToSquared(e[r]));return this.radius=Math.sqrt(n),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const i=this.center.distanceToSquared(e);return t.copy(e),i>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){En.subVectors(e,this.center);const t=En.lengthSq();if(t>this.radius*this.radius){const i=Math.sqrt(t),n=(i-this.radius)*.5;this.center.add(En.multiplyScalar(n/i)),this.radius+=n}return this}union(e){return Tn.subVectors(e.center,this.center).normalize().multiplyScalar(e.radius),this.expandByPoint(Wr.copy(e.center).add(Tn)),this.expandByPoint(Wr.copy(e.center).sub(Tn)),this}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const vt=new C,An=new C,Hi=new C,Ct=new C,Ln=new C,Xi=new C,Cn=new C;class Vo{constructor(e=new C,t=new C(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,vt)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const i=t.dot(this.direction);return i<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(i).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=vt.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(vt.copy(this.direction).multiplyScalar(t).add(this.origin),vt.distanceToSquared(e))}distanceSqToSegment(e,t,i,n){An.copy(e).add(t).multiplyScalar(.5),Hi.copy(t).sub(e).normalize(),Ct.copy(this.origin).sub(An);const r=e.distanceTo(t)*.5,a=-this.direction.dot(Hi),o=Ct.dot(this.direction),c=-Ct.dot(Hi),l=Ct.lengthSq(),h=Math.abs(1-a*a);let p,f,m,_;if(h>0)if(p=a*c-o,f=a*o-c,_=r*h,p>=0)if(f>=-_)if(f<=_){const g=1/h;p*=g,f*=g,m=p*(p+a*f+2*o)+f*(a*p+f+2*c)+l}else f=r,p=Math.max(0,-(a*f+o)),m=-p*p+f*(f+2*c)+l;else f=-r,p=Math.max(0,-(a*f+o)),m=-p*p+f*(f+2*c)+l;else f<=-_?(p=Math.max(0,-(-a*r+o)),f=p>0?-r:Math.min(Math.max(-r,-c),r),m=-p*p+f*(f+2*c)+l):f<=_?(p=0,f=Math.min(Math.max(-r,-c),r),m=f*(f+2*c)+l):(p=Math.max(0,-(a*r+o)),f=p>0?r:Math.min(Math.max(-r,-c),r),m=-p*p+f*(f+2*c)+l);else f=a>0?-r:r,p=Math.max(0,-(a*f+o)),m=-p*p+f*(f+2*c)+l;return i&&i.copy(this.direction).multiplyScalar(p).add(this.origin),n&&n.copy(Hi).multiplyScalar(f).add(An),m}intersectSphere(e,t){vt.subVectors(e.center,this.origin);const i=vt.dot(this.direction),n=vt.dot(vt)-i*i,r=e.radius*e.radius;if(n>r)return null;const a=Math.sqrt(r-n),o=i-a,c=i+a;return o<0&&c<0?null:o<0?this.at(c,t):this.at(o,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const i=-(this.origin.dot(e.normal)+e.constant)/t;return i>=0?i:null}intersectPlane(e,t){const i=this.distanceToPlane(e);return i===null?null:this.at(i,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let i,n,r,a,o,c;const l=1/this.direction.x,h=1/this.direction.y,p=1/this.direction.z,f=this.origin;return l>=0?(i=(e.min.x-f.x)*l,n=(e.max.x-f.x)*l):(i=(e.max.x-f.x)*l,n=(e.min.x-f.x)*l),h>=0?(r=(e.min.y-f.y)*h,a=(e.max.y-f.y)*h):(r=(e.max.y-f.y)*h,a=(e.min.y-f.y)*h),i>a||r>n||((r>i||i!==i)&&(i=r),(a<n||n!==n)&&(n=a),p>=0?(o=(e.min.z-f.z)*p,c=(e.max.z-f.z)*p):(o=(e.max.z-f.z)*p,c=(e.min.z-f.z)*p),i>c||o>n)||((o>i||i!==i)&&(i=o),(c<n||n!==n)&&(n=c),n<0)?null:this.at(i>=0?i:n,t)}intersectsBox(e){return this.intersectBox(e,vt)!==null}intersectTriangle(e,t,i,n,r){Ln.subVectors(t,e),Xi.subVectors(i,e),Cn.crossVectors(Ln,Xi);let a=this.direction.dot(Cn),o;if(a>0){if(n)return null;o=1}else if(a<0)o=-1,a=-a;else return null;Ct.subVectors(this.origin,e);const c=o*this.direction.dot(Xi.crossVectors(Ct,Xi));if(c<0)return null;const l=o*this.direction.dot(Ln.cross(Ct));if(l<0||c+l>a)return null;const h=-o*Ct.dot(Cn);return h<0?null:this.at(h/a,r)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class Be{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(e,t,i,n,r,a,o,c,l,h,p,f,m,_,g,b){const u=this.elements;return u[0]=e,u[4]=t,u[8]=i,u[12]=n,u[1]=r,u[5]=a,u[9]=o,u[13]=c,u[2]=l,u[6]=h,u[10]=p,u[14]=f,u[3]=m,u[7]=_,u[11]=g,u[15]=b,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Be().fromArray(this.elements)}copy(e){const t=this.elements,i=e.elements;return t[0]=i[0],t[1]=i[1],t[2]=i[2],t[3]=i[3],t[4]=i[4],t[5]=i[5],t[6]=i[6],t[7]=i[7],t[8]=i[8],t[9]=i[9],t[10]=i[10],t[11]=i[11],t[12]=i[12],t[13]=i[13],t[14]=i[14],t[15]=i[15],this}copyPosition(e){const t=this.elements,i=e.elements;return t[12]=i[12],t[13]=i[13],t[14]=i[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,i){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(e,t,i){return this.set(e.x,t.x,i.x,0,e.y,t.y,i.y,0,e.z,t.z,i.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,i=e.elements,n=1/ti.setFromMatrixColumn(e,0).length(),r=1/ti.setFromMatrixColumn(e,1).length(),a=1/ti.setFromMatrixColumn(e,2).length();return t[0]=i[0]*n,t[1]=i[1]*n,t[2]=i[2]*n,t[3]=0,t[4]=i[4]*r,t[5]=i[5]*r,t[6]=i[6]*r,t[7]=0,t[8]=i[8]*a,t[9]=i[9]*a,t[10]=i[10]*a,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const t=this.elements,i=e.x,n=e.y,r=e.z,a=Math.cos(i),o=Math.sin(i),c=Math.cos(n),l=Math.sin(n),h=Math.cos(r),p=Math.sin(r);if(e.order==="XYZ"){const f=a*h,m=a*p,_=o*h,g=o*p;t[0]=c*h,t[4]=-c*p,t[8]=l,t[1]=m+_*l,t[5]=f-g*l,t[9]=-o*c,t[2]=g-f*l,t[6]=_+m*l,t[10]=a*c}else if(e.order==="YXZ"){const f=c*h,m=c*p,_=l*h,g=l*p;t[0]=f+g*o,t[4]=_*o-m,t[8]=a*l,t[1]=a*p,t[5]=a*h,t[9]=-o,t[2]=m*o-_,t[6]=g+f*o,t[10]=a*c}else if(e.order==="ZXY"){const f=c*h,m=c*p,_=l*h,g=l*p;t[0]=f-g*o,t[4]=-a*p,t[8]=_+m*o,t[1]=m+_*o,t[5]=a*h,t[9]=g-f*o,t[2]=-a*l,t[6]=o,t[10]=a*c}else if(e.order==="ZYX"){const f=a*h,m=a*p,_=o*h,g=o*p;t[0]=c*h,t[4]=_*l-m,t[8]=f*l+g,t[1]=c*p,t[5]=g*l+f,t[9]=m*l-_,t[2]=-l,t[6]=o*c,t[10]=a*c}else if(e.order==="YZX"){const f=a*c,m=a*l,_=o*c,g=o*l;t[0]=c*h,t[4]=g-f*p,t[8]=_*p+m,t[1]=p,t[5]=a*h,t[9]=-o*h,t[2]=-l*h,t[6]=m*p+_,t[10]=f-g*p}else if(e.order==="XZY"){const f=a*c,m=a*l,_=o*c,g=o*l;t[0]=c*h,t[4]=-p,t[8]=l*h,t[1]=f*p+g,t[5]=a*h,t[9]=m*p-_,t[2]=_*p-m,t[6]=o*h,t[10]=g*p+f}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(ko,e,Wo)}lookAt(e,t,i){const n=this.elements;return je.subVectors(e,t),je.lengthSq()===0&&(je.z=1),je.normalize(),Dt.crossVectors(i,je),Dt.lengthSq()===0&&(Math.abs(i.z)===1?je.x+=1e-4:je.z+=1e-4,je.normalize(),Dt.crossVectors(i,je)),Dt.normalize(),qi.crossVectors(je,Dt),n[0]=Dt.x,n[4]=qi.x,n[8]=je.x,n[1]=Dt.y,n[5]=qi.y,n[9]=je.y,n[2]=Dt.z,n[6]=qi.z,n[10]=je.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const i=e.elements,n=t.elements,r=this.elements,a=i[0],o=i[4],c=i[8],l=i[12],h=i[1],p=i[5],f=i[9],m=i[13],_=i[2],g=i[6],b=i[10],u=i[14],d=i[3],T=i[7],M=i[11],w=i[15],A=n[0],v=n[4],B=n[8],X=n[12],O=n[1],L=n[5],j=n[9],I=n[13],U=n[2],G=n[6],z=n[10],N=n[14],Y=n[3],ne=n[7],oe=n[11],te=n[15];return r[0]=a*A+o*O+c*U+l*Y,r[4]=a*v+o*L+c*G+l*ne,r[8]=a*B+o*j+c*z+l*oe,r[12]=a*X+o*I+c*N+l*te,r[1]=h*A+p*O+f*U+m*Y,r[5]=h*v+p*L+f*G+m*ne,r[9]=h*B+p*j+f*z+m*oe,r[13]=h*X+p*I+f*N+m*te,r[2]=_*A+g*O+b*U+u*Y,r[6]=_*v+g*L+b*G+u*ne,r[10]=_*B+g*j+b*z+u*oe,r[14]=_*X+g*I+b*N+u*te,r[3]=d*A+T*O+M*U+w*Y,r[7]=d*v+T*L+M*G+w*ne,r[11]=d*B+T*j+M*z+w*oe,r[15]=d*X+T*I+M*N+w*te,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],i=e[4],n=e[8],r=e[12],a=e[1],o=e[5],c=e[9],l=e[13],h=e[2],p=e[6],f=e[10],m=e[14],_=e[3],g=e[7],b=e[11],u=e[15];return _*(+r*c*p-n*l*p-r*o*f+i*l*f+n*o*m-i*c*m)+g*(+t*c*m-t*l*f+r*a*f-n*a*m+n*l*h-r*c*h)+b*(+t*l*p-t*o*m-r*a*p+i*a*m+r*o*h-i*l*h)+u*(-n*o*h-t*c*p+t*o*f+n*a*p-i*a*f+i*c*h)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,i){const n=this.elements;return e.isVector3?(n[12]=e.x,n[13]=e.y,n[14]=e.z):(n[12]=e,n[13]=t,n[14]=i),this}invert(){const e=this.elements,t=e[0],i=e[1],n=e[2],r=e[3],a=e[4],o=e[5],c=e[6],l=e[7],h=e[8],p=e[9],f=e[10],m=e[11],_=e[12],g=e[13],b=e[14],u=e[15],d=p*b*l-g*f*l+g*c*m-o*b*m-p*c*u+o*f*u,T=_*f*l-h*b*l-_*c*m+a*b*m+h*c*u-a*f*u,M=h*g*l-_*p*l+_*o*m-a*g*m-h*o*u+a*p*u,w=_*p*c-h*g*c-_*o*f+a*g*f+h*o*b-a*p*b,A=t*d+i*T+n*M+r*w;if(A===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const v=1/A;return e[0]=d*v,e[1]=(g*f*r-p*b*r-g*n*m+i*b*m+p*n*u-i*f*u)*v,e[2]=(o*b*r-g*c*r+g*n*l-i*b*l-o*n*u+i*c*u)*v,e[3]=(p*c*r-o*f*r-p*n*l+i*f*l+o*n*m-i*c*m)*v,e[4]=T*v,e[5]=(h*b*r-_*f*r+_*n*m-t*b*m-h*n*u+t*f*u)*v,e[6]=(_*c*r-a*b*r-_*n*l+t*b*l+a*n*u-t*c*u)*v,e[7]=(a*f*r-h*c*r+h*n*l-t*f*l-a*n*m+t*c*m)*v,e[8]=M*v,e[9]=(_*p*r-h*g*r-_*i*m+t*g*m+h*i*u-t*p*u)*v,e[10]=(a*g*r-_*o*r+_*i*l-t*g*l-a*i*u+t*o*u)*v,e[11]=(h*o*r-a*p*r-h*i*l+t*p*l+a*i*m-t*o*m)*v,e[12]=w*v,e[13]=(h*g*n-_*p*n+_*i*f-t*g*f-h*i*b+t*p*b)*v,e[14]=(_*o*n-a*g*n-_*i*c+t*g*c+a*i*b-t*o*b)*v,e[15]=(a*p*n-h*o*n+h*i*c-t*p*c-a*i*f+t*o*f)*v,this}scale(e){const t=this.elements,i=e.x,n=e.y,r=e.z;return t[0]*=i,t[4]*=n,t[8]*=r,t[1]*=i,t[5]*=n,t[9]*=r,t[2]*=i,t[6]*=n,t[10]*=r,t[3]*=i,t[7]*=n,t[11]*=r,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],i=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],n=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,i,n))}makeTranslation(e,t,i){return this.set(1,0,0,e,0,1,0,t,0,0,1,i,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),i=Math.sin(e);return this.set(1,0,0,0,0,t,-i,0,0,i,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),i=Math.sin(e);return this.set(t,0,i,0,0,1,0,0,-i,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),i=Math.sin(e);return this.set(t,-i,0,0,i,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const i=Math.cos(t),n=Math.sin(t),r=1-i,a=e.x,o=e.y,c=e.z,l=r*a,h=r*o;return this.set(l*a+i,l*o-n*c,l*c+n*o,0,l*o+n*c,h*o+i,h*c-n*a,0,l*c-n*o,h*c+n*a,r*c*c+i,0,0,0,0,1),this}makeScale(e,t,i){return this.set(e,0,0,0,0,t,0,0,0,0,i,0,0,0,0,1),this}makeShear(e,t,i,n,r,a){return this.set(1,i,r,0,e,1,a,0,t,n,1,0,0,0,0,1),this}compose(e,t,i){const n=this.elements,r=t._x,a=t._y,o=t._z,c=t._w,l=r+r,h=a+a,p=o+o,f=r*l,m=r*h,_=r*p,g=a*h,b=a*p,u=o*p,d=c*l,T=c*h,M=c*p,w=i.x,A=i.y,v=i.z;return n[0]=(1-(g+u))*w,n[1]=(m+M)*w,n[2]=(_-T)*w,n[3]=0,n[4]=(m-M)*A,n[5]=(1-(f+u))*A,n[6]=(b+d)*A,n[7]=0,n[8]=(_+T)*v,n[9]=(b-d)*v,n[10]=(1-(f+g))*v,n[11]=0,n[12]=e.x,n[13]=e.y,n[14]=e.z,n[15]=1,this}decompose(e,t,i){const n=this.elements;let r=ti.set(n[0],n[1],n[2]).length();const a=ti.set(n[4],n[5],n[6]).length(),o=ti.set(n[8],n[9],n[10]).length();this.determinant()<0&&(r=-r),e.x=n[12],e.y=n[13],e.z=n[14],rt.copy(this);const l=1/r,h=1/a,p=1/o;return rt.elements[0]*=l,rt.elements[1]*=l,rt.elements[2]*=l,rt.elements[4]*=h,rt.elements[5]*=h,rt.elements[6]*=h,rt.elements[8]*=p,rt.elements[9]*=p,rt.elements[10]*=p,t.setFromRotationMatrix(rt),i.x=r,i.y=a,i.z=o,this}makePerspective(e,t,i,n,r,a){a===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const o=this.elements,c=2*r/(t-e),l=2*r/(i-n),h=(t+e)/(t-e),p=(i+n)/(i-n),f=-(a+r)/(a-r),m=-2*a*r/(a-r);return o[0]=c,o[4]=0,o[8]=h,o[12]=0,o[1]=0,o[5]=l,o[9]=p,o[13]=0,o[2]=0,o[6]=0,o[10]=f,o[14]=m,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(e,t,i,n,r,a){const o=this.elements,c=1/(t-e),l=1/(i-n),h=1/(a-r),p=(t+e)*c,f=(i+n)*l,m=(a+r)*h;return o[0]=2*c,o[4]=0,o[8]=0,o[12]=-p,o[1]=0,o[5]=2*l,o[9]=0,o[13]=-f,o[2]=0,o[6]=0,o[10]=-2*h,o[14]=-m,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(e){const t=this.elements,i=e.elements;for(let n=0;n<16;n++)if(t[n]!==i[n])return!1;return!0}fromArray(e,t=0){for(let i=0;i<16;i++)this.elements[i]=e[i+t];return this}toArray(e=[],t=0){const i=this.elements;return e[t]=i[0],e[t+1]=i[1],e[t+2]=i[2],e[t+3]=i[3],e[t+4]=i[4],e[t+5]=i[5],e[t+6]=i[6],e[t+7]=i[7],e[t+8]=i[8],e[t+9]=i[9],e[t+10]=i[10],e[t+11]=i[11],e[t+12]=i[12],e[t+13]=i[13],e[t+14]=i[14],e[t+15]=i[15],e}}Be.prototype.isMatrix4=!0;const ti=new C,rt=new Be,ko=new C(0,0,0),Wo=new C(1,1,1),Dt=new C,qi=new C,je=new C,Hr=new Be,Xr=new yi;class bi{constructor(e=0,t=0,i=0,n=bi.DefaultOrder){this._x=e,this._y=t,this._z=i,this._order=n}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,i,n=this._order){return this._x=e,this._y=t,this._z=i,this._order=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,i=!0){const n=e.elements,r=n[0],a=n[4],o=n[8],c=n[1],l=n[5],h=n[9],p=n[2],f=n[6],m=n[10];switch(t){case"XYZ":this._y=Math.asin(ht(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-h,m),this._z=Math.atan2(-a,r)):(this._x=Math.atan2(f,l),this._z=0);break;case"YXZ":this._x=Math.asin(-ht(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(o,m),this._z=Math.atan2(c,l)):(this._y=Math.atan2(-p,r),this._z=0);break;case"ZXY":this._x=Math.asin(ht(f,-1,1)),Math.abs(f)<.9999999?(this._y=Math.atan2(-p,m),this._z=Math.atan2(-a,l)):(this._y=0,this._z=Math.atan2(c,r));break;case"ZYX":this._y=Math.asin(-ht(p,-1,1)),Math.abs(p)<.9999999?(this._x=Math.atan2(f,m),this._z=Math.atan2(c,r)):(this._x=0,this._z=Math.atan2(-a,l));break;case"YZX":this._z=Math.asin(ht(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(-h,l),this._y=Math.atan2(-p,r)):(this._x=0,this._y=Math.atan2(o,m));break;case"XZY":this._z=Math.asin(-ht(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(f,l),this._y=Math.atan2(o,r)):(this._x=Math.atan2(-h,m),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,i===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,i){return Hr.makeRotationFromQuaternion(e),this.setFromRotationMatrix(Hr,t,i)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return Xr.setFromEuler(this),this.setFromQuaternion(Xr,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}toVector3(e){return e?e.set(this._x,this._y,this._z):new C(this._x,this._y,this._z)}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}bi.prototype.isEuler=!0;bi.DefaultOrder="XYZ";bi.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class Ho{constructor(){this.mask=1}set(e){this.mask=1<<e|0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}}let Xo=0;const qr=new C,ii=new yi,Mt=new Be,Yi=new C,Di=new C,qo=new C,Yo=new yi,Yr=new C(1,0,0),Zr=new C(0,1,0),jr=new C(0,0,1),Zo={type:"added"},Jr={type:"removed"};class tt extends Mi{constructor(){super(),Object.defineProperty(this,"id",{value:Xo++}),this.uuid=Gi(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=tt.DefaultUp.clone();const e=new C,t=new bi,i=new yi,n=new C(1,1,1);function r(){i.setFromEuler(t,!1)}function a(){t.setFromQuaternion(i,void 0,!1)}t._onChange(r),i._onChange(a),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:i},scale:{configurable:!0,enumerable:!0,value:n},modelViewMatrix:{value:new Be},normalMatrix:{value:new lt}}),this.matrix=new Be,this.matrixWorld=new Be,this.matrixAutoUpdate=tt.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new Ho,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return ii.setFromAxisAngle(e,t),this.quaternion.multiply(ii),this}rotateOnWorldAxis(e,t){return ii.setFromAxisAngle(e,t),this.quaternion.premultiply(ii),this}rotateX(e){return this.rotateOnAxis(Yr,e)}rotateY(e){return this.rotateOnAxis(Zr,e)}rotateZ(e){return this.rotateOnAxis(jr,e)}translateOnAxis(e,t){return qr.copy(e).applyQuaternion(this.quaternion),this.position.add(qr.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(Yr,e)}translateY(e){return this.translateOnAxis(Zr,e)}translateZ(e){return this.translateOnAxis(jr,e)}localToWorld(e){return e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return e.applyMatrix4(Mt.copy(this.matrixWorld).invert())}lookAt(e,t,i){e.isVector3?Yi.copy(e):Yi.set(e,t,i);const n=this.parent;this.updateWorldMatrix(!0,!1),Di.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Mt.lookAt(Di,Yi,this.up):Mt.lookAt(Yi,Di,this.up),this.quaternion.setFromRotationMatrix(Mt),n&&(Mt.extractRotation(n.matrixWorld),ii.setFromRotationMatrix(Mt),this.quaternion.premultiply(ii.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(Zo)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let i=0;i<arguments.length;i++)this.remove(arguments[i]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(Jr)),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){for(let e=0;e<this.children.length;e++){const t=this.children[e];t.parent=null,t.dispatchEvent(Jr)}return this.children.length=0,this}attach(e){return this.updateWorldMatrix(!0,!1),Mt.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),Mt.multiply(e.parent.matrixWorld)),e.applyMatrix4(Mt),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let i=0,n=this.children.length;i<n;i++){const a=this.children[i].getObjectByProperty(e,t);if(a!==void 0)return a}}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Di,e,qo),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Di,Yo,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let i=0,n=t.length;i<n;i++)t[i].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let i=0,n=t.length;i<n;i++)t[i].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let i=0,n=t.length;i<n;i++)t[i].updateMatrixWorld(e)}updateWorldMatrix(e,t){const i=this.parent;if(e===!0&&i!==null&&i.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const n=this.children;for(let r=0,a=n.length;r<a;r++)n[r].updateWorldMatrix(!1,!0)}}toJSON(e){const t=e===void 0||typeof e=="string",i={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},i.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const n={};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.castShadow===!0&&(n.castShadow=!0),this.receiveShadow===!0&&(n.receiveShadow=!0),this.visible===!1&&(n.visible=!1),this.frustumCulled===!1&&(n.frustumCulled=!1),this.renderOrder!==0&&(n.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData),n.layers=this.layers.mask,n.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(n.matrixAutoUpdate=!1),this.isInstancedMesh&&(n.type="InstancedMesh",n.count=this.count,n.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(n.instanceColor=this.instanceColor.toJSON()));function r(o,c){return o[c.uuid]===void 0&&(o[c.uuid]=c.toJSON(e)),c.uuid}if(this.isScene)this.background&&(this.background.isColor?n.background=this.background.toJSON():this.background.isTexture&&(n.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&(n.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){n.geometry=r(e.geometries,this.geometry);const o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){const c=o.shapes;if(Array.isArray(c))for(let l=0,h=c.length;l<h;l++){const p=c[l];r(e.shapes,p)}else r(e.shapes,c)}}if(this.isSkinnedMesh&&(n.bindMode=this.bindMode,n.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(e.skeletons,this.skeleton),n.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const o=[];for(let c=0,l=this.material.length;c<l;c++)o.push(r(e.materials,this.material[c]));n.material=o}else n.material=r(e.materials,this.material);if(this.children.length>0){n.children=[];for(let o=0;o<this.children.length;o++)n.children.push(this.children[o].toJSON(e).object)}if(this.animations.length>0){n.animations=[];for(let o=0;o<this.animations.length;o++){const c=this.animations[o];n.animations.push(r(e.animations,c))}}if(t){const o=a(e.geometries),c=a(e.materials),l=a(e.textures),h=a(e.images),p=a(e.shapes),f=a(e.skeletons),m=a(e.animations);o.length>0&&(i.geometries=o),c.length>0&&(i.materials=c),l.length>0&&(i.textures=l),h.length>0&&(i.images=h),p.length>0&&(i.shapes=p),f.length>0&&(i.skeletons=f),m.length>0&&(i.animations=m)}return i.object=n,i;function a(o){const c=[];for(const l in o){const h=o[l];delete h.metadata,c.push(h)}return c}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let i=0;i<e.children.length;i++){const n=e.children[i];this.add(n.clone())}return this}}tt.DefaultUp=new C(0,1,0);tt.DefaultMatrixAutoUpdate=!0;tt.prototype.isObject3D=!0;const st=new C,yt=new C,Dn=new C,St=new C,ni=new C,ri=new C,$r=new C,Pn=new C,Rn=new C,Fn=new C;class bt{constructor(e=new C,t=new C,i=new C){this.a=e,this.b=t,this.c=i}static getNormal(e,t,i,n){n.subVectors(i,t),st.subVectors(e,t),n.cross(st);const r=n.lengthSq();return r>0?n.multiplyScalar(1/Math.sqrt(r)):n.set(0,0,0)}static getBarycoord(e,t,i,n,r){st.subVectors(n,t),yt.subVectors(i,t),Dn.subVectors(e,t);const a=st.dot(st),o=st.dot(yt),c=st.dot(Dn),l=yt.dot(yt),h=yt.dot(Dn),p=a*l-o*o;if(p===0)return r.set(-2,-1,-1);const f=1/p,m=(l*c-o*h)*f,_=(a*h-o*c)*f;return r.set(1-m-_,_,m)}static containsPoint(e,t,i,n){return this.getBarycoord(e,t,i,n,St),St.x>=0&&St.y>=0&&St.x+St.y<=1}static getUV(e,t,i,n,r,a,o,c){return this.getBarycoord(e,t,i,n,St),c.set(0,0),c.addScaledVector(r,St.x),c.addScaledVector(a,St.y),c.addScaledVector(o,St.z),c}static isFrontFacing(e,t,i,n){return st.subVectors(i,t),yt.subVectors(e,t),st.cross(yt).dot(n)<0}set(e,t,i){return this.a.copy(e),this.b.copy(t),this.c.copy(i),this}setFromPointsAndIndices(e,t,i,n){return this.a.copy(e[t]),this.b.copy(e[i]),this.c.copy(e[n]),this}setFromAttributeAndIndices(e,t,i,n){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,i),this.c.fromBufferAttribute(e,n),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return st.subVectors(this.c,this.b),yt.subVectors(this.a,this.b),st.cross(yt).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return bt.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return bt.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,i,n,r){return bt.getUV(e,this.a,this.b,this.c,t,i,n,r)}containsPoint(e){return bt.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return bt.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const i=this.a,n=this.b,r=this.c;let a,o;ni.subVectors(n,i),ri.subVectors(r,i),Pn.subVectors(e,i);const c=ni.dot(Pn),l=ri.dot(Pn);if(c<=0&&l<=0)return t.copy(i);Rn.subVectors(e,n);const h=ni.dot(Rn),p=ri.dot(Rn);if(h>=0&&p<=h)return t.copy(n);const f=c*p-h*l;if(f<=0&&c>=0&&h<=0)return a=c/(c-h),t.copy(i).addScaledVector(ni,a);Fn.subVectors(e,r);const m=ni.dot(Fn),_=ri.dot(Fn);if(_>=0&&m<=_)return t.copy(r);const g=m*l-c*_;if(g<=0&&l>=0&&_<=0)return o=l/(l-_),t.copy(i).addScaledVector(ri,o);const b=h*_-m*p;if(b<=0&&p-h>=0&&m-_>=0)return $r.subVectors(r,n),o=(p-h)/(p-h+(m-_)),t.copy(n).addScaledVector($r,o);const u=1/(b+g+f);return a=g*u,o=f*u,t.copy(i).addScaledVector(ni,a).addScaledVector(ri,o)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}let jo=0;class Oi extends Mi{constructor(){super(),Object.defineProperty(this,"id",{value:jo++}),this.uuid=Gi(),this.name="",this.type="Material",this.fog=!0,this.blending=Ni,this.side=Bi,this.vertexColors=!1,this.opacity=1,this.format=Xe,this.transparent=!1,this.blendSrc=Ss,this.blendDst=bs,this.blendEquation=fi,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=Zn,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=Fo,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=xn,this.stencilZFail=xn,this.stencilZPass=xn,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const i=e[t];if(i===void 0){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}if(t==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=i===oa;continue}const n=this[t];if(n===void 0){console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.");continue}n&&n.isColor?n.set(i):n&&n.isVector3&&i&&i.isVector3?n.copy(i):this[t]=i}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const i={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.color&&this.color.isColor&&(i.color=this.color.getHex()),this.roughness!==void 0&&(i.roughness=this.roughness),this.metalness!==void 0&&(i.metalness=this.metalness),this.sheen!==void 0&&(i.sheen=this.sheen),this.sheenTint&&this.sheenTint.isColor&&(i.sheenTint=this.sheenTint.getHex()),this.sheenRoughness!==void 0&&(i.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(i.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(i.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(i.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(i.specularIntensity=this.specularIntensity),this.specularTint&&this.specularTint.isColor&&(i.specularTint=this.specularTint.getHex()),this.shininess!==void 0&&(i.shininess=this.shininess),this.clearcoat!==void 0&&(i.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(i.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(i.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(i.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,i.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(i.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(i.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(i.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(i.lightMap=this.lightMap.toJSON(e).uuid,i.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(i.aoMap=this.aoMap.toJSON(e).uuid,i.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(i.bumpMap=this.bumpMap.toJSON(e).uuid,i.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(i.normalMap=this.normalMap.toJSON(e).uuid,i.normalMapType=this.normalMapType,i.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(i.displacementMap=this.displacementMap.toJSON(e).uuid,i.displacementScale=this.displacementScale,i.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(i.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(i.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(i.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(i.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(i.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularTintMap&&this.specularTintMap.isTexture&&(i.specularTintMap=this.specularTintMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(i.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(i.combine=this.combine)),this.envMapIntensity!==void 0&&(i.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(i.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(i.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(i.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(i.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(i.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(i.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(i.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&(i.attenuationDistance=this.attenuationDistance),this.attenuationTint!==void 0&&(i.attenuationTint=this.attenuationTint.getHex()),this.size!==void 0&&(i.size=this.size),this.shadowSide!==null&&(i.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(i.sizeAttenuation=this.sizeAttenuation),this.blending!==Ni&&(i.blending=this.blending),this.side!==Bi&&(i.side=this.side),this.vertexColors&&(i.vertexColors=!0),this.opacity<1&&(i.opacity=this.opacity),this.format!==Xe&&(i.format=this.format),this.transparent===!0&&(i.transparent=this.transparent),i.depthFunc=this.depthFunc,i.depthTest=this.depthTest,i.depthWrite=this.depthWrite,i.colorWrite=this.colorWrite,i.stencilWrite=this.stencilWrite,i.stencilWriteMask=this.stencilWriteMask,i.stencilFunc=this.stencilFunc,i.stencilRef=this.stencilRef,i.stencilFuncMask=this.stencilFuncMask,i.stencilFail=this.stencilFail,i.stencilZFail=this.stencilZFail,i.stencilZPass=this.stencilZPass,this.rotation&&this.rotation!==0&&(i.rotation=this.rotation),this.polygonOffset===!0&&(i.polygonOffset=!0),this.polygonOffsetFactor!==0&&(i.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(i.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&this.linewidth!==1&&(i.linewidth=this.linewidth),this.dashSize!==void 0&&(i.dashSize=this.dashSize),this.gapSize!==void 0&&(i.gapSize=this.gapSize),this.scale!==void 0&&(i.scale=this.scale),this.dithering===!0&&(i.dithering=!0),this.alphaTest>0&&(i.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(i.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(i.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(i.wireframe=this.wireframe),this.wireframeLinewidth>1&&(i.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(i.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(i.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(i.flatShading=this.flatShading),this.visible===!1&&(i.visible=!1),this.toneMapped===!1&&(i.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData);function n(r){const a=[];for(const o in r){const c=r[o];delete c.metadata,a.push(c)}return a}if(t){const r=n(e.textures),a=n(e.images);r.length>0&&(i.textures=r),a.length>0&&(i.images=a)}return i}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.fog=e.fog,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.format=e.format,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let i=null;if(t!==null){const n=t.length;i=new Array(n);for(let r=0;r!==n;++r)i[r]=t[r].clone()}return this.clippingPlanes=i,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}Oi.prototype.isMaterial=!0;const Ps={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},at={h:0,s:0,l:0},Zi={h:0,s:0,l:0};function In(s,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?s+(e-s)*6*t:t<1/2?e:t<2/3?s+(e-s)*6*(2/3-t):s}function zn(s){return s<.04045?s*.0773993808:Math.pow(s*.9478672986+.0521327014,2.4)}function Nn(s){return s<.0031308?s*12.92:1.055*Math.pow(s,.41666)-.055}class Ae{constructor(e,t,i){return t===void 0&&i===void 0?this.set(e):this.setRGB(e,t,i)}set(e){return e&&e.isColor?this.copy(e):typeof e=="number"?this.setHex(e):typeof e=="string"&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,this}setRGB(e,t,i){return this.r=e,this.g=t,this.b=i,this}setHSL(e,t,i){if(e=zo(e,1),t=ht(t,0,1),i=ht(i,0,1),t===0)this.r=this.g=this.b=i;else{const n=i<=.5?i*(1+t):i+t-i*t,r=2*i-n;this.r=In(r,n,e+1/3),this.g=In(r,n,e),this.b=In(r,n,e-1/3)}return this}setStyle(e){function t(n){n!==void 0&&parseFloat(n)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let i;if(i=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let n;const r=i[1],a=i[2];switch(r){case"rgb":case"rgba":if(n=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(255,parseInt(n[1],10))/255,this.g=Math.min(255,parseInt(n[2],10))/255,this.b=Math.min(255,parseInt(n[3],10))/255,t(n[4]),this;if(n=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(100,parseInt(n[1],10))/100,this.g=Math.min(100,parseInt(n[2],10))/100,this.b=Math.min(100,parseInt(n[3],10))/100,t(n[4]),this;break;case"hsl":case"hsla":if(n=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)){const o=parseFloat(n[1])/360,c=parseInt(n[2],10)/100,l=parseInt(n[3],10)/100;return t(n[4]),this.setHSL(o,c,l)}break}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(e)){const n=i[1],r=n.length;if(r===3)return this.r=parseInt(n.charAt(0)+n.charAt(0),16)/255,this.g=parseInt(n.charAt(1)+n.charAt(1),16)/255,this.b=parseInt(n.charAt(2)+n.charAt(2),16)/255,this;if(r===6)return this.r=parseInt(n.charAt(0)+n.charAt(1),16)/255,this.g=parseInt(n.charAt(2)+n.charAt(3),16)/255,this.b=parseInt(n.charAt(4)+n.charAt(5),16)/255,this}return e&&e.length>0?this.setColorName(e):this}setColorName(e){const t=Ps[e.toLowerCase()];return t!==void 0?this.setHex(t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copyGammaToLinear(e,t=2){return this.r=Math.pow(e.r,t),this.g=Math.pow(e.g,t),this.b=Math.pow(e.b,t),this}copyLinearToGamma(e,t=2){const i=t>0?1/t:1;return this.r=Math.pow(e.r,i),this.g=Math.pow(e.g,i),this.b=Math.pow(e.b,i),this}convertGammaToLinear(e){return this.copyGammaToLinear(this,e),this}convertLinearToGamma(e){return this.copyLinearToGamma(this,e),this}copySRGBToLinear(e){return this.r=zn(e.r),this.g=zn(e.g),this.b=zn(e.b),this}copyLinearToSRGB(e){return this.r=Nn(e.r),this.g=Nn(e.g),this.b=Nn(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(e){const t=this.r,i=this.g,n=this.b,r=Math.max(t,i,n),a=Math.min(t,i,n);let o,c;const l=(a+r)/2;if(a===r)o=0,c=0;else{const h=r-a;switch(c=l<=.5?h/(r+a):h/(2-r-a),r){case t:o=(i-n)/h+(i<n?6:0);break;case i:o=(n-t)/h+2;break;case n:o=(t-i)/h+4;break}o/=6}return e.h=o,e.s=c,e.l=l,e}getStyle(){return"rgb("+(this.r*255|0)+","+(this.g*255|0)+","+(this.b*255|0)+")"}offsetHSL(e,t,i){return this.getHSL(at),at.h+=e,at.s+=t,at.l+=i,this.setHSL(at.h,at.s,at.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,i){return this.r=e.r+(t.r-e.r)*i,this.g=e.g+(t.g-e.g)*i,this.b=e.b+(t.b-e.b)*i,this}lerpHSL(e,t){this.getHSL(at),e.getHSL(Zi);const i=Mn(at.h,Zi.h,t),n=Mn(at.s,Zi.s,t),r=Mn(at.l,Zi.l,t);return this.setHSL(i,n,r),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),e.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}Ae.NAMES=Ps;Ae.prototype.isColor=!0;Ae.prototype.r=1;Ae.prototype.g=1;Ae.prototype.b=1;class pn extends Oi{constructor(e){super(),this.type="MeshBasicMaterial",this.color=new Ae(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=ws,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this}}pn.prototype.isMeshBasicMaterial=!0;const Ce=new C,ji=new De;class et{constructor(e,t,i){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=i===!0,this.usage=Br,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this}copyAt(e,t,i){e*=this.itemSize,i*=t.itemSize;for(let n=0,r=this.itemSize;n<r;n++)this.array[e+n]=t.array[i+n];return this}copyArray(e){return this.array.set(e),this}copyColorsArray(e){const t=this.array;let i=0;for(let n=0,r=e.length;n<r;n++){let a=e[n];a===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",n),a=new Ae),t[i++]=a.r,t[i++]=a.g,t[i++]=a.b}return this}copyVector2sArray(e){const t=this.array;let i=0;for(let n=0,r=e.length;n<r;n++){let a=e[n];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",n),a=new De),t[i++]=a.x,t[i++]=a.y}return this}copyVector3sArray(e){const t=this.array;let i=0;for(let n=0,r=e.length;n<r;n++){let a=e[n];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",n),a=new C),t[i++]=a.x,t[i++]=a.y,t[i++]=a.z}return this}copyVector4sArray(e){const t=this.array;let i=0;for(let n=0,r=e.length;n<r;n++){let a=e[n];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",n),a=new He),t[i++]=a.x,t[i++]=a.y,t[i++]=a.z,t[i++]=a.w}return this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,i=this.count;t<i;t++)ji.fromBufferAttribute(this,t),ji.applyMatrix3(e),this.setXY(t,ji.x,ji.y);else if(this.itemSize===3)for(let t=0,i=this.count;t<i;t++)Ce.fromBufferAttribute(this,t),Ce.applyMatrix3(e),this.setXYZ(t,Ce.x,Ce.y,Ce.z);return this}applyMatrix4(e){for(let t=0,i=this.count;t<i;t++)Ce.x=this.getX(t),Ce.y=this.getY(t),Ce.z=this.getZ(t),Ce.applyMatrix4(e),this.setXYZ(t,Ce.x,Ce.y,Ce.z);return this}applyNormalMatrix(e){for(let t=0,i=this.count;t<i;t++)Ce.x=this.getX(t),Ce.y=this.getY(t),Ce.z=this.getZ(t),Ce.applyNormalMatrix(e),this.setXYZ(t,Ce.x,Ce.y,Ce.z);return this}transformDirection(e){for(let t=0,i=this.count;t<i;t++)Ce.x=this.getX(t),Ce.y=this.getY(t),Ce.z=this.getZ(t),Ce.transformDirection(e),this.setXYZ(t,Ce.x,Ce.y,Ce.z);return this}set(e,t=0){return this.array.set(e,t),this}getX(e){return this.array[e*this.itemSize]}setX(e,t){return this.array[e*this.itemSize]=t,this}getY(e){return this.array[e*this.itemSize+1]}setY(e,t){return this.array[e*this.itemSize+1]=t,this}getZ(e){return this.array[e*this.itemSize+2]}setZ(e,t){return this.array[e*this.itemSize+2]=t,this}getW(e){return this.array[e*this.itemSize+3]}setW(e,t){return this.array[e*this.itemSize+3]=t,this}setXY(e,t,i){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=i,this}setXYZ(e,t,i,n){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=i,this.array[e+2]=n,this}setXYZW(e,t,i,n,r){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=i,this.array[e+2]=n,this.array[e+3]=r,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==Br&&(e.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(e.updateRange=this.updateRange),e}}et.prototype.isBufferAttribute=!0;class Rs extends et{constructor(e,t,i){super(new Uint16Array(e),t,i)}}class Fs extends et{constructor(e,t,i){super(new Uint32Array(e),t,i)}}class Jo extends et{constructor(e,t,i){super(new Uint16Array(e),t,i)}}Jo.prototype.isFloat16BufferAttribute=!0;class mt extends et{constructor(e,t,i){super(new Float32Array(e),t,i)}}let $o=0;const Ke=new Be,Un=new tt,si=new C,Je=new Si,Pi=new Si,Ne=new C;class wt extends Mi{constructor(){super(),Object.defineProperty(this,"id",{value:$o++}),this.uuid=Gi(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(Cs(e)>65535?Fs:Rs)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,i=0){this.groups.push({start:e,count:t,materialIndex:i})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const i=this.attributes.normal;if(i!==void 0){const r=new lt().getNormalMatrix(e);i.applyNormalMatrix(r),i.needsUpdate=!0}const n=this.attributes.tangent;return n!==void 0&&(n.transformDirection(e),n.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return Ke.makeRotationFromQuaternion(e),this.applyMatrix4(Ke),this}rotateX(e){return Ke.makeRotationX(e),this.applyMatrix4(Ke),this}rotateY(e){return Ke.makeRotationY(e),this.applyMatrix4(Ke),this}rotateZ(e){return Ke.makeRotationZ(e),this.applyMatrix4(Ke),this}translate(e,t,i){return Ke.makeTranslation(e,t,i),this.applyMatrix4(Ke),this}scale(e,t,i){return Ke.makeScale(e,t,i),this.applyMatrix4(Ke),this}lookAt(e){return Un.lookAt(e),Un.updateMatrix(),this.applyMatrix4(Un.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(si).negate(),this.translate(si.x,si.y,si.z),this}setFromPoints(e){const t=[];for(let i=0,n=e.length;i<n;i++){const r=e[i];t.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new mt(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Si);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new C(-1/0,-1/0,-1/0),new C(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let i=0,n=t.length;i<n;i++){const r=t[i];Je.setFromBufferAttribute(r),this.morphTargetsRelative?(Ne.addVectors(this.boundingBox.min,Je.min),this.boundingBox.expandByPoint(Ne),Ne.addVectors(this.boundingBox.max,Je.max),this.boundingBox.expandByPoint(Ne)):(this.boundingBox.expandByPoint(Je.min),this.boundingBox.expandByPoint(Je.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new or);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new C,1/0);return}if(e){const i=this.boundingSphere.center;if(Je.setFromBufferAttribute(e),t)for(let r=0,a=t.length;r<a;r++){const o=t[r];Pi.setFromBufferAttribute(o),this.morphTargetsRelative?(Ne.addVectors(Je.min,Pi.min),Je.expandByPoint(Ne),Ne.addVectors(Je.max,Pi.max),Je.expandByPoint(Ne)):(Je.expandByPoint(Pi.min),Je.expandByPoint(Pi.max))}Je.getCenter(i);let n=0;for(let r=0,a=e.count;r<a;r++)Ne.fromBufferAttribute(e,r),n=Math.max(n,i.distanceToSquared(Ne));if(t)for(let r=0,a=t.length;r<a;r++){const o=t[r],c=this.morphTargetsRelative;for(let l=0,h=o.count;l<h;l++)Ne.fromBufferAttribute(o,l),c&&(si.fromBufferAttribute(e,l),Ne.add(si)),n=Math.max(n,i.distanceToSquared(Ne))}this.boundingSphere.radius=Math.sqrt(n),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const i=e.array,n=t.position.array,r=t.normal.array,a=t.uv.array,o=n.length/3;t.tangent===void 0&&this.setAttribute("tangent",new et(new Float32Array(4*o),4));const c=t.tangent.array,l=[],h=[];for(let O=0;O<o;O++)l[O]=new C,h[O]=new C;const p=new C,f=new C,m=new C,_=new De,g=new De,b=new De,u=new C,d=new C;function T(O,L,j){p.fromArray(n,O*3),f.fromArray(n,L*3),m.fromArray(n,j*3),_.fromArray(a,O*2),g.fromArray(a,L*2),b.fromArray(a,j*2),f.sub(p),m.sub(p),g.sub(_),b.sub(_);const I=1/(g.x*b.y-b.x*g.y);!isFinite(I)||(u.copy(f).multiplyScalar(b.y).addScaledVector(m,-g.y).multiplyScalar(I),d.copy(m).multiplyScalar(g.x).addScaledVector(f,-b.x).multiplyScalar(I),l[O].add(u),l[L].add(u),l[j].add(u),h[O].add(d),h[L].add(d),h[j].add(d))}let M=this.groups;M.length===0&&(M=[{start:0,count:i.length}]);for(let O=0,L=M.length;O<L;++O){const j=M[O],I=j.start,U=j.count;for(let G=I,z=I+U;G<z;G+=3)T(i[G+0],i[G+1],i[G+2])}const w=new C,A=new C,v=new C,B=new C;function X(O){v.fromArray(r,O*3),B.copy(v);const L=l[O];w.copy(L),w.sub(v.multiplyScalar(v.dot(L))).normalize(),A.crossVectors(B,L);const I=A.dot(h[O])<0?-1:1;c[O*4]=w.x,c[O*4+1]=w.y,c[O*4+2]=w.z,c[O*4+3]=I}for(let O=0,L=M.length;O<L;++O){const j=M[O],I=j.start,U=j.count;for(let G=I,z=I+U;G<z;G+=3)X(i[G+0]),X(i[G+1]),X(i[G+2])}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let i=this.getAttribute("normal");if(i===void 0)i=new et(new Float32Array(t.count*3),3),this.setAttribute("normal",i);else for(let f=0,m=i.count;f<m;f++)i.setXYZ(f,0,0,0);const n=new C,r=new C,a=new C,o=new C,c=new C,l=new C,h=new C,p=new C;if(e)for(let f=0,m=e.count;f<m;f+=3){const _=e.getX(f+0),g=e.getX(f+1),b=e.getX(f+2);n.fromBufferAttribute(t,_),r.fromBufferAttribute(t,g),a.fromBufferAttribute(t,b),h.subVectors(a,r),p.subVectors(n,r),h.cross(p),o.fromBufferAttribute(i,_),c.fromBufferAttribute(i,g),l.fromBufferAttribute(i,b),o.add(h),c.add(h),l.add(h),i.setXYZ(_,o.x,o.y,o.z),i.setXYZ(g,c.x,c.y,c.z),i.setXYZ(b,l.x,l.y,l.z)}else for(let f=0,m=t.count;f<m;f+=3)n.fromBufferAttribute(t,f+0),r.fromBufferAttribute(t,f+1),a.fromBufferAttribute(t,f+2),h.subVectors(a,r),p.subVectors(n,r),h.cross(p),i.setXYZ(f+0,h.x,h.y,h.z),i.setXYZ(f+1,h.x,h.y,h.z),i.setXYZ(f+2,h.x,h.y,h.z);this.normalizeNormals(),i.needsUpdate=!0}}merge(e,t){if(!(e&&e.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",e);return}t===void 0&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const i=this.attributes;for(const n in i){if(e.attributes[n]===void 0)continue;const a=i[n].array,o=e.attributes[n],c=o.array,l=o.itemSize*t,h=Math.min(c.length,a.length-l);for(let p=0,f=l;p<h;p++,f++)a[f]=c[p]}return this}normalizeNormals(){const e=this.attributes.normal;for(let t=0,i=e.count;t<i;t++)Ne.fromBufferAttribute(e,t),Ne.normalize(),e.setXYZ(t,Ne.x,Ne.y,Ne.z)}toNonIndexed(){function e(o,c){const l=o.array,h=o.itemSize,p=o.normalized,f=new l.constructor(c.length*h);let m=0,_=0;for(let g=0,b=c.length;g<b;g++){o.isInterleavedBufferAttribute?m=c[g]*o.data.stride+o.offset:m=c[g]*h;for(let u=0;u<h;u++)f[_++]=l[m++]}return new et(f,h,p)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new wt,i=this.index.array,n=this.attributes;for(const o in n){const c=n[o],l=e(c,i);t.setAttribute(o,l)}const r=this.morphAttributes;for(const o in r){const c=[],l=r[o];for(let h=0,p=l.length;h<p;h++){const f=l[h],m=e(f,i);c.push(m)}t.morphAttributes[o]=c}t.morphTargetsRelative=this.morphTargetsRelative;const a=this.groups;for(let o=0,c=a.length;o<c;o++){const l=a[o];t.addGroup(l.start,l.count,l.materialIndex)}return t}toJSON(){const e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const c=this.parameters;for(const l in c)c[l]!==void 0&&(e[l]=c[l]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const i=this.attributes;for(const c in i){const l=i[c];e.data.attributes[c]=l.toJSON(e.data)}const n={};let r=!1;for(const c in this.morphAttributes){const l=this.morphAttributes[c],h=[];for(let p=0,f=l.length;p<f;p++){const m=l[p];h.push(m.toJSON(e.data))}h.length>0&&(n[c]=h,r=!0)}r&&(e.data.morphAttributes=n,e.data.morphTargetsRelative=this.morphTargetsRelative);const a=this.groups;a.length>0&&(e.data.groups=JSON.parse(JSON.stringify(a)));const o=this.boundingSphere;return o!==null&&(e.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const i=e.index;i!==null&&this.setIndex(i.clone(t));const n=e.attributes;for(const l in n){const h=n[l];this.setAttribute(l,h.clone(t))}const r=e.morphAttributes;for(const l in r){const h=[],p=r[l];for(let f=0,m=p.length;f<m;f++)h.push(p[f].clone(t));this.morphAttributes[l]=h}this.morphTargetsRelative=e.morphTargetsRelative;const a=e.groups;for(let l=0,h=a.length;l<h;l++){const p=a[l];this.addGroup(p.start,p.count,p.materialIndex)}const o=e.boundingBox;o!==null&&(this.boundingBox=o.clone());const c=e.boundingSphere;return c!==null&&(this.boundingSphere=c.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,e.parameters!==void 0&&(this.parameters=Object.assign({},e.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}wt.prototype.isBufferGeometry=!0;const Qr=new Be,ai=new Vo,Bn=new or,Pt=new C,Rt=new C,Ft=new C,Gn=new C,On=new C,Vn=new C,Ji=new C,$i=new C,Qi=new C,Ki=new De,en=new De,tn=new De,kn=new C,nn=new C;class pt extends tt{constructor(e=new wt,t=new pn){super(),this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,i=Object.keys(t);if(i.length>0){const n=t[i[0]];if(n!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,a=n.length;r<a;r++){const o=n[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(e,t){const i=this.geometry,n=this.material,r=this.matrixWorld;if(n===void 0||(i.boundingSphere===null&&i.computeBoundingSphere(),Bn.copy(i.boundingSphere),Bn.applyMatrix4(r),e.ray.intersectsSphere(Bn)===!1)||(Qr.copy(r).invert(),ai.copy(e.ray).applyMatrix4(Qr),i.boundingBox!==null&&ai.intersectsBox(i.boundingBox)===!1))return;let a;if(i.isBufferGeometry){const o=i.index,c=i.attributes.position,l=i.morphAttributes.position,h=i.morphTargetsRelative,p=i.attributes.uv,f=i.attributes.uv2,m=i.groups,_=i.drawRange;if(o!==null)if(Array.isArray(n))for(let g=0,b=m.length;g<b;g++){const u=m[g],d=n[u.materialIndex],T=Math.max(u.start,_.start),M=Math.min(o.count,Math.min(u.start+u.count,_.start+_.count));for(let w=T,A=M;w<A;w+=3){const v=o.getX(w),B=o.getX(w+1),X=o.getX(w+2);a=rn(this,d,e,ai,c,l,h,p,f,v,B,X),a&&(a.faceIndex=Math.floor(w/3),a.face.materialIndex=u.materialIndex,t.push(a))}}else{const g=Math.max(0,_.start),b=Math.min(o.count,_.start+_.count);for(let u=g,d=b;u<d;u+=3){const T=o.getX(u),M=o.getX(u+1),w=o.getX(u+2);a=rn(this,n,e,ai,c,l,h,p,f,T,M,w),a&&(a.faceIndex=Math.floor(u/3),t.push(a))}}else if(c!==void 0)if(Array.isArray(n))for(let g=0,b=m.length;g<b;g++){const u=m[g],d=n[u.materialIndex],T=Math.max(u.start,_.start),M=Math.min(c.count,Math.min(u.start+u.count,_.start+_.count));for(let w=T,A=M;w<A;w+=3){const v=w,B=w+1,X=w+2;a=rn(this,d,e,ai,c,l,h,p,f,v,B,X),a&&(a.faceIndex=Math.floor(w/3),a.face.materialIndex=u.materialIndex,t.push(a))}}else{const g=Math.max(0,_.start),b=Math.min(c.count,_.start+_.count);for(let u=g,d=b;u<d;u+=3){const T=u,M=u+1,w=u+2;a=rn(this,n,e,ai,c,l,h,p,f,T,M,w),a&&(a.faceIndex=Math.floor(u/3),t.push(a))}}}else i.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}pt.prototype.isMesh=!0;function Qo(s,e,t,i,n,r,a,o){let c;if(e.side===ze?c=i.intersectTriangle(a,r,n,!0,o):c=i.intersectTriangle(n,r,a,e.side!==gi,o),c===null)return null;nn.copy(o),nn.applyMatrix4(s.matrixWorld);const l=t.ray.origin.distanceTo(nn);return l<t.near||l>t.far?null:{distance:l,point:nn.clone(),object:s}}function rn(s,e,t,i,n,r,a,o,c,l,h,p){Pt.fromBufferAttribute(n,l),Rt.fromBufferAttribute(n,h),Ft.fromBufferAttribute(n,p);const f=s.morphTargetInfluences;if(r&&f){Ji.set(0,0,0),$i.set(0,0,0),Qi.set(0,0,0);for(let _=0,g=r.length;_<g;_++){const b=f[_],u=r[_];b!==0&&(Gn.fromBufferAttribute(u,l),On.fromBufferAttribute(u,h),Vn.fromBufferAttribute(u,p),a?(Ji.addScaledVector(Gn,b),$i.addScaledVector(On,b),Qi.addScaledVector(Vn,b)):(Ji.addScaledVector(Gn.sub(Pt),b),$i.addScaledVector(On.sub(Rt),b),Qi.addScaledVector(Vn.sub(Ft),b)))}Pt.add(Ji),Rt.add($i),Ft.add(Qi)}s.isSkinnedMesh&&(s.boneTransform(l,Pt),s.boneTransform(h,Rt),s.boneTransform(p,Ft));const m=Qo(s,e,t,i,Pt,Rt,Ft,kn);if(m){o&&(Ki.fromBufferAttribute(o,l),en.fromBufferAttribute(o,h),tn.fromBufferAttribute(o,p),m.uv=bt.getUV(kn,Pt,Rt,Ft,Ki,en,tn,new De)),c&&(Ki.fromBufferAttribute(c,l),en.fromBufferAttribute(c,h),tn.fromBufferAttribute(c,p),m.uv2=bt.getUV(kn,Pt,Rt,Ft,Ki,en,tn,new De));const _={a:l,b:h,c:p,normal:new C,materialIndex:0};bt.getNormal(Pt,Rt,Ft,_.normal),m.face=_}return m}class wi extends wt{constructor(e=1,t=1,i=1,n=1,r=1,a=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:i,widthSegments:n,heightSegments:r,depthSegments:a};const o=this;n=Math.floor(n),r=Math.floor(r),a=Math.floor(a);const c=[],l=[],h=[],p=[];let f=0,m=0;_("z","y","x",-1,-1,i,t,e,a,r,0),_("z","y","x",1,-1,i,t,-e,a,r,1),_("x","z","y",1,1,e,i,t,n,a,2),_("x","z","y",1,-1,e,i,-t,n,a,3),_("x","y","z",1,-1,e,t,i,n,r,4),_("x","y","z",-1,-1,e,t,-i,n,r,5),this.setIndex(c),this.setAttribute("position",new mt(l,3)),this.setAttribute("normal",new mt(h,3)),this.setAttribute("uv",new mt(p,2));function _(g,b,u,d,T,M,w,A,v,B,X){const O=M/v,L=w/B,j=M/2,I=w/2,U=A/2,G=v+1,z=B+1;let N=0,Y=0;const ne=new C;for(let oe=0;oe<z;oe++){const te=oe*L-I;for(let xe=0;xe<G;xe++){const H=xe*O-j;ne[g]=H*d,ne[b]=te*T,ne[u]=U,l.push(ne.x,ne.y,ne.z),ne[g]=0,ne[b]=0,ne[u]=A>0?1:-1,h.push(ne.x,ne.y,ne.z),p.push(xe/v),p.push(1-oe/B),N+=1}}for(let oe=0;oe<B;oe++)for(let te=0;te<v;te++){const xe=f+te+G*oe,H=f+te+G*(oe+1),q=f+(te+1)+G*(oe+1),re=f+(te+1)+G*oe;c.push(xe,H,re),c.push(H,q,re),Y+=6}o.addGroup(m,Y,X),m+=Y,f+=N}}static fromJSON(e){return new wi(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function _i(s){const e={};for(const t in s){e[t]={};for(const i in s[t]){const n=s[t][i];n&&(n.isColor||n.isMatrix3||n.isMatrix4||n.isVector2||n.isVector3||n.isVector4||n.isTexture||n.isQuaternion)?e[t][i]=n.clone():Array.isArray(n)?e[t][i]=n.slice():e[t][i]=n}}return e}function Ve(s){const e={};for(let t=0;t<s.length;t++){const i=_i(s[t]);for(const n in i)e[n]=i[n]}return e}const Ko={clone:_i,merge:Ve};var el="void main(){gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}",tl="void main(){gl_FragColor=vec4(1.0,0.0,0.0,1.0);}";class xi extends Oi{constructor(e){super(),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=el,this.fragmentShader=tl,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&(e.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(e))}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=_i(e.uniforms),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const n in this.uniforms){const a=this.uniforms[n].value;a&&a.isTexture?t.uniforms[n]={type:"t",value:a.toJSON(e).uuid}:a&&a.isColor?t.uniforms[n]={type:"c",value:a.getHex()}:a&&a.isVector2?t.uniforms[n]={type:"v2",value:a.toArray()}:a&&a.isVector3?t.uniforms[n]={type:"v3",value:a.toArray()}:a&&a.isVector4?t.uniforms[n]={type:"v4",value:a.toArray()}:a&&a.isMatrix3?t.uniforms[n]={type:"m3",value:a.toArray()}:a&&a.isMatrix4?t.uniforms[n]={type:"m4",value:a.toArray()}:t.uniforms[n]={value:a}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const i={};for(const n in this.extensions)this.extensions[n]===!0&&(i[n]=!0);return Object.keys(i).length>0&&(t.extensions=i),t}}xi.prototype.isShaderMaterial=!0;class lr extends tt{constructor(){super(),this.type="Camera",this.matrixWorldInverse=new Be,this.projectionMatrix=new Be,this.projectionMatrixInverse=new Be}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}lr.prototype.isCamera=!0;class ot extends lr{constructor(e=50,t=1,i=.1,n=2e3){super(),this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=i,this.far=n,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=Or*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(vn*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return Or*2*Math.atan(Math.tan(vn*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,i,n,r,a){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=i,this.view.offsetY=n,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(vn*.5*this.fov)/this.zoom,i=2*t,n=this.aspect*i,r=-.5*n;const a=this.view;if(this.view!==null&&this.view.enabled){const c=a.fullWidth,l=a.fullHeight;r+=a.offsetX*n/c,t-=a.offsetY*i/l,n*=a.width/c,i*=a.height/l}const o=this.filmOffset;o!==0&&(r+=e*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+n,t,t-i,e,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}ot.prototype.isPerspectiveCamera=!0;const oi=90,li=1;class il extends tt{constructor(e,t,i){if(super(),this.type="CubeCamera",i.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=i;const n=new ot(oi,li,e,t);n.layers=this.layers,n.up.set(0,-1,0),n.lookAt(new C(1,0,0)),this.add(n);const r=new ot(oi,li,e,t);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new C(-1,0,0)),this.add(r);const a=new ot(oi,li,e,t);a.layers=this.layers,a.up.set(0,0,1),a.lookAt(new C(0,1,0)),this.add(a);const o=new ot(oi,li,e,t);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(new C(0,-1,0)),this.add(o);const c=new ot(oi,li,e,t);c.layers=this.layers,c.up.set(0,-1,0),c.lookAt(new C(0,0,1)),this.add(c);const l=new ot(oi,li,e,t);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new C(0,0,-1)),this.add(l)}update(e,t){this.parent===null&&this.updateMatrixWorld();const i=this.renderTarget,[n,r,a,o,c,l]=this.children,h=e.xr.enabled,p=e.getRenderTarget();e.xr.enabled=!1;const f=i.texture.generateMipmaps;i.texture.generateMipmaps=!1,e.setRenderTarget(i,0),e.render(t,n),e.setRenderTarget(i,1),e.render(t,r),e.setRenderTarget(i,2),e.render(t,a),e.setRenderTarget(i,3),e.render(t,o),e.setRenderTarget(i,4),e.render(t,c),i.texture.generateMipmaps=f,e.setRenderTarget(i,5),e.render(t,l),e.setRenderTarget(p),e.xr.enabled=h}}class cr extends ct{constructor(e,t,i,n,r,a,o,c,l,h){e=e!==void 0?e:[],t=t!==void 0?t:un,super(e,t,i,n,r,a,o,c,l,h),this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}cr.prototype.isCubeTexture=!0;class Is extends Ut{constructor(e,t,i){Number.isInteger(t)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),t=i),super(e,e,t),t=t||{},this.texture=new cr(void 0,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:ft,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.format=Xe,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const i={uniforms:{tEquirect:{value:null}},vertexShader:`varying vec3 vWorldDirection;vec3 transformDirection(in vec3 dir,in mat4 matrix){return normalize((matrix*vec4(dir,0.0)).xyz);}void main(){vWorldDirection=transformDirection(position,modelMatrix);
#include <begin_vertex>
#include <project_vertex>
}`,fragmentShader:`uniform sampler2D tEquirect;varying vec3 vWorldDirection;
#include <common>
void main(){vec3 direction=normalize(vWorldDirection);vec2 sampleUV=equirectUv(direction);gl_FragColor=texture2D(tEquirect,sampleUV);}`},n=new wi(5,5,5),r=new xi({name:"CubemapFromEquirect",uniforms:_i(i.uniforms),vertexShader:i.vertexShader,fragmentShader:i.fragmentShader,side:ze,blending:Nt});r.uniforms.tEquirect.value=t;const a=new pt(n,r),o=t.minFilter;return t.minFilter===fn&&(t.minFilter=ft),new il(1,10,this).update(e,a),t.minFilter=o,a.geometry.dispose(),a.material.dispose(),this}clear(e,t,i,n){const r=e.getRenderTarget();for(let a=0;a<6;a++)e.setRenderTarget(this,a),e.clear(t,i,n);e.setRenderTarget(r)}}Is.prototype.isWebGLCubeRenderTarget=!0;const Wn=new C,nl=new C,rl=new lt;class It{constructor(e=new C(1,0,0),t=0){this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,i,n){return this.normal.set(e,t,i),this.constant=n,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,i){const n=Wn.subVectors(i,t).cross(nl.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(n,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){const i=e.delta(Wn),n=this.normal.dot(i);if(n===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const r=-(e.start.dot(this.normal)+this.constant)/n;return r<0||r>1?null:t.copy(i).multiplyScalar(r).add(e.start)}intersectsLine(e){const t=this.distanceToPoint(e.start),i=this.distanceToPoint(e.end);return t<0&&i>0||i<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const i=t||rl.getNormalMatrix(e),n=this.coplanarPoint(Wn).applyMatrix4(e),r=this.normal.applyMatrix3(i).normalize();return this.constant=-n.dot(r),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}It.prototype.isPlane=!0;const ci=new or,sn=new C;class zs{constructor(e=new It,t=new It,i=new It,n=new It,r=new It,a=new It){this.planes=[e,t,i,n,r,a]}set(e,t,i,n,r,a){const o=this.planes;return o[0].copy(e),o[1].copy(t),o[2].copy(i),o[3].copy(n),o[4].copy(r),o[5].copy(a),this}copy(e){const t=this.planes;for(let i=0;i<6;i++)t[i].copy(e.planes[i]);return this}setFromProjectionMatrix(e){const t=this.planes,i=e.elements,n=i[0],r=i[1],a=i[2],o=i[3],c=i[4],l=i[5],h=i[6],p=i[7],f=i[8],m=i[9],_=i[10],g=i[11],b=i[12],u=i[13],d=i[14],T=i[15];return t[0].setComponents(o-n,p-c,g-f,T-b).normalize(),t[1].setComponents(o+n,p+c,g+f,T+b).normalize(),t[2].setComponents(o+r,p+l,g+m,T+u).normalize(),t[3].setComponents(o-r,p-l,g-m,T-u).normalize(),t[4].setComponents(o-a,p-h,g-_,T-d).normalize(),t[5].setComponents(o+a,p+h,g+_,T+d).normalize(),this}intersectsObject(e){const t=e.geometry;return t.boundingSphere===null&&t.computeBoundingSphere(),ci.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(ci)}intersectsSprite(e){return ci.center.set(0,0,0),ci.radius=.7071067811865476,ci.applyMatrix4(e.matrixWorld),this.intersectsSphere(ci)}intersectsSphere(e){const t=this.planes,i=e.center,n=-e.radius;for(let r=0;r<6;r++)if(t[r].distanceToPoint(i)<n)return!1;return!0}intersectsBox(e){const t=this.planes;for(let i=0;i<6;i++){const n=t[i];if(sn.x=n.normal.x>0?e.max.x:e.min.x,sn.y=n.normal.y>0?e.max.y:e.min.y,sn.z=n.normal.z>0?e.max.z:e.min.z,n.distanceToPoint(sn)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let i=0;i<6;i++)if(t[i].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function Ns(){let s=null,e=!1,t=null,i=null;function n(r,a){t(r,a),i=s.requestAnimationFrame(n)}return{start:function(){e!==!0&&t!==null&&(i=s.requestAnimationFrame(n),e=!0)},stop:function(){s.cancelAnimationFrame(i),e=!1},setAnimationLoop:function(r){t=r},setContext:function(r){s=r}}}function sl(s,e){const t=e.isWebGL2,i=new WeakMap;function n(l,h){const p=l.array,f=l.usage,m=s.createBuffer();s.bindBuffer(h,m),s.bufferData(h,p,f),l.onUploadCallback();let _=5126;return p instanceof Float32Array?_=5126:p instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):p instanceof Uint16Array?l.isFloat16BufferAttribute?t?_=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):_=5123:p instanceof Int16Array?_=5122:p instanceof Uint32Array?_=5125:p instanceof Int32Array?_=5124:p instanceof Int8Array?_=5120:(p instanceof Uint8Array||p instanceof Uint8ClampedArray)&&(_=5121),{buffer:m,type:_,bytesPerElement:p.BYTES_PER_ELEMENT,version:l.version}}function r(l,h,p){const f=h.array,m=h.updateRange;s.bindBuffer(p,l),m.count===-1?s.bufferSubData(p,0,f):(t?s.bufferSubData(p,m.offset*f.BYTES_PER_ELEMENT,f,m.offset,m.count):s.bufferSubData(p,m.offset*f.BYTES_PER_ELEMENT,f.subarray(m.offset,m.offset+m.count)),m.count=-1)}function a(l){return l.isInterleavedBufferAttribute&&(l=l.data),i.get(l)}function o(l){l.isInterleavedBufferAttribute&&(l=l.data);const h=i.get(l);h&&(s.deleteBuffer(h.buffer),i.delete(l))}function c(l,h){if(l.isGLBufferAttribute){const f=i.get(l);(!f||f.version<l.version)&&i.set(l,{buffer:l.buffer,type:l.type,bytesPerElement:l.elementSize,version:l.version});return}l.isInterleavedBufferAttribute&&(l=l.data);const p=i.get(l);p===void 0?i.set(l,n(l,h)):p.version<l.version&&(r(p.buffer,l,h),p.version=l.version)}return{get:a,remove:o,update:c}}class ur extends wt{constructor(e=1,t=1,i=1,n=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:i,heightSegments:n};const r=e/2,a=t/2,o=Math.floor(i),c=Math.floor(n),l=o+1,h=c+1,p=e/o,f=t/c,m=[],_=[],g=[],b=[];for(let u=0;u<h;u++){const d=u*f-a;for(let T=0;T<l;T++){const M=T*p-r;_.push(M,-d,0),g.push(0,0,1),b.push(T/o),b.push(1-u/c)}}for(let u=0;u<c;u++)for(let d=0;d<o;d++){const T=d+l*u,M=d+l*(u+1),w=d+1+l*(u+1),A=d+1+l*u;m.push(T,M,A),m.push(M,w,A)}this.setIndex(m),this.setAttribute("position",new mt(_,3)),this.setAttribute("normal",new mt(g,3)),this.setAttribute("uv",new mt(b,2))}static fromJSON(e){return new ur(e.width,e.height,e.widthSegments,e.heightSegments)}}var al=`#ifdef USE_ALPHAMAP
diffuseColor.a*=texture2D(alphaMap,vUv).g;
#endif`,ol=`#ifdef USE_ALPHAMAP
uniform sampler2D alphaMap;
#endif`,ll=`#ifdef USE_ALPHATEST
if(diffuseColor.a<alphaTest)discard;
#endif`,cl=`#ifdef USE_ALPHATEST
uniform float alphaTest;
#endif`,ul=`#ifdef USE_AOMAP
float ambientOcclusion=(texture2D(aoMap,vUv2).r-1.0)*aoMapIntensity+1.0;reflectedLight.indirectDiffuse*=ambientOcclusion;
#if defined(USE_ENVMAP)&&defined(STANDARD)
float dotNV=saturate(dot(geometry.normal,geometry.viewDir));reflectedLight.indirectSpecular*=computeSpecularOcclusion(dotNV,ambientOcclusion,material.roughness);
#endif
#endif`,hl=`#ifdef USE_AOMAP
uniform sampler2D aoMap;uniform float aoMapIntensity;
#endif`,dl="vec3 transformed=vec3(position);",fl=`vec3 objectNormal=vec3(normal);
#ifdef USE_TANGENT
vec3 objectTangent=vec3(tangent.xyz);
#endif`,pl=`vec3 BRDF_Lambert(const in vec3 diffuseColor){return RECIPROCAL_PI*diffuseColor;}vec3 F_Schlick(const in vec3 f0,const in float f90,const in float dotVH){float fresnel=exp2((-5.55473*dotVH-6.98316)*dotVH);return f0*(1.0-fresnel)+(f90*fresnel);}float V_GGX_SmithCorrelated(const in float alpha,const in float dotNL,const in float dotNV){float a2=pow2(alpha);float gv=dotNL*sqrt(a2+(1.0-a2)*pow2(dotNV));float gl=dotNV*sqrt(a2+(1.0-a2)*pow2(dotNL));return 0.5/max(gv+gl,EPSILON);}float D_GGX(const in float alpha,const in float dotNH){float a2=pow2(alpha);float denom=pow2(dotNH)*(a2-1.0)+1.0;return RECIPROCAL_PI*a2/pow2(denom);}vec3 BRDF_GGX(const in vec3 lightDir,const in vec3 viewDir,const in vec3 normal,const in vec3 f0,const in float f90,const in float roughness){float alpha=pow2(roughness);vec3 halfDir=normalize(lightDir+viewDir);float dotNL=saturate(dot(normal,lightDir));float dotNV=saturate(dot(normal,viewDir));float dotNH=saturate(dot(normal,halfDir));float dotVH=saturate(dot(viewDir,halfDir));vec3 F=F_Schlick(f0,f90,dotVH);float V=V_GGX_SmithCorrelated(alpha,dotNL,dotNV);float D=D_GGX(alpha,dotNH);return F*(V*D);}vec2 LTC_Uv(const in vec3 N,const in vec3 V,const in float roughness){const float LUT_SIZE=64.0;const float LUT_SCALE=(LUT_SIZE-1.0)/LUT_SIZE;const float LUT_BIAS=0.5/LUT_SIZE;float dotNV=saturate(dot(N,V));vec2 uv=vec2(roughness,sqrt(1.0-dotNV));uv=uv*LUT_SCALE+LUT_BIAS;return uv;}float LTC_ClippedSphereFormFactor(const in vec3 f){float l=length(f);return max((l*l+f.z)/(l+1.0),0.0);}vec3 LTC_EdgeVectorFormFactor(const in vec3 v1,const in vec3 v2){float x=dot(v1,v2);float y=abs(x);float a=0.8543985+(0.4965155+0.0145206*y)*y;float b=3.4175940+(4.1616724+y)*y;float v=a/b;float theta_sintheta=(x>0.0)?v:0.5*inversesqrt(max(1.0-x*x,1e-7))-v;return cross(v1,v2)*theta_sintheta;}vec3 LTC_Evaluate(const in vec3 N,const in vec3 V,const in vec3 P,const in mat3 mInv,const in vec3 rectCoords[4]){vec3 v1=rectCoords[1]-rectCoords[0];vec3 v2=rectCoords[3]-rectCoords[0];vec3 lightNormal=cross(v1,v2);if(dot(lightNormal,P-rectCoords[0])<0.0)return vec3(0.0);vec3 T1,T2;T1=normalize(V-N*dot(V,N));T2=-cross(N,T1);mat3 mat=mInv*transposeMat3(mat3(T1,T2,N));vec3 coords[4];coords[0]=mat*(rectCoords[0]-P);coords[1]=mat*(rectCoords[1]-P);coords[2]=mat*(rectCoords[2]-P);coords[3]=mat*(rectCoords[3]-P);coords[0]=normalize(coords[0]);coords[1]=normalize(coords[1]);coords[2]=normalize(coords[2]);coords[3]=normalize(coords[3]);vec3 vectorFormFactor=vec3(0.0);vectorFormFactor+=LTC_EdgeVectorFormFactor(coords[0],coords[1]);vectorFormFactor+=LTC_EdgeVectorFormFactor(coords[1],coords[2]);vectorFormFactor+=LTC_EdgeVectorFormFactor(coords[2],coords[3]);vectorFormFactor+=LTC_EdgeVectorFormFactor(coords[3],coords[0]);float result=LTC_ClippedSphereFormFactor(vectorFormFactor);return vec3(result);}float G_BlinnPhong_Implicit(){return 0.25;}float D_BlinnPhong(const in float shininess,const in float dotNH){return RECIPROCAL_PI*(shininess*0.5+1.0)*pow(dotNH,shininess);}vec3 BRDF_BlinnPhong(const in vec3 lightDir,const in vec3 viewDir,const in vec3 normal,const in vec3 specularColor,const in float shininess){vec3 halfDir=normalize(lightDir+viewDir);float dotNH=saturate(dot(normal,halfDir));float dotVH=saturate(dot(viewDir,halfDir));vec3 F=F_Schlick(specularColor,1.0,dotVH);float G=G_BlinnPhong_Implicit();float D=D_BlinnPhong(shininess,dotNH);return F*(G*D);}
#if defined(USE_SHEEN)
float D_Charlie(float roughness,float dotNH){float alpha=pow2(roughness);float invAlpha=1.0/alpha;float cos2h=dotNH*dotNH;float sin2h=max(1.0-cos2h,0.0078125);return(2.0+invAlpha)*pow(sin2h,invAlpha*0.5)/(2.0*PI);}float V_Neubelt(float dotNV,float dotNL){return saturate(1.0/(4.0*(dotNL+dotNV-dotNL*dotNV)));}vec3 BRDF_Sheen(const in vec3 lightDir,const in vec3 viewDir,const in vec3 normal,vec3 sheenTint,const in float sheenRoughness){vec3 halfDir=normalize(lightDir+viewDir);float dotNL=saturate(dot(normal,lightDir));float dotNV=saturate(dot(normal,viewDir));float dotNH=saturate(dot(normal,halfDir));float D=D_Charlie(sheenRoughness,dotNH);float V=V_Neubelt(dotNV,dotNL);return sheenTint*(D*V);}
#endif`,ml=`#ifdef USE_BUMPMAP
uniform sampler2D bumpMap;uniform float bumpScale;vec2 dHdxy_fwd(){vec2 dSTdx=dFdx(vUv);vec2 dSTdy=dFdy(vUv);float Hll=bumpScale*texture2D(bumpMap,vUv).x;float dBx=bumpScale*texture2D(bumpMap,vUv+dSTdx).x-Hll;float dBy=bumpScale*texture2D(bumpMap,vUv+dSTdy).x-Hll;return vec2(dBx,dBy);}vec3 perturbNormalArb(vec3 surf_pos,vec3 surf_norm,vec2 dHdxy,float faceDirection){vec3 vSigmaX=vec3(dFdx(surf_pos.x),dFdx(surf_pos.y),dFdx(surf_pos.z));vec3 vSigmaY=vec3(dFdy(surf_pos.x),dFdy(surf_pos.y),dFdy(surf_pos.z));vec3 vN=surf_norm;vec3 R1=cross(vSigmaY,vN);vec3 R2=cross(vN,vSigmaX);float fDet=dot(vSigmaX,R1)*faceDirection;vec3 vGrad=sign(fDet)*(dHdxy.x*R1+dHdxy.y*R2);return normalize(abs(fDet)*surf_norm-vGrad);}
#endif`,gl=`#if NUM_CLIPPING_PLANES>0
vec4 plane;
#pragma unroll_loop_start
for(int i=0;i<UNION_CLIPPING_PLANES;i++){plane=clippingPlanes[i];if(dot(vClipPosition,plane.xyz)>plane.w)discard;}
#pragma unroll_loop_end
#if UNION_CLIPPING_PLANES<NUM_CLIPPING_PLANES
bool clipped=true;
#pragma unroll_loop_start
for(int i=UNION_CLIPPING_PLANES;i<NUM_CLIPPING_PLANES;i++){plane=clippingPlanes[i];clipped=(dot(vClipPosition,plane.xyz)>plane.w)&&clipped;}
#pragma unroll_loop_end
if(clipped)discard;
#endif
#endif`,_l=`#if NUM_CLIPPING_PLANES>0
varying vec3 vClipPosition;uniform vec4 clippingPlanes[NUM_CLIPPING_PLANES];
#endif`,xl=`#if NUM_CLIPPING_PLANES>0
varying vec3 vClipPosition;
#endif`,vl=`#if NUM_CLIPPING_PLANES>0
vClipPosition=-mvPosition.xyz;
#endif`,Ml=`#if defined(USE_COLOR_ALPHA)
diffuseColor*=vColor;
#elif defined(USE_COLOR)
diffuseColor.rgb*=vColor;
#endif`,yl=`#if defined(USE_COLOR_ALPHA)
varying vec4 vColor;
#elif defined(USE_COLOR)
varying vec3 vColor;
#endif`,Sl=`#if defined(USE_COLOR_ALPHA)
varying vec4 vColor;
#elif defined(USE_COLOR)||defined(USE_INSTANCING_COLOR)
varying vec3 vColor;
#endif`,bl=`#if defined(USE_COLOR_ALPHA)
vColor=vec4(1.0);
#elif defined(USE_COLOR)||defined(USE_INSTANCING_COLOR)
vColor=vec3(1.0);
#endif
#ifdef USE_COLOR
vColor*=color;
#endif
#ifdef USE_INSTANCING_COLOR
vColor.xyz*=instanceColor.xyz;
#endif`,wl=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate(a)clamp(a,0.0,1.0)
#endif
#define whiteComplement(a)(1.0-saturate(a))
float pow2(const in float x){return x*x;}float pow3(const in float x){return x*x*x;}float pow4(const in float x){float x2=x*x;return x2*x2;}float max3(const in vec3 v){return max(max(v.x,v.y),v.z);}float average(const in vec3 color){return dot(color,vec3(0.3333));}highp float rand(const in vec2 uv){const highp float a=12.9898,b=78.233,c=43758.5453;highp float dt=dot(uv.xy,vec2(a,b)),sn=mod(dt,PI);return fract(sin(sn)*c);}
#ifdef HIGH_PRECISION
float precisionSafeLength(vec3 v){return length(v);}
#else
float precisionSafeLength(vec3 v){float maxComponent=max3(abs(v));return length(v/maxComponent)*maxComponent;}
#endif
struct IncidentLight{vec3 color;vec3 direction;bool visible;};struct ReflectedLight{vec3 directDiffuse;vec3 directSpecular;vec3 indirectDiffuse;vec3 indirectSpecular;};struct GeometricContext{vec3 position;vec3 normal;vec3 viewDir;
#ifdef USE_CLEARCOAT
vec3 clearcoatNormal;
#endif
};vec3 transformDirection(in vec3 dir,in mat4 matrix){return normalize((matrix*vec4(dir,0.0)).xyz);}vec3 inverseTransformDirection(in vec3 dir,in mat4 matrix){return normalize((vec4(dir,0.0)*matrix).xyz);}mat3 transposeMat3(const in mat3 m){mat3 tmp;tmp[0]=vec3(m[0].x,m[1].x,m[2].x);tmp[1]=vec3(m[0].y,m[1].y,m[2].y);tmp[2]=vec3(m[0].z,m[1].z,m[2].z);return tmp;}float linearToRelativeLuminance(const in vec3 color){vec3 weights=vec3(0.2126,0.7152,0.0722);return dot(weights,color.rgb);}bool isPerspectiveMatrix(mat4 m){return m[2][3]==-1.0;}vec2 equirectUv(in vec3 dir){float u=atan(dir.z,dir.x)*RECIPROCAL_PI2+0.5;float v=asin(clamp(dir.y,-1.0,1.0))*RECIPROCAL_PI+0.5;return vec2(u,v);}`,Tl=`#ifdef ENVMAP_TYPE_CUBE_UV
#define cubeUV_maxMipLevel 8.0
#define cubeUV_minMipLevel 4.0
#define cubeUV_maxTileSize 256.0
#define cubeUV_minTileSize 16.0
float getFace(vec3 direction){vec3 absDirection=abs(direction);float face=-1.0;if(absDirection.x>absDirection.z){if(absDirection.x>absDirection.y)face=direction.x>0.0?0.0:3.0;else face=direction.y>0.0?1.0:4.0;}else{if(absDirection.z>absDirection.y)face=direction.z>0.0?2.0:5.0;else face=direction.y>0.0?1.0:4.0;}return face;}vec2 getUV(vec3 direction,float face){vec2 uv;if(face==0.0){uv=vec2(direction.z,direction.y)/abs(direction.x);}else if(face==1.0){uv=vec2(-direction.x,-direction.z)/abs(direction.y);}else if(face==2.0){uv=vec2(-direction.x,direction.y)/abs(direction.z);}else if(face==3.0){uv=vec2(-direction.z,direction.y)/abs(direction.x);}else if(face==4.0){uv=vec2(-direction.x,direction.z)/abs(direction.y);}else{uv=vec2(direction.x,direction.y)/abs(direction.z);}return 0.5*(uv+1.0);}vec3 bilinearCubeUV(sampler2D envMap,vec3 direction,float mipInt){float face=getFace(direction);float filterInt=max(cubeUV_minMipLevel-mipInt,0.0);mipInt=max(mipInt,cubeUV_minMipLevel);float faceSize=exp2(mipInt);float texelSize=1.0/(3.0*cubeUV_maxTileSize);vec2 uv=getUV(direction,face)*(faceSize-1.0);vec2 f=fract(uv);uv+=0.5-f;if(face>2.0){uv.y+=faceSize;face-=3.0;}uv.x+=face*faceSize;if(mipInt<cubeUV_maxMipLevel){uv.y+=2.0*cubeUV_maxTileSize;}uv.y+=filterInt*2.0*cubeUV_minTileSize;uv.x+=3.0*max(0.0,cubeUV_maxTileSize-2.0*faceSize);uv*=texelSize;vec3 tl=envMapTexelToLinear(texture2D(envMap,uv)).rgb;uv.x+=texelSize;vec3 tr=envMapTexelToLinear(texture2D(envMap,uv)).rgb;uv.y+=texelSize;vec3 br=envMapTexelToLinear(texture2D(envMap,uv)).rgb;uv.x-=texelSize;vec3 bl=envMapTexelToLinear(texture2D(envMap,uv)).rgb;vec3 tm=mix(tl,tr,f.x);vec3 bm=mix(bl,br,f.x);return mix(tm,bm,f.y);}
#define r0 1.0
#define v0 0.339
#define m0-2.0
#define r1 0.8
#define v1 0.276
#define m1-1.0
#define r4 0.4
#define v4 0.046
#define m4 2.0
#define r5 0.305
#define v5 0.016
#define m5 3.0
#define r6 0.21
#define v6 0.0038
#define m6 4.0
float roughnessToMip(float roughness){float mip=0.0;if(roughness>=r1){mip=(r0-roughness)*(m1-m0)/(r0-r1)+m0;}else if(roughness>=r4){mip=(r1-roughness)*(m4-m1)/(r1-r4)+m1;}else if(roughness>=r5){mip=(r4-roughness)*(m5-m4)/(r4-r5)+m4;}else if(roughness>=r6){mip=(r5-roughness)*(m6-m5)/(r5-r6)+m5;}else{mip=-2.0*log2(1.16*roughness);}return mip;}vec4 textureCubeUV(sampler2D envMap,vec3 sampleDir,float roughness){float mip=clamp(roughnessToMip(roughness),m0,cubeUV_maxMipLevel);float mipF=fract(mip);float mipInt=floor(mip);vec3 color0=bilinearCubeUV(envMap,sampleDir,mipInt);if(mipF==0.0){return vec4(color0,1.0);}else{vec3 color1=bilinearCubeUV(envMap,sampleDir,mipInt+1.0);return vec4(mix(color0,color1,mipF),1.0);}}
#endif`,El=`vec3 transformedNormal=objectNormal;
#ifdef USE_INSTANCING
mat3 m=mat3(instanceMatrix);transformedNormal/=vec3(dot(m[0],m[0]),dot(m[1],m[1]),dot(m[2],m[2]));transformedNormal=m*transformedNormal;
#endif
transformedNormal=normalMatrix*transformedNormal;
#ifdef FLIP_SIDED
transformedNormal=-transformedNormal;
#endif
#ifdef USE_TANGENT
vec3 transformedTangent=(modelViewMatrix*vec4(objectTangent,0.0)).xyz;
#ifdef FLIP_SIDED
transformedTangent=-transformedTangent;
#endif
#endif`,Al=`#ifdef USE_DISPLACEMENTMAP
uniform sampler2D displacementMap;uniform float displacementScale;uniform float displacementBias;
#endif`,Ll=`#ifdef USE_DISPLACEMENTMAP
transformed+=normalize(objectNormal)*(texture2D(displacementMap,vUv).x*displacementScale+displacementBias);
#endif`,Cl=`#ifdef USE_EMISSIVEMAP
vec4 emissiveColor=texture2D(emissiveMap,vUv);emissiveColor.rgb=emissiveMapTexelToLinear(emissiveColor).rgb;totalEmissiveRadiance*=emissiveColor.rgb;
#endif`,Dl=`#ifdef USE_EMISSIVEMAP
uniform sampler2D emissiveMap;
#endif`,Pl="gl_FragColor=linearToOutputTexel(gl_FragColor);",Rl="vec4 LinearToLinear(in vec4 value){return value;}vec4 GammaToLinear(in vec4 value,in float gammaFactor){return vec4(pow(value.rgb,vec3(gammaFactor)),value.a);}vec4 LinearToGamma(in vec4 value,in float gammaFactor){return vec4(pow(value.rgb,vec3(1.0/gammaFactor)),value.a);}vec4 sRGBToLinear(in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}vec4 LinearTosRGB(in vec4 value){return vec4(mix(pow(value.rgb,vec3(0.41666))*1.055-vec3(0.055),value.rgb*12.92,vec3(lessThanEqual(value.rgb,vec3(0.0031308)))),value.a);}vec4 RGBEToLinear(in vec4 value){return vec4(value.rgb*exp2(value.a*255.0-128.0),1.0);}vec4 LinearToRGBE(in vec4 value){float maxComponent=max(max(value.r,value.g),value.b);float fExp=clamp(ceil(log2(maxComponent)),-128.0,127.0);return vec4(value.rgb/exp2(fExp),(fExp+128.0)/255.0);}vec4 RGBMToLinear(in vec4 value,in float maxRange){return vec4(value.rgb*value.a*maxRange,1.0);}vec4 LinearToRGBM(in vec4 value,in float maxRange){float maxRGB=max(value.r,max(value.g,value.b));float M=clamp(maxRGB/maxRange,0.0,1.0);M=ceil(M*255.0)/255.0;return vec4(value.rgb/(M*maxRange),M);}vec4 RGBDToLinear(in vec4 value,in float maxRange){return vec4(value.rgb*((maxRange/255.0)/value.a),1.0);}vec4 LinearToRGBD(in vec4 value,in float maxRange){float maxRGB=max(value.r,max(value.g,value.b));float D=max(maxRange/maxRGB,1.0);D=clamp(floor(D)/255.0,0.0,1.0);return vec4(value.rgb*(D*(255.0/maxRange)),D);}const mat3 cLogLuvM=mat3(0.2209,0.3390,0.4184,0.1138,0.6780,0.7319,0.0102,0.1130,0.2969);vec4 LinearToLogLuv(in vec4 value){vec3 Xp_Y_XYZp=cLogLuvM*value.rgb;Xp_Y_XYZp=max(Xp_Y_XYZp,vec3(1e-6,1e-6,1e-6));vec4 vResult;vResult.xy=Xp_Y_XYZp.xy/Xp_Y_XYZp.z;float Le=2.0*log2(Xp_Y_XYZp.y)+127.0;vResult.w=fract(Le);vResult.z=(Le-(floor(vResult.w*255.0))/255.0)/255.0;return vResult;}const mat3 cLogLuvInverseM=mat3(6.0014,-2.7008,-1.7996,-1.3320,3.1029,-5.7721,0.3008,-1.0882,5.6268);vec4 LogLuvToLinear(in vec4 value){float Le=value.z*255.0+value.w;vec3 Xp_Y_XYZp;Xp_Y_XYZp.y=exp2((Le-127.0)/2.0);Xp_Y_XYZp.z=Xp_Y_XYZp.y/value.y;Xp_Y_XYZp.x=value.x*Xp_Y_XYZp.z;vec3 vRGB=cLogLuvInverseM*Xp_Y_XYZp.rgb;return vec4(max(vRGB,0.0),1.0);}",Fl=`#ifdef USE_ENVMAP
#ifdef ENV_WORLDPOS
vec3 cameraToFrag;if(isOrthographic){cameraToFrag=normalize(vec3(-viewMatrix[0][2],-viewMatrix[1][2],-viewMatrix[2][2]));}else{cameraToFrag=normalize(vWorldPosition-cameraPosition);}vec3 worldNormal=inverseTransformDirection(normal,viewMatrix);
#ifdef ENVMAP_MODE_REFLECTION
vec3 reflectVec=reflect(cameraToFrag,worldNormal);
#else
vec3 reflectVec=refract(cameraToFrag,worldNormal,refractionRatio);
#endif
#else
vec3 reflectVec=vReflect;
#endif
#ifdef ENVMAP_TYPE_CUBE
vec4 envColor=textureCube(envMap,vec3(flipEnvMap*reflectVec.x,reflectVec.yz));envColor=envMapTexelToLinear(envColor);
#elif defined(ENVMAP_TYPE_CUBE_UV)
vec4 envColor=textureCubeUV(envMap,reflectVec,0.0);
#else
vec4 envColor=vec4(0.0);
#endif
#ifdef ENVMAP_BLENDING_MULTIPLY
outgoingLight=mix(outgoingLight,outgoingLight*envColor.xyz,specularStrength*reflectivity);
#elif defined(ENVMAP_BLENDING_MIX)
outgoingLight=mix(outgoingLight,envColor.xyz,specularStrength*reflectivity);
#elif defined(ENVMAP_BLENDING_ADD)
outgoingLight+=envColor.xyz*specularStrength*reflectivity;
#endif
#endif`,Il=`#ifdef USE_ENVMAP
uniform float envMapIntensity;uniform float flipEnvMap;uniform int maxMipLevel;
#ifdef ENVMAP_TYPE_CUBE
uniform samplerCube envMap;
#else
uniform sampler2D envMap;
#endif
#endif`,zl=`#ifdef USE_ENVMAP
uniform float reflectivity;
#if defined(USE_BUMPMAP)||defined(USE_NORMALMAP)||defined(PHONG)
#define ENV_WORLDPOS
#endif
#ifdef ENV_WORLDPOS
varying vec3 vWorldPosition;uniform float refractionRatio;
#else
varying vec3 vReflect;
#endif
#endif`,Nl=`#ifdef USE_ENVMAP
#if defined(USE_BUMPMAP)||defined(USE_NORMALMAP)||defined(PHONG)
#define ENV_WORLDPOS
#endif
#ifdef ENV_WORLDPOS
varying vec3 vWorldPosition;
#else
varying vec3 vReflect;uniform float refractionRatio;
#endif
#endif`,Ul=`#ifdef USE_ENVMAP
#ifdef ENV_WORLDPOS
vWorldPosition=worldPosition.xyz;
#else
vec3 cameraToVertex;if(isOrthographic){cameraToVertex=normalize(vec3(-viewMatrix[0][2],-viewMatrix[1][2],-viewMatrix[2][2]));}else{cameraToVertex=normalize(worldPosition.xyz-cameraPosition);}vec3 worldNormal=inverseTransformDirection(transformedNormal,viewMatrix);
#ifdef ENVMAP_MODE_REFLECTION
vReflect=reflect(cameraToVertex,worldNormal);
#else
vReflect=refract(cameraToVertex,worldNormal,refractionRatio);
#endif
#endif
#endif`,Bl=`#ifdef USE_FOG
vFogDepth=-mvPosition.z;
#endif`,Gl=`#ifdef USE_FOG
varying float vFogDepth;
#endif`,Ol=`#ifdef USE_FOG
#ifdef FOG_EXP2
float fogFactor=1.0-exp(-fogDensity*fogDensity*vFogDepth*vFogDepth);
#else
float fogFactor=smoothstep(fogNear,fogFar,vFogDepth);
#endif
gl_FragColor.rgb=mix(gl_FragColor.rgb,fogColor,fogFactor);
#endif`,Vl=`#ifdef USE_FOG
uniform vec3 fogColor;varying float vFogDepth;
#ifdef FOG_EXP2
uniform float fogDensity;
#else
uniform float fogNear;uniform float fogFar;
#endif
#endif`,kl=`#ifdef USE_GRADIENTMAP
uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance(vec3 normal,vec3 lightDirection){float dotNL=dot(normal,lightDirection);vec2 coord=vec2(dotNL*0.5+0.5,0.0);
#ifdef USE_GRADIENTMAP
return texture2D(gradientMap,coord).rgb;
#else
return(coord.x<0.7)?vec3(0.7):vec3(1.0);
#endif
}`,Wl=`#ifdef USE_LIGHTMAP
vec4 lightMapTexel=texture2D(lightMap,vUv2);vec3 lightMapIrradiance=lightMapTexelToLinear(lightMapTexel).rgb*lightMapIntensity;
#ifndef PHYSICALLY_CORRECT_LIGHTS
lightMapIrradiance*=PI;
#endif
reflectedLight.indirectDiffuse+=lightMapIrradiance;
#endif`,Hl=`#ifdef USE_LIGHTMAP
uniform sampler2D lightMap;uniform float lightMapIntensity;
#endif`,Xl=`vec3 diffuse=vec3(1.0);GeometricContext geometry;geometry.position=mvPosition.xyz;geometry.normal=normalize(transformedNormal);geometry.viewDir=(isOrthographic)?vec3(0,0,1):normalize(-mvPosition.xyz);GeometricContext backGeometry;backGeometry.position=geometry.position;backGeometry.normal=-geometry.normal;backGeometry.viewDir=geometry.viewDir;vLightFront=vec3(0.0);vIndirectFront=vec3(0.0);
#ifdef DOUBLE_SIDED
vLightBack=vec3(0.0);vIndirectBack=vec3(0.0);
#endif
IncidentLight directLight;float dotNL;vec3 directLightColor_Diffuse;vIndirectFront+=getAmbientLightIrradiance(ambientLightColor);vIndirectFront+=getLightProbeIrradiance(lightProbe,geometry.normal);
#ifdef DOUBLE_SIDED
vIndirectBack+=getAmbientLightIrradiance(ambientLightColor);vIndirectBack+=getLightProbeIrradiance(lightProbe,backGeometry.normal);
#endif
#if NUM_POINT_LIGHTS>0
#pragma unroll_loop_start
for(int i=0;i<NUM_POINT_LIGHTS;i++){getPointLightInfo(pointLights[i],geometry,directLight);dotNL=dot(geometry.normal,directLight.direction);directLightColor_Diffuse=directLight.color;vLightFront+=saturate(dotNL)*directLightColor_Diffuse;
#ifdef DOUBLE_SIDED
vLightBack+=saturate(-dotNL)*directLightColor_Diffuse;
#endif
}
#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS>0
#pragma unroll_loop_start
for(int i=0;i<NUM_SPOT_LIGHTS;i++){getSpotLightInfo(spotLights[i],geometry,directLight);dotNL=dot(geometry.normal,directLight.direction);directLightColor_Diffuse=directLight.color;vLightFront+=saturate(dotNL)*directLightColor_Diffuse;
#ifdef DOUBLE_SIDED
vLightBack+=saturate(-dotNL)*directLightColor_Diffuse;
#endif
}
#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS>0
#pragma unroll_loop_start
for(int i=0;i<NUM_DIR_LIGHTS;i++){getDirectionalLightInfo(directionalLights[i],geometry,directLight);dotNL=dot(geometry.normal,directLight.direction);directLightColor_Diffuse=directLight.color;vLightFront+=saturate(dotNL)*directLightColor_Diffuse;
#ifdef DOUBLE_SIDED
vLightBack+=saturate(-dotNL)*directLightColor_Diffuse;
#endif
}
#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS>0
#pragma unroll_loop_start
for(int i=0;i<NUM_HEMI_LIGHTS;i++){vIndirectFront+=getHemisphereLightIrradiance(hemisphereLights[i],geometry.normal);
#ifdef DOUBLE_SIDED
vIndirectBack+=getHemisphereLightIrradiance(hemisphereLights[i],backGeometry.normal);
#endif
}
#pragma unroll_loop_end
#endif`,ql=`uniform bool receiveShadow;uniform vec3 ambientLightColor;uniform vec3 lightProbe[9];vec3 shGetIrradianceAt(in vec3 normal,in vec3 shCoefficients[9]){float x=normal.x,y=normal.y,z=normal.z;vec3 result=shCoefficients[0]*0.886227;result+=shCoefficients[1]*2.0*0.511664*y;result+=shCoefficients[2]*2.0*0.511664*z;result+=shCoefficients[3]*2.0*0.511664*x;result+=shCoefficients[4]*2.0*0.429043*x*y;result+=shCoefficients[5]*2.0*0.429043*y*z;result+=shCoefficients[6]*(0.743125*z*z-0.247708);result+=shCoefficients[7]*2.0*0.429043*x*z;result+=shCoefficients[8]*0.429043*(x*x-y*y);return result;}vec3 getLightProbeIrradiance(const in vec3 lightProbe[9],const in vec3 normal){vec3 worldNormal=inverseTransformDirection(normal,viewMatrix);vec3 irradiance=shGetIrradianceAt(worldNormal,lightProbe);return irradiance;}vec3 getAmbientLightIrradiance(const in vec3 ambientLightColor){vec3 irradiance=ambientLightColor;return irradiance;}float getDistanceAttenuation(const in float lightDistance,const in float cutoffDistance,const in float decayExponent){
#if defined(PHYSICALLY_CORRECT_LIGHTS)
float distanceFalloff=1.0/max(pow(lightDistance,decayExponent),0.01);if(cutoffDistance>0.0){distanceFalloff*=pow2(saturate(1.0-pow4(lightDistance/cutoffDistance)));}return distanceFalloff;
#else
if(cutoffDistance>0.0&&decayExponent>0.0){return pow(saturate(-lightDistance/cutoffDistance+1.0),decayExponent);}return 1.0;
#endif
}float getSpotAttenuation(const in float coneCosine,const in float penumbraCosine,const in float angleCosine){return smoothstep(coneCosine,penumbraCosine,angleCosine);}
#if NUM_DIR_LIGHTS>0
struct DirectionalLight{vec3 direction;vec3 color;};uniform DirectionalLight directionalLights[NUM_DIR_LIGHTS];void getDirectionalLightInfo(const in DirectionalLight directionalLight,const in GeometricContext geometry,out IncidentLight light){light.color=directionalLight.color;light.direction=directionalLight.direction;light.visible=true;}
#endif
#if NUM_POINT_LIGHTS>0
struct PointLight{vec3 position;vec3 color;float distance;float decay;};uniform PointLight pointLights[NUM_POINT_LIGHTS];void getPointLightInfo(const in PointLight pointLight,const in GeometricContext geometry,out IncidentLight light){vec3 lVector=pointLight.position-geometry.position;light.direction=normalize(lVector);float lightDistance=length(lVector);light.color=pointLight.color;light.color*=getDistanceAttenuation(lightDistance,pointLight.distance,pointLight.decay);light.visible=(light.color!=vec3(0.0));}
#endif
#if NUM_SPOT_LIGHTS>0
struct SpotLight{vec3 position;vec3 direction;vec3 color;float distance;float decay;float coneCos;float penumbraCos;};uniform SpotLight spotLights[NUM_SPOT_LIGHTS];void getSpotLightInfo(const in SpotLight spotLight,const in GeometricContext geometry,out IncidentLight light){vec3 lVector=spotLight.position-geometry.position;light.direction=normalize(lVector);float angleCos=dot(light.direction,spotLight.direction);float spotAttenuation=getSpotAttenuation(spotLight.coneCos,spotLight.penumbraCos,angleCos);if(spotAttenuation>0.0){float lightDistance=length(lVector);light.color=spotLight.color*spotAttenuation;light.color*=getDistanceAttenuation(lightDistance,spotLight.distance,spotLight.decay);light.visible=(light.color!=vec3(0.0));}else{light.color=vec3(0.0);light.visible=false;}}
#endif
#if NUM_RECT_AREA_LIGHTS>0
struct RectAreaLight{vec3 color;vec3 position;vec3 halfWidth;vec3 halfHeight;};uniform sampler2D ltc_1;uniform sampler2D ltc_2;uniform RectAreaLight rectAreaLights[NUM_RECT_AREA_LIGHTS];
#endif
#if NUM_HEMI_LIGHTS>0
struct HemisphereLight{vec3 direction;vec3 skyColor;vec3 groundColor;};uniform HemisphereLight hemisphereLights[NUM_HEMI_LIGHTS];vec3 getHemisphereLightIrradiance(const in HemisphereLight hemiLight,const in vec3 normal){float dotNL=dot(normal,hemiLight.direction);float hemiDiffuseWeight=0.5*dotNL+0.5;vec3 irradiance=mix(hemiLight.groundColor,hemiLight.skyColor,hemiDiffuseWeight);return irradiance;}
#endif`,Yl=`#if defined(USE_ENVMAP)
#ifdef ENVMAP_MODE_REFRACTION
uniform float refractionRatio;
#endif
vec3 getIBLIrradiance(const in vec3 normal){
#if defined(ENVMAP_TYPE_CUBE_UV)
vec3 worldNormal=inverseTransformDirection(normal,viewMatrix);vec4 envMapColor=textureCubeUV(envMap,worldNormal,1.0);return PI*envMapColor.rgb*envMapIntensity;
#else
return vec3(0.0);
#endif
}vec3 getIBLRadiance(const in vec3 viewDir,const in vec3 normal,const in float roughness){
#if defined(ENVMAP_TYPE_CUBE_UV)
vec3 reflectVec;
#ifdef ENVMAP_MODE_REFLECTION
reflectVec=reflect(-viewDir,normal);reflectVec=normalize(mix(reflectVec,normal,roughness*roughness));
#else
reflectVec=refract(-viewDir,normal,refractionRatio);
#endif
reflectVec=inverseTransformDirection(reflectVec,viewMatrix);vec4 envMapColor=textureCubeUV(envMap,reflectVec,roughness);return envMapColor.rgb*envMapIntensity;
#else
return vec3(0.0);
#endif
}
#endif`,Zl="ToonMaterial material;material.diffuseColor=diffuseColor.rgb;",jl=`varying vec3 vViewPosition;struct ToonMaterial{vec3 diffuseColor;};void RE_Direct_Toon(const in IncidentLight directLight,const in GeometricContext geometry,const in ToonMaterial material,inout ReflectedLight reflectedLight){vec3 irradiance=getGradientIrradiance(geometry.normal,directLight.direction)*directLight.color;reflectedLight.directDiffuse+=irradiance*BRDF_Lambert(material.diffuseColor);}void RE_IndirectDiffuse_Toon(const in vec3 irradiance,const in GeometricContext geometry,const in ToonMaterial material,inout ReflectedLight reflectedLight){reflectedLight.indirectDiffuse+=irradiance*BRDF_Lambert(material.diffuseColor);}
#define RE_Direct RE_Direct_Toon
#define RE_IndirectDiffuse RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD(material)(0)`,Jl="BlinnPhongMaterial material;material.diffuseColor=diffuseColor.rgb;material.specularColor=specular;material.specularShininess=shininess;material.specularStrength=specularStrength;",$l=`varying vec3 vViewPosition;struct BlinnPhongMaterial{vec3 diffuseColor;vec3 specularColor;float specularShininess;float specularStrength;};void RE_Direct_BlinnPhong(const in IncidentLight directLight,const in GeometricContext geometry,const in BlinnPhongMaterial material,inout ReflectedLight reflectedLight){float dotNL=saturate(dot(geometry.normal,directLight.direction));vec3 irradiance=dotNL*directLight.color;reflectedLight.directDiffuse+=irradiance*BRDF_Lambert(material.diffuseColor);reflectedLight.directSpecular+=irradiance*BRDF_BlinnPhong(directLight.direction,geometry.viewDir,geometry.normal,material.specularColor,material.specularShininess)*material.specularStrength;}void RE_IndirectDiffuse_BlinnPhong(const in vec3 irradiance,const in GeometricContext geometry,const in BlinnPhongMaterial material,inout ReflectedLight reflectedLight){reflectedLight.indirectDiffuse+=irradiance*BRDF_Lambert(material.diffuseColor);}
#define RE_Direct RE_Direct_BlinnPhong
#define RE_IndirectDiffuse RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD(material)(0)`,Ql=`PhysicalMaterial material;material.diffuseColor=diffuseColor.rgb*(1.0-metalnessFactor);vec3 dxy=max(abs(dFdx(geometryNormal)),abs(dFdy(geometryNormal)));float geometryRoughness=max(max(dxy.x,dxy.y),dxy.z);material.roughness=max(roughnessFactor,0.0525);material.roughness+=geometryRoughness;material.roughness=min(material.roughness,1.0);
#ifdef IOR
#ifdef SPECULAR
float specularIntensityFactor=specularIntensity;vec3 specularTintFactor=specularTint;
#ifdef USE_SPECULARINTENSITYMAP
specularIntensityFactor*=texture2D(specularIntensityMap,vUv).a;
#endif
#ifdef USE_SPECULARTINTMAP
specularTintFactor*=specularTintMapTexelToLinear(texture2D(specularTintMap,vUv)).rgb;
#endif
material.specularF90=mix(specularIntensityFactor,1.0,metalnessFactor);
#else
float specularIntensityFactor=1.0;vec3 specularTintFactor=vec3(1.0);material.specularF90=1.0;
#endif
material.specularColor=mix(min(pow2((ior-1.0)/(ior+1.0))*specularTintFactor,vec3(1.0))*specularIntensityFactor,diffuseColor.rgb,metalnessFactor);
#else
material.specularColor=mix(vec3(0.04),diffuseColor.rgb,metalnessFactor);material.specularF90=1.0;
#endif
#ifdef USE_CLEARCOAT
material.clearcoat=clearcoat;material.clearcoatRoughness=clearcoatRoughness;material.clearcoatF0=vec3(0.04);material.clearcoatF90=1.0;
#ifdef USE_CLEARCOATMAP
material.clearcoat*=texture2D(clearcoatMap,vUv).x;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
material.clearcoatRoughness*=texture2D(clearcoatRoughnessMap,vUv).y;
#endif
material.clearcoat=saturate(material.clearcoat);material.clearcoatRoughness=max(material.clearcoatRoughness,0.0525);material.clearcoatRoughness+=geometryRoughness;material.clearcoatRoughness=min(material.clearcoatRoughness,1.0);
#endif
#ifdef USE_SHEEN
material.sheenTint=sheenTint;material.sheenRoughness=clamp(sheenRoughness,0.07,1.0);
#endif`,Kl=`struct PhysicalMaterial{vec3 diffuseColor;float roughness;vec3 specularColor;float specularF90;
#ifdef USE_CLEARCOAT
float clearcoat;float clearcoatRoughness;vec3 clearcoatF0;float clearcoatF90;
#endif
#ifdef USE_SHEEN
vec3 sheenTint;float sheenRoughness;
#endif
};vec3 clearcoatSpecular=vec3(0.0);vec2 DFGApprox(const in vec3 normal,const in vec3 viewDir,const in float roughness){float dotNV=saturate(dot(normal,viewDir));const vec4 c0=vec4(-1,-0.0275,-0.572,0.022);const vec4 c1=vec4(1,0.0425,1.04,-0.04);vec4 r=roughness*c0+c1;float a004=min(r.x*r.x,exp2(-9.28*dotNV))*r.x+r.y;vec2 fab=vec2(-1.04,1.04)*a004+r.zw;return fab;}vec3 EnvironmentBRDF(const in vec3 normal,const in vec3 viewDir,const in vec3 specularColor,const in float specularF90,const in float roughness){vec2 fab=DFGApprox(normal,viewDir,roughness);return specularColor*fab.x+specularF90*fab.y;}void computeMultiscattering(const in vec3 normal,const in vec3 viewDir,const in vec3 specularColor,const in float specularF90,const in float roughness,inout vec3 singleScatter,inout vec3 multiScatter){vec2 fab=DFGApprox(normal,viewDir,roughness);vec3 FssEss=specularColor*fab.x+specularF90*fab.y;float Ess=fab.x+fab.y;float Ems=1.0-Ess;vec3 Favg=specularColor+(1.0-specularColor)*0.047619;vec3 Fms=FssEss*Favg/(1.0-Ems*Favg);singleScatter+=FssEss;multiScatter+=Fms*Ems;}
#if NUM_RECT_AREA_LIGHTS>0
void RE_Direct_RectArea_Physical(const in RectAreaLight rectAreaLight,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){vec3 normal=geometry.normal;vec3 viewDir=geometry.viewDir;vec3 position=geometry.position;vec3 lightPos=rectAreaLight.position;vec3 halfWidth=rectAreaLight.halfWidth;vec3 halfHeight=rectAreaLight.halfHeight;vec3 lightColor=rectAreaLight.color;float roughness=material.roughness;vec3 rectCoords[4];rectCoords[0]=lightPos+halfWidth-halfHeight;rectCoords[1]=lightPos-halfWidth-halfHeight;rectCoords[2]=lightPos-halfWidth+halfHeight;rectCoords[3]=lightPos+halfWidth+halfHeight;vec2 uv=LTC_Uv(normal,viewDir,roughness);vec4 t1=texture2D(ltc_1,uv);vec4 t2=texture2D(ltc_2,uv);mat3 mInv=mat3(vec3(t1.x,0,t1.y),vec3(0,1,0),vec3(t1.z,0,t1.w));vec3 fresnel=(material.specularColor*t2.x+(vec3(1.0)-material.specularColor)*t2.y);reflectedLight.directSpecular+=lightColor*fresnel*LTC_Evaluate(normal,viewDir,position,mInv,rectCoords);reflectedLight.directDiffuse+=lightColor*material.diffuseColor*LTC_Evaluate(normal,viewDir,position,mat3(1.0),rectCoords);}
#endif
void RE_Direct_Physical(const in IncidentLight directLight,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){float dotNL=saturate(dot(geometry.normal,directLight.direction));vec3 irradiance=dotNL*directLight.color;
#ifdef USE_CLEARCOAT
float dotNLcc=saturate(dot(geometry.clearcoatNormal,directLight.direction));vec3 ccIrradiance=dotNLcc*directLight.color;clearcoatSpecular+=ccIrradiance*BRDF_GGX(directLight.direction,geometry.viewDir,geometry.clearcoatNormal,material.clearcoatF0,material.clearcoatF90,material.clearcoatRoughness);
#endif
#ifdef USE_SHEEN
reflectedLight.directSpecular+=irradiance*BRDF_Sheen(directLight.direction,geometry.viewDir,geometry.normal,material.sheenTint,material.sheenRoughness);
#endif
reflectedLight.directSpecular+=irradiance*BRDF_GGX(directLight.direction,geometry.viewDir,geometry.normal,material.specularColor,material.specularF90,material.roughness);reflectedLight.directDiffuse+=irradiance*BRDF_Lambert(material.diffuseColor);}void RE_IndirectDiffuse_Physical(const in vec3 irradiance,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){reflectedLight.indirectDiffuse+=irradiance*BRDF_Lambert(material.diffuseColor);}void RE_IndirectSpecular_Physical(const in vec3 radiance,const in vec3 irradiance,const in vec3 clearcoatRadiance,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){
#ifdef USE_CLEARCOAT
clearcoatSpecular+=clearcoatRadiance*EnvironmentBRDF(geometry.clearcoatNormal,geometry.viewDir,material.clearcoatF0,material.clearcoatF90,material.clearcoatRoughness);
#endif
vec3 singleScattering=vec3(0.0);vec3 multiScattering=vec3(0.0);vec3 cosineWeightedIrradiance=irradiance*RECIPROCAL_PI;computeMultiscattering(geometry.normal,geometry.viewDir,material.specularColor,material.specularF90,material.roughness,singleScattering,multiScattering);vec3 diffuse=material.diffuseColor*(1.0-(singleScattering+multiScattering));reflectedLight.indirectSpecular+=radiance*singleScattering;reflectedLight.indirectSpecular+=multiScattering*cosineWeightedIrradiance;reflectedLight.indirectDiffuse+=diffuse*cosineWeightedIrradiance;}
#define RE_Direct RE_Direct_Physical
#define RE_Direct_RectArea RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular RE_IndirectSpecular_Physical
float computeSpecularOcclusion(const in float dotNV,const in float ambientOcclusion,const in float roughness){return saturate(pow(dotNV+ambientOcclusion,exp2(-16.0*roughness-1.0))-1.0+ambientOcclusion);}`,ec=`GeometricContext geometry;geometry.position=-vViewPosition;geometry.normal=normal;geometry.viewDir=(isOrthographic)?vec3(0,0,1):normalize(vViewPosition);
#ifdef USE_CLEARCOAT
geometry.clearcoatNormal=clearcoatNormal;
#endif
IncidentLight directLight;
#if (NUM_POINT_LIGHTS>0)&&defined(RE_Direct)
PointLight pointLight;
#if defined(USE_SHADOWMAP)&&NUM_POINT_LIGHT_SHADOWS>0
PointLightShadow pointLightShadow;
#endif
#pragma unroll_loop_start
for(int i=0;i<NUM_POINT_LIGHTS;i++){pointLight=pointLights[i];getPointLightInfo(pointLight,geometry,directLight);
#if defined(USE_SHADOWMAP)&&(UNROLLED_LOOP_INDEX<NUM_POINT_LIGHT_SHADOWS)
pointLightShadow=pointLightShadows[i];directLight.color*=all(bvec2(directLight.visible,receiveShadow))?getPointShadow(pointShadowMap[i],pointLightShadow.shadowMapSize,pointLightShadow.shadowBias,pointLightShadow.shadowRadius,vPointShadowCoord[i],pointLightShadow.shadowCameraNear,pointLightShadow.shadowCameraFar):1.0;
#endif
RE_Direct(directLight,geometry,material,reflectedLight);}
#pragma unroll_loop_end
#endif
#if (NUM_SPOT_LIGHTS>0)&&defined(RE_Direct)
SpotLight spotLight;
#if defined(USE_SHADOWMAP)&&NUM_SPOT_LIGHT_SHADOWS>0
SpotLightShadow spotLightShadow;
#endif
#pragma unroll_loop_start
for(int i=0;i<NUM_SPOT_LIGHTS;i++){spotLight=spotLights[i];getSpotLightInfo(spotLight,geometry,directLight);
#if defined(USE_SHADOWMAP)&&(UNROLLED_LOOP_INDEX<NUM_SPOT_LIGHT_SHADOWS)
spotLightShadow=spotLightShadows[i];directLight.color*=all(bvec2(directLight.visible,receiveShadow))?getShadow(spotShadowMap[i],spotLightShadow.shadowMapSize,spotLightShadow.shadowBias,spotLightShadow.shadowRadius,vSpotShadowCoord[i]):1.0;
#endif
RE_Direct(directLight,geometry,material,reflectedLight);}
#pragma unroll_loop_end
#endif
#if (NUM_DIR_LIGHTS>0)&&defined(RE_Direct)
DirectionalLight directionalLight;
#if defined(USE_SHADOWMAP)&&NUM_DIR_LIGHT_SHADOWS>0
DirectionalLightShadow directionalLightShadow;
#endif
#pragma unroll_loop_start
for(int i=0;i<NUM_DIR_LIGHTS;i++){directionalLight=directionalLights[i];getDirectionalLightInfo(directionalLight,geometry,directLight);
#if defined(USE_SHADOWMAP)&&(UNROLLED_LOOP_INDEX<NUM_DIR_LIGHT_SHADOWS)
directionalLightShadow=directionalLightShadows[i];directLight.color*=all(bvec2(directLight.visible,receiveShadow))?getShadow(directionalShadowMap[i],directionalLightShadow.shadowMapSize,directionalLightShadow.shadowBias,directionalLightShadow.shadowRadius,vDirectionalShadowCoord[i]):1.0;
#endif
RE_Direct(directLight,geometry,material,reflectedLight);}
#pragma unroll_loop_end
#endif
#if (NUM_RECT_AREA_LIGHTS>0)&&defined(RE_Direct_RectArea)
RectAreaLight rectAreaLight;
#pragma unroll_loop_start
for(int i=0;i<NUM_RECT_AREA_LIGHTS;i++){rectAreaLight=rectAreaLights[i];RE_Direct_RectArea(rectAreaLight,geometry,material,reflectedLight);}
#pragma unroll_loop_end
#endif
#if defined(RE_IndirectDiffuse)
vec3 iblIrradiance=vec3(0.0);vec3 irradiance=getAmbientLightIrradiance(ambientLightColor);irradiance+=getLightProbeIrradiance(lightProbe,geometry.normal);
#if (NUM_HEMI_LIGHTS>0)
#pragma unroll_loop_start
for(int i=0;i<NUM_HEMI_LIGHTS;i++){irradiance+=getHemisphereLightIrradiance(hemisphereLights[i],geometry.normal);}
#pragma unroll_loop_end
#endif
#endif
#if defined(RE_IndirectSpecular)
vec3 radiance=vec3(0.0);vec3 clearcoatRadiance=vec3(0.0);
#endif`,tc=`#if defined(RE_IndirectDiffuse)
#ifdef USE_LIGHTMAP
vec4 lightMapTexel=texture2D(lightMap,vUv2);vec3 lightMapIrradiance=lightMapTexelToLinear(lightMapTexel).rgb*lightMapIntensity;
#ifndef PHYSICALLY_CORRECT_LIGHTS
lightMapIrradiance*=PI;
#endif
irradiance+=lightMapIrradiance;
#endif
#if defined(USE_ENVMAP)&&defined(STANDARD)&&defined(ENVMAP_TYPE_CUBE_UV)
iblIrradiance+=getIBLIrradiance(geometry.normal);
#endif
#endif
#if defined(USE_ENVMAP)&&defined(RE_IndirectSpecular)
radiance+=getIBLRadiance(geometry.viewDir,geometry.normal,material.roughness);
#ifdef USE_CLEARCOAT
clearcoatRadiance+=getIBLRadiance(geometry.viewDir,geometry.clearcoatNormal,material.clearcoatRoughness);
#endif
#endif`,ic=`#if defined(RE_IndirectDiffuse)
RE_IndirectDiffuse(irradiance,geometry,material,reflectedLight);
#endif
#if defined(RE_IndirectSpecular)
RE_IndirectSpecular(radiance,iblIrradiance,clearcoatRadiance,geometry,material,reflectedLight);
#endif`,nc=`#if defined(USE_LOGDEPTHBUF)&&defined(USE_LOGDEPTHBUF_EXT)
gl_FragDepthEXT=vIsPerspective==0.0?gl_FragCoord.z:log2(vFragDepth)*logDepthBufFC*0.5;
#endif`,rc=`#if defined(USE_LOGDEPTHBUF)&&defined(USE_LOGDEPTHBUF_EXT)
uniform float logDepthBufFC;varying float vFragDepth;varying float vIsPerspective;
#endif`,sc=`#ifdef USE_LOGDEPTHBUF
#ifdef USE_LOGDEPTHBUF_EXT
varying float vFragDepth;varying float vIsPerspective;
#else
uniform float logDepthBufFC;
#endif
#endif`,ac=`#ifdef USE_LOGDEPTHBUF
#ifdef USE_LOGDEPTHBUF_EXT
vFragDepth=1.0+gl_Position.w;vIsPerspective=float(isPerspectiveMatrix(projectionMatrix));
#else
if(isPerspectiveMatrix(projectionMatrix)){gl_Position.z=log2(max(EPSILON,gl_Position.w+1.0))*logDepthBufFC-1.0;gl_Position.z*=gl_Position.w;}
#endif
#endif`,oc=`#ifdef USE_MAP
vec4 texelColor=texture2D(map,vUv);texelColor=mapTexelToLinear(texelColor);diffuseColor*=texelColor;
#endif`,lc=`#ifdef USE_MAP
uniform sampler2D map;
#endif`,cc=`#if defined(USE_MAP)||defined(USE_ALPHAMAP)
vec2 uv=(uvTransform*vec3(gl_PointCoord.x,1.0-gl_PointCoord.y,1)).xy;
#endif
#ifdef USE_MAP
vec4 mapTexel=texture2D(map,uv);diffuseColor*=mapTexelToLinear(mapTexel);
#endif
#ifdef USE_ALPHAMAP
diffuseColor.a*=texture2D(alphaMap,uv).g;
#endif`,uc=`#if defined(USE_MAP)||defined(USE_ALPHAMAP)
uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
uniform sampler2D alphaMap;
#endif`,hc=`float metalnessFactor=metalness;
#ifdef USE_METALNESSMAP
vec4 texelMetalness=texture2D(metalnessMap,vUv);metalnessFactor*=texelMetalness.b;
#endif`,dc=`#ifdef USE_METALNESSMAP
uniform sampler2D metalnessMap;
#endif`,fc=`#ifdef USE_MORPHNORMALS
objectNormal*=morphTargetBaseInfluence;
#ifdef MORPHTARGETS_TEXTURE
for(int i=0;i<MORPHTARGETS_COUNT;i++){if(morphTargetInfluences[i]>0.0)objectNormal+=getMorph(gl_VertexID,i,1,2)*morphTargetInfluences[i];}
#else
objectNormal+=morphNormal0*morphTargetInfluences[0];objectNormal+=morphNormal1*morphTargetInfluences[1];objectNormal+=morphNormal2*morphTargetInfluences[2];objectNormal+=morphNormal3*morphTargetInfluences[3];
#endif
#endif`,pc=`#ifdef USE_MORPHTARGETS
uniform float morphTargetBaseInfluence;
#ifdef MORPHTARGETS_TEXTURE
uniform float morphTargetInfluences[MORPHTARGETS_COUNT];uniform sampler2DArray morphTargetsTexture;uniform vec2 morphTargetsTextureSize;vec3 getMorph(const in int vertexIndex,const in int morphTargetIndex,const in int offset,const in int stride){float texelIndex=float(vertexIndex*stride+offset);float y=floor(texelIndex/morphTargetsTextureSize.x);float x=texelIndex-y*morphTargetsTextureSize.x;vec3 morphUV=vec3((x+0.5)/morphTargetsTextureSize.x,y/morphTargetsTextureSize.y,morphTargetIndex);return texture(morphTargetsTexture,morphUV).xyz;}
#else
#ifndef USE_MORPHNORMALS
uniform float morphTargetInfluences[8];
#else
uniform float morphTargetInfluences[4];
#endif
#endif
#endif`,mc=`#ifdef USE_MORPHTARGETS
transformed*=morphTargetBaseInfluence;
#ifdef MORPHTARGETS_TEXTURE
for(int i=0;i<MORPHTARGETS_COUNT;i++){
#ifndef USE_MORPHNORMALS
if(morphTargetInfluences[i]>0.0)transformed+=getMorph(gl_VertexID,i,0,1)*morphTargetInfluences[i];
#else
if(morphTargetInfluences[i]>0.0)transformed+=getMorph(gl_VertexID,i,0,2)*morphTargetInfluences[i];
#endif
}
#else
transformed+=morphTarget0*morphTargetInfluences[0];transformed+=morphTarget1*morphTargetInfluences[1];transformed+=morphTarget2*morphTargetInfluences[2];transformed+=morphTarget3*morphTargetInfluences[3];
#ifndef USE_MORPHNORMALS
transformed+=morphTarget4*morphTargetInfluences[4];transformed+=morphTarget5*morphTargetInfluences[5];transformed+=morphTarget6*morphTargetInfluences[6];transformed+=morphTarget7*morphTargetInfluences[7];
#endif
#endif
#endif`,gc=`float faceDirection=gl_FrontFacing?1.0:-1.0;
#ifdef FLAT_SHADED
vec3 fdx=vec3(dFdx(vViewPosition.x),dFdx(vViewPosition.y),dFdx(vViewPosition.z));vec3 fdy=vec3(dFdy(vViewPosition.x),dFdy(vViewPosition.y),dFdy(vViewPosition.z));vec3 normal=normalize(cross(fdx,fdy));
#else
vec3 normal=normalize(vNormal);
#ifdef DOUBLE_SIDED
normal=normal*faceDirection;
#endif
#ifdef USE_TANGENT
vec3 tangent=normalize(vTangent);vec3 bitangent=normalize(vBitangent);
#ifdef DOUBLE_SIDED
tangent=tangent*faceDirection;bitangent=bitangent*faceDirection;
#endif
#if defined(TANGENTSPACE_NORMALMAP)||defined(USE_CLEARCOAT_NORMALMAP)
mat3 vTBN=mat3(tangent,bitangent,normal);
#endif
#endif
#endif
vec3 geometryNormal=normal;`,_c=`#ifdef OBJECTSPACE_NORMALMAP
normal=texture2D(normalMap,vUv).xyz*2.0-1.0;
#ifdef FLIP_SIDED
normal=-normal;
#endif
#ifdef DOUBLE_SIDED
normal=normal*faceDirection;
#endif
normal=normalize(normalMatrix*normal);
#elif defined(TANGENTSPACE_NORMALMAP)
vec3 mapN=texture2D(normalMap,vUv).xyz*2.0-1.0;mapN.xy*=normalScale;
#ifdef USE_TANGENT
normal=normalize(vTBN*mapN);
#else
normal=perturbNormal2Arb(-vViewPosition,normal,mapN,faceDirection);
#endif
#elif defined(USE_BUMPMAP)
normal=perturbNormalArb(-vViewPosition,normal,dHdxy_fwd(),faceDirection);
#endif`,xc=`#ifndef FLAT_SHADED
varying vec3 vNormal;
#ifdef USE_TANGENT
varying vec3 vTangent;varying vec3 vBitangent;
#endif
#endif`,vc=`#ifndef FLAT_SHADED
varying vec3 vNormal;
#ifdef USE_TANGENT
varying vec3 vTangent;varying vec3 vBitangent;
#endif
#endif`,Mc=`#ifndef FLAT_SHADED
vNormal=normalize(transformedNormal);
#ifdef USE_TANGENT
vTangent=normalize(transformedTangent);vBitangent=normalize(cross(vNormal,vTangent)*tangent.w);
#endif
#endif`,yc=`#ifdef USE_NORMALMAP
uniform sampler2D normalMap;uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
uniform mat3 normalMatrix;
#endif
#if !defined(USE_TANGENT)&&(defined(TANGENTSPACE_NORMALMAP)||defined(USE_CLEARCOAT_NORMALMAP))
vec3 perturbNormal2Arb(vec3 eye_pos,vec3 surf_norm,vec3 mapN,float faceDirection){vec3 q0=vec3(dFdx(eye_pos.x),dFdx(eye_pos.y),dFdx(eye_pos.z));vec3 q1=vec3(dFdy(eye_pos.x),dFdy(eye_pos.y),dFdy(eye_pos.z));vec2 st0=dFdx(vUv.st);vec2 st1=dFdy(vUv.st);vec3 N=surf_norm;vec3 q1perp=cross(q1,N);vec3 q0perp=cross(N,q0);vec3 T=q1perp*st0.x+q0perp*st1.x;vec3 B=q1perp*st0.y+q0perp*st1.y;float det=max(dot(T,T),dot(B,B));float scale=(det==0.0)?0.0:faceDirection*inversesqrt(det);return normalize(T*(mapN.x*scale)+B*(mapN.y*scale)+N*mapN.z);}
#endif`,Sc=`#ifdef USE_CLEARCOAT
vec3 clearcoatNormal=geometryNormal;
#endif`,bc=`#ifdef USE_CLEARCOAT_NORMALMAP
vec3 clearcoatMapN=texture2D(clearcoatNormalMap,vUv).xyz*2.0-1.0;clearcoatMapN.xy*=clearcoatNormalScale;
#ifdef USE_TANGENT
clearcoatNormal=normalize(vTBN*clearcoatMapN);
#else
clearcoatNormal=perturbNormal2Arb(-vViewPosition,clearcoatNormal,clearcoatMapN,faceDirection);
#endif
#endif`,wc=`#ifdef USE_CLEARCOATMAP
uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
uniform sampler2D clearcoatNormalMap;uniform vec2 clearcoatNormalScale;
#endif`,Tc=`#ifdef OPAQUE
diffuseColor.a=1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a*=transmissionAlpha+0.1;
#endif
gl_FragColor=vec4(outgoingLight,diffuseColor.a);`,Ec="vec3 packNormalToRGB(const in vec3 normal){return normalize(normal)*0.5+0.5;}vec3 unpackRGBToNormal(const in vec3 rgb){return 2.0*rgb.xyz-1.0;}const float PackUpscale=256./255.;const float UnpackDownscale=255./256.;const vec3 PackFactors=vec3(256.*256.*256.,256.*256.,256.);const vec4 UnpackFactors=UnpackDownscale/vec4(PackFactors,1.);const float ShiftRight8=1./256.;vec4 packDepthToRGBA(const in float v){vec4 r=vec4(fract(v*PackFactors),v);r.yzw-=r.xyz*ShiftRight8;return r*PackUpscale;}float unpackRGBAToDepth(const in vec4 v){return dot(v,UnpackFactors);}vec4 pack2HalfToRGBA(vec2 v){vec4 r=vec4(v.x,fract(v.x*255.0),v.y,fract(v.y*255.0));return vec4(r.x-r.y/255.0,r.y,r.z-r.w/255.0,r.w);}vec2 unpackRGBATo2Half(vec4 v){return vec2(v.x+(v.y/255.0),v.z+(v.w/255.0));}float viewZToOrthographicDepth(const in float viewZ,const in float near,const in float far){return(viewZ+near)/(near-far);}float orthographicDepthToViewZ(const in float linearClipZ,const in float near,const in float far){return linearClipZ*(near-far)-near;}float viewZToPerspectiveDepth(const in float viewZ,const in float near,const in float far){return((near+viewZ)*far)/((far-near)*viewZ);}float perspectiveDepthToViewZ(const in float invClipZ,const in float near,const in float far){return(near*far)/((far-near)*invClipZ-far);}",Ac=`#ifdef PREMULTIPLIED_ALPHA
gl_FragColor.rgb*=gl_FragColor.a;
#endif`,Lc=`vec4 mvPosition=vec4(transformed,1.0);
#ifdef USE_INSTANCING
mvPosition=instanceMatrix*mvPosition;
#endif
mvPosition=modelViewMatrix*mvPosition;gl_Position=projectionMatrix*mvPosition;`,Cc=`#ifdef DITHERING
gl_FragColor.rgb=dithering(gl_FragColor.rgb);
#endif`,Dc=`#ifdef DITHERING
vec3 dithering(vec3 color){float grid_position=rand(gl_FragCoord.xy);vec3 dither_shift_RGB=vec3(0.25/255.0,-0.25/255.0,0.25/255.0);dither_shift_RGB=mix(2.0*dither_shift_RGB,-2.0*dither_shift_RGB,grid_position);return color+dither_shift_RGB;}
#endif`,Pc=`float roughnessFactor=roughness;
#ifdef USE_ROUGHNESSMAP
vec4 texelRoughness=texture2D(roughnessMap,vUv);roughnessFactor*=texelRoughness.g;
#endif`,Rc=`#ifdef USE_ROUGHNESSMAP
uniform sampler2D roughnessMap;
#endif`,Fc=`#ifdef USE_SHADOWMAP
#if NUM_DIR_LIGHT_SHADOWS>0
uniform sampler2D directionalShadowMap[NUM_DIR_LIGHT_SHADOWS];varying vec4 vDirectionalShadowCoord[NUM_DIR_LIGHT_SHADOWS];struct DirectionalLightShadow{float shadowBias;float shadowNormalBias;float shadowRadius;vec2 shadowMapSize;};uniform DirectionalLightShadow directionalLightShadows[NUM_DIR_LIGHT_SHADOWS];
#endif
#if NUM_SPOT_LIGHT_SHADOWS>0
uniform sampler2D spotShadowMap[NUM_SPOT_LIGHT_SHADOWS];varying vec4 vSpotShadowCoord[NUM_SPOT_LIGHT_SHADOWS];struct SpotLightShadow{float shadowBias;float shadowNormalBias;float shadowRadius;vec2 shadowMapSize;};uniform SpotLightShadow spotLightShadows[NUM_SPOT_LIGHT_SHADOWS];
#endif
#if NUM_POINT_LIGHT_SHADOWS>0
uniform sampler2D pointShadowMap[NUM_POINT_LIGHT_SHADOWS];varying vec4 vPointShadowCoord[NUM_POINT_LIGHT_SHADOWS];struct PointLightShadow{float shadowBias;float shadowNormalBias;float shadowRadius;vec2 shadowMapSize;float shadowCameraNear;float shadowCameraFar;};uniform PointLightShadow pointLightShadows[NUM_POINT_LIGHT_SHADOWS];
#endif
float texture2DCompare(sampler2D depths,vec2 uv,float compare){return step(compare,unpackRGBAToDepth(texture2D(depths,uv)));}vec2 texture2DDistribution(sampler2D shadow,vec2 uv){return unpackRGBATo2Half(texture2D(shadow,uv));}float VSMShadow(sampler2D shadow,vec2 uv,float compare){float occlusion=1.0;vec2 distribution=texture2DDistribution(shadow,uv);float hard_shadow=step(compare,distribution.x);if(hard_shadow!=1.0){float distance=compare-distribution.x;float variance=max(0.00000,distribution.y*distribution.y);float softness_probability=variance/(variance+distance*distance);softness_probability=clamp((softness_probability-0.3)/(0.95-0.3),0.0,1.0);occlusion=clamp(max(hard_shadow,softness_probability),0.0,1.0);}return occlusion;}float getShadow(sampler2D shadowMap,vec2 shadowMapSize,float shadowBias,float shadowRadius,vec4 shadowCoord){float shadow=1.0;shadowCoord.xyz/=shadowCoord.w;shadowCoord.z+=shadowBias;bvec4 inFrustumVec=bvec4(shadowCoord.x>=0.0,shadowCoord.x<=1.0,shadowCoord.y>=0.0,shadowCoord.y<=1.0);bool inFrustum=all(inFrustumVec);bvec2 frustumTestVec=bvec2(inFrustum,shadowCoord.z<=1.0);bool frustumTest=all(frustumTestVec);if(frustumTest){
#if defined(SHADOWMAP_TYPE_PCF)
vec2 texelSize=vec2(1.0)/shadowMapSize;float dx0=-texelSize.x*shadowRadius;float dy0=-texelSize.y*shadowRadius;float dx1=+texelSize.x*shadowRadius;float dy1=+texelSize.y*shadowRadius;float dx2=dx0/2.0;float dy2=dy0/2.0;float dx3=dx1/2.0;float dy3=dy1/2.0;shadow=(texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx0,dy0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(0.0,dy0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx1,dy0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx2,dy2),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(0.0,dy2),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx3,dy2),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx0,0.0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx2,0.0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy,shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx3,0.0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx1,0.0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx2,dy3),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(0.0,dy3),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx3,dy3),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx0,dy1),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(0.0,dy1),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx1,dy1),shadowCoord.z))*(1.0/17.0);
#elif defined(SHADOWMAP_TYPE_PCF_SOFT)
vec2 texelSize=vec2(1.0)/shadowMapSize;float dx=texelSize.x;float dy=texelSize.y;vec2 uv=shadowCoord.xy;vec2 f=fract(uv*shadowMapSize+0.5);uv-=f*texelSize;shadow=(texture2DCompare(shadowMap,uv,shadowCoord.z)+texture2DCompare(shadowMap,uv+vec2(dx,0.0),shadowCoord.z)+texture2DCompare(shadowMap,uv+vec2(0.0,dy),shadowCoord.z)+texture2DCompare(shadowMap,uv+texelSize,shadowCoord.z)+mix(texture2DCompare(shadowMap,uv+vec2(-dx,0.0),shadowCoord.z),texture2DCompare(shadowMap,uv+vec2(2.0*dx,0.0),shadowCoord.z),f.x)+mix(texture2DCompare(shadowMap,uv+vec2(-dx,dy),shadowCoord.z),texture2DCompare(shadowMap,uv+vec2(2.0*dx,dy),shadowCoord.z),f.x)+mix(texture2DCompare(shadowMap,uv+vec2(0.0,-dy),shadowCoord.z),texture2DCompare(shadowMap,uv+vec2(0.0,2.0*dy),shadowCoord.z),f.y)+mix(texture2DCompare(shadowMap,uv+vec2(dx,-dy),shadowCoord.z),texture2DCompare(shadowMap,uv+vec2(dx,2.0*dy),shadowCoord.z),f.y)+mix(mix(texture2DCompare(shadowMap,uv+vec2(-dx,-dy),shadowCoord.z),texture2DCompare(shadowMap,uv+vec2(2.0*dx,-dy),shadowCoord.z),f.x),mix(texture2DCompare(shadowMap,uv+vec2(-dx,2.0*dy),shadowCoord.z),texture2DCompare(shadowMap,uv+vec2(2.0*dx,2.0*dy),shadowCoord.z),f.x),f.y))*(1.0/9.0);
#elif defined(SHADOWMAP_TYPE_VSM)
shadow=VSMShadow(shadowMap,shadowCoord.xy,shadowCoord.z);
#else
shadow=texture2DCompare(shadowMap,shadowCoord.xy,shadowCoord.z);
#endif
}return shadow;}vec2 cubeToUV(vec3 v,float texelSizeY){vec3 absV=abs(v);float scaleToCube=1.0/max(absV.x,max(absV.y,absV.z));absV*=scaleToCube;v*=scaleToCube*(1.0-2.0*texelSizeY);vec2 planar=v.xy;float almostATexel=1.5*texelSizeY;float almostOne=1.0-almostATexel;if(absV.z>=almostOne){if(v.z>0.0)planar.x=4.0-v.x;}else if(absV.x>=almostOne){float signX=sign(v.x);planar.x=v.z*signX+2.0*signX;}else if(absV.y>=almostOne){float signY=sign(v.y);planar.x=v.x+2.0*signY+2.0;planar.y=v.z*signY-2.0;}return vec2(0.125,0.25)*planar+vec2(0.375,0.75);}float getPointShadow(sampler2D shadowMap,vec2 shadowMapSize,float shadowBias,float shadowRadius,vec4 shadowCoord,float shadowCameraNear,float shadowCameraFar){vec2 texelSize=vec2(1.0)/(shadowMapSize*vec2(4.0,2.0));vec3 lightToPosition=shadowCoord.xyz;float dp=(length(lightToPosition)-shadowCameraNear)/(shadowCameraFar-shadowCameraNear);dp+=shadowBias;vec3 bd3D=normalize(lightToPosition);
#if defined(SHADOWMAP_TYPE_PCF)||defined(SHADOWMAP_TYPE_PCF_SOFT)||defined(SHADOWMAP_TYPE_VSM)
vec2 offset=vec2(-1,1)*shadowRadius*texelSize.y;return(texture2DCompare(shadowMap,cubeToUV(bd3D+offset.xyy,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.yyy,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.xyx,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.yyx,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.xxy,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.yxy,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.xxx,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.yxx,texelSize.y),dp))*(1.0/9.0);
#else
return texture2DCompare(shadowMap,cubeToUV(bd3D,texelSize.y),dp);
#endif
}
#endif`,Ic=`#ifdef USE_SHADOWMAP
#if NUM_DIR_LIGHT_SHADOWS>0
uniform mat4 directionalShadowMatrix[NUM_DIR_LIGHT_SHADOWS];varying vec4 vDirectionalShadowCoord[NUM_DIR_LIGHT_SHADOWS];struct DirectionalLightShadow{float shadowBias;float shadowNormalBias;float shadowRadius;vec2 shadowMapSize;};uniform DirectionalLightShadow directionalLightShadows[NUM_DIR_LIGHT_SHADOWS];
#endif
#if NUM_SPOT_LIGHT_SHADOWS>0
uniform mat4 spotShadowMatrix[NUM_SPOT_LIGHT_SHADOWS];varying vec4 vSpotShadowCoord[NUM_SPOT_LIGHT_SHADOWS];struct SpotLightShadow{float shadowBias;float shadowNormalBias;float shadowRadius;vec2 shadowMapSize;};uniform SpotLightShadow spotLightShadows[NUM_SPOT_LIGHT_SHADOWS];
#endif
#if NUM_POINT_LIGHT_SHADOWS>0
uniform mat4 pointShadowMatrix[NUM_POINT_LIGHT_SHADOWS];varying vec4 vPointShadowCoord[NUM_POINT_LIGHT_SHADOWS];struct PointLightShadow{float shadowBias;float shadowNormalBias;float shadowRadius;vec2 shadowMapSize;float shadowCameraNear;float shadowCameraFar;};uniform PointLightShadow pointLightShadows[NUM_POINT_LIGHT_SHADOWS];
#endif
#endif`,zc=`#ifdef USE_SHADOWMAP
#if NUM_DIR_LIGHT_SHADOWS>0||NUM_SPOT_LIGHT_SHADOWS>0||NUM_POINT_LIGHT_SHADOWS>0
vec3 shadowWorldNormal=inverseTransformDirection(transformedNormal,viewMatrix);vec4 shadowWorldPosition;
#endif
#if NUM_DIR_LIGHT_SHADOWS>0
#pragma unroll_loop_start
for(int i=0;i<NUM_DIR_LIGHT_SHADOWS;i++){shadowWorldPosition=worldPosition+vec4(shadowWorldNormal*directionalLightShadows[i].shadowNormalBias,0);vDirectionalShadowCoord[i]=directionalShadowMatrix[i]*shadowWorldPosition;}
#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHT_SHADOWS>0
#pragma unroll_loop_start
for(int i=0;i<NUM_SPOT_LIGHT_SHADOWS;i++){shadowWorldPosition=worldPosition+vec4(shadowWorldNormal*spotLightShadows[i].shadowNormalBias,0);vSpotShadowCoord[i]=spotShadowMatrix[i]*shadowWorldPosition;}
#pragma unroll_loop_end
#endif
#if NUM_POINT_LIGHT_SHADOWS>0
#pragma unroll_loop_start
for(int i=0;i<NUM_POINT_LIGHT_SHADOWS;i++){shadowWorldPosition=worldPosition+vec4(shadowWorldNormal*pointLightShadows[i].shadowNormalBias,0);vPointShadowCoord[i]=pointShadowMatrix[i]*shadowWorldPosition;}
#pragma unroll_loop_end
#endif
#endif`,Nc=`float getShadowMask(){float shadow=1.0;
#ifdef USE_SHADOWMAP
#if NUM_DIR_LIGHT_SHADOWS>0
DirectionalLightShadow directionalLight;
#pragma unroll_loop_start
for(int i=0;i<NUM_DIR_LIGHT_SHADOWS;i++){directionalLight=directionalLightShadows[i];shadow*=receiveShadow?getShadow(directionalShadowMap[i],directionalLight.shadowMapSize,directionalLight.shadowBias,directionalLight.shadowRadius,vDirectionalShadowCoord[i]):1.0;}
#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHT_SHADOWS>0
SpotLightShadow spotLight;
#pragma unroll_loop_start
for(int i=0;i<NUM_SPOT_LIGHT_SHADOWS;i++){spotLight=spotLightShadows[i];shadow*=receiveShadow?getShadow(spotShadowMap[i],spotLight.shadowMapSize,spotLight.shadowBias,spotLight.shadowRadius,vSpotShadowCoord[i]):1.0;}
#pragma unroll_loop_end
#endif
#if NUM_POINT_LIGHT_SHADOWS>0
PointLightShadow pointLight;
#pragma unroll_loop_start
for(int i=0;i<NUM_POINT_LIGHT_SHADOWS;i++){pointLight=pointLightShadows[i];shadow*=receiveShadow?getPointShadow(pointShadowMap[i],pointLight.shadowMapSize,pointLight.shadowBias,pointLight.shadowRadius,vPointShadowCoord[i],pointLight.shadowCameraNear,pointLight.shadowCameraFar):1.0;}
#pragma unroll_loop_end
#endif
#endif
return shadow;}`,Uc=`#ifdef USE_SKINNING
mat4 boneMatX=getBoneMatrix(skinIndex.x);mat4 boneMatY=getBoneMatrix(skinIndex.y);mat4 boneMatZ=getBoneMatrix(skinIndex.z);mat4 boneMatW=getBoneMatrix(skinIndex.w);
#endif`,Bc=`#ifdef USE_SKINNING
uniform mat4 bindMatrix;uniform mat4 bindMatrixInverse;
#ifdef BONE_TEXTURE
uniform highp sampler2D boneTexture;uniform int boneTextureSize;mat4 getBoneMatrix(const in float i){float j=i*4.0;float x=mod(j,float(boneTextureSize));float y=floor(j/float(boneTextureSize));float dx=1.0/float(boneTextureSize);float dy=1.0/float(boneTextureSize);y=dy*(y+0.5);vec4 v1=texture2D(boneTexture,vec2(dx*(x+0.5),y));vec4 v2=texture2D(boneTexture,vec2(dx*(x+1.5),y));vec4 v3=texture2D(boneTexture,vec2(dx*(x+2.5),y));vec4 v4=texture2D(boneTexture,vec2(dx*(x+3.5),y));mat4 bone=mat4(v1,v2,v3,v4);return bone;}
#else
uniform mat4 boneMatrices[MAX_BONES];mat4 getBoneMatrix(const in float i){mat4 bone=boneMatrices[int(i)];return bone;}
#endif
#endif`,Gc=`#ifdef USE_SKINNING
vec4 skinVertex=bindMatrix*vec4(transformed,1.0);vec4 skinned=vec4(0.0);skinned+=boneMatX*skinVertex*skinWeight.x;skinned+=boneMatY*skinVertex*skinWeight.y;skinned+=boneMatZ*skinVertex*skinWeight.z;skinned+=boneMatW*skinVertex*skinWeight.w;transformed=(bindMatrixInverse*skinned).xyz;
#endif`,Oc=`#ifdef USE_SKINNING
mat4 skinMatrix=mat4(0.0);skinMatrix+=skinWeight.x*boneMatX;skinMatrix+=skinWeight.y*boneMatY;skinMatrix+=skinWeight.z*boneMatZ;skinMatrix+=skinWeight.w*boneMatW;skinMatrix=bindMatrixInverse*skinMatrix*bindMatrix;objectNormal=vec4(skinMatrix*vec4(objectNormal,0.0)).xyz;
#ifdef USE_TANGENT
objectTangent=vec4(skinMatrix*vec4(objectTangent,0.0)).xyz;
#endif
#endif`,Vc=`float specularStrength;
#ifdef USE_SPECULARMAP
vec4 texelSpecular=texture2D(specularMap,vUv);specularStrength=texelSpecular.r;
#else
specularStrength=1.0;
#endif`,kc=`#ifdef USE_SPECULARMAP
uniform sampler2D specularMap;
#endif`,Wc=`#if defined(TONE_MAPPING)
gl_FragColor.rgb=toneMapping(gl_FragColor.rgb);
#endif`,Hc=`#ifndef saturate
#define saturate(a)clamp(a,0.0,1.0)
#endif
uniform float toneMappingExposure;vec3 LinearToneMapping(vec3 color){return toneMappingExposure*color;}vec3 ReinhardToneMapping(vec3 color){color*=toneMappingExposure;return saturate(color/(vec3(1.0)+color));}vec3 OptimizedCineonToneMapping(vec3 color){color*=toneMappingExposure;color=max(vec3(0.0),color-0.004);return pow((color*(6.2*color+0.5))/(color*(6.2*color+1.7)+0.06),vec3(2.2));}vec3 RRTAndODTFit(vec3 v){vec3 a=v*(v+0.0245786)-0.000090537;vec3 b=v*(0.983729*v+0.4329510)+0.238081;return a/b;}vec3 ACESFilmicToneMapping(vec3 color){const mat3 ACESInputMat=mat3(vec3(0.59719,0.07600,0.02840),vec3(0.35458,0.90834,0.13383),vec3(0.04823,0.01566,0.83777));const mat3 ACESOutputMat=mat3(vec3(1.60475,-0.10208,-0.00327),vec3(-0.53108,1.10813,-0.07276),vec3(-0.07367,-0.00605,1.07602));color*=toneMappingExposure/0.6;color=ACESInputMat*color;color=RRTAndODTFit(color);color=ACESOutputMat*color;return saturate(color);}vec3 CustomToneMapping(vec3 color){return color;}`,Xc=`#ifdef USE_TRANSMISSION
float transmissionAlpha=1.0;float transmissionFactor=transmission;float thicknessFactor=thickness;
#ifdef USE_TRANSMISSIONMAP
transmissionFactor*=texture2D(transmissionMap,vUv).r;
#endif
#ifdef USE_THICKNESSMAP
thicknessFactor*=texture2D(thicknessMap,vUv).g;
#endif
vec3 pos=vWorldPosition;vec3 v=normalize(cameraPosition-pos);vec3 n=inverseTransformDirection(normal,viewMatrix);vec4 transmission=getIBLVolumeRefraction(n,v,roughnessFactor,material.diffuseColor,material.specularColor,material.specularF90,pos,modelMatrix,viewMatrix,projectionMatrix,ior,thicknessFactor,attenuationTint,attenuationDistance);totalDiffuse=mix(totalDiffuse,transmission.rgb,transmissionFactor);transmissionAlpha=mix(transmissionAlpha,transmission.a,transmissionFactor);
#endif`,qc=`#ifdef USE_TRANSMISSION
uniform float transmission;uniform float thickness;uniform float attenuationDistance;uniform vec3 attenuationTint;
#ifdef USE_TRANSMISSIONMAP
uniform sampler2D transmissionMap;
#endif
#ifdef USE_THICKNESSMAP
uniform sampler2D thicknessMap;
#endif
uniform vec2 transmissionSamplerSize;uniform sampler2D transmissionSamplerMap;uniform mat4 modelMatrix;uniform mat4 projectionMatrix;varying vec3 vWorldPosition;vec3 getVolumeTransmissionRay(vec3 n,vec3 v,float thickness,float ior,mat4 modelMatrix){vec3 refractionVector=refract(-v,normalize(n),1.0/ior);vec3 modelScale;modelScale.x=length(vec3(modelMatrix[0].xyz));modelScale.y=length(vec3(modelMatrix[1].xyz));modelScale.z=length(vec3(modelMatrix[2].xyz));return normalize(refractionVector)*thickness*modelScale;}float applyIorToRoughness(float roughness,float ior){return roughness*clamp(ior*2.0-2.0,0.0,1.0);}vec4 getTransmissionSample(vec2 fragCoord,float roughness,float ior){float framebufferLod=log2(transmissionSamplerSize.x)*applyIorToRoughness(roughness,ior);
#ifdef TEXTURE_LOD_EXT
return texture2DLodEXT(transmissionSamplerMap,fragCoord.xy,framebufferLod);
#else
return texture2D(transmissionSamplerMap,fragCoord.xy,framebufferLod);
#endif
}vec3 applyVolumeAttenuation(vec3 radiance,float transmissionDistance,vec3 attenuationColor,float attenuationDistance){if(attenuationDistance==0.0){return radiance;}else{vec3 attenuationCoefficient=-log(attenuationColor)/attenuationDistance;vec3 transmittance=exp(-attenuationCoefficient*transmissionDistance);return transmittance*radiance;}}vec4 getIBLVolumeRefraction(vec3 n,vec3 v,float roughness,vec3 diffuseColor,vec3 specularColor,float specularF90,vec3 position,mat4 modelMatrix,mat4 viewMatrix,mat4 projMatrix,float ior,float thickness,vec3 attenuationColor,float attenuationDistance){vec3 transmissionRay=getVolumeTransmissionRay(n,v,thickness,ior,modelMatrix);vec3 refractedRayExit=position+transmissionRay;vec4 ndcPos=projMatrix*viewMatrix*vec4(refractedRayExit,1.0);vec2 refractionCoords=ndcPos.xy/ndcPos.w;refractionCoords+=1.0;refractionCoords/=2.0;vec4 transmittedLight=getTransmissionSample(refractionCoords,roughness,ior);vec3 attenuatedColor=applyVolumeAttenuation(transmittedLight.rgb,length(transmissionRay),attenuationColor,attenuationDistance);vec3 F=EnvironmentBRDF(n,v,specularColor,specularF90,roughness);return vec4((1.0-F)*attenuatedColor*diffuseColor,transmittedLight.a);}
#endif`,Yc=`#if (defined(USE_UV)&&!defined(UVS_VERTEX_ONLY))
varying vec2 vUv;
#endif`,Zc=`#ifdef USE_UV
#ifdef UVS_VERTEX_ONLY
vec2 vUv;
#else
varying vec2 vUv;
#endif
uniform mat3 uvTransform;
#endif`,jc=`#ifdef USE_UV
vUv=(uvTransform*vec3(uv,1)).xy;
#endif`,Jc=`#if defined(USE_LIGHTMAP)||defined(USE_AOMAP)
varying vec2 vUv2;
#endif`,$c=`#if defined(USE_LIGHTMAP)||defined(USE_AOMAP)
attribute vec2 uv2;varying vec2 vUv2;uniform mat3 uv2Transform;
#endif`,Qc=`#if defined(USE_LIGHTMAP)||defined(USE_AOMAP)
vUv2=(uv2Transform*vec3(uv2,1)).xy;
#endif`,Kc=`#if defined(USE_ENVMAP)||defined(DISTANCE)||defined(USE_SHADOWMAP)||defined(USE_TRANSMISSION)
vec4 worldPosition=vec4(transformed,1.0);
#ifdef USE_INSTANCING
worldPosition=instanceMatrix*worldPosition;
#endif
worldPosition=modelMatrix*worldPosition;
#endif`;const eu="varying vec2 vUv;uniform mat3 uvTransform;void main(){vUv=(uvTransform*vec3(uv,1)).xy;gl_Position=vec4(position.xy,1.0,1.0);}",tu=`uniform sampler2D t2D;varying vec2 vUv;void main(){vec4 texColor=texture2D(t2D,vUv);gl_FragColor=mapTexelToLinear(texColor);
#include <tonemapping_fragment>
#include <encodings_fragment>
}`,iu=`varying vec3 vWorldDirection;
#include <common>
void main(){vWorldDirection=transformDirection(position,modelMatrix);
#include <begin_vertex>
#include <project_vertex>
gl_Position.z=gl_Position.w;}`,nu=`#include <envmap_common_pars_fragment>
uniform float opacity;varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main(){vec3 vReflect=vWorldDirection;
#include <envmap_fragment>
gl_FragColor=envColor;gl_FragColor.a*=opacity;
#include <tonemapping_fragment>
#include <encodings_fragment>
}`,ru=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;void main(){
#include <uv_vertex>
#include <skinbase_vertex>
#ifdef USE_DISPLACEMENTMAP
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinnormal_vertex>
#endif
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <displacementmap_vertex>
#include <project_vertex>
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
vHighPrecisionZW=gl_Position.zw;}`,su=`#if DEPTH_PACKING==3200
uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;void main(){
#include <clipping_planes_fragment>
vec4 diffuseColor=vec4(1.0);
#if DEPTH_PACKING==3200
diffuseColor.a=opacity;
#endif
#include <map_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
#include <logdepthbuf_fragment>
float fragCoordZ=0.5*vHighPrecisionZW[0]/vHighPrecisionZW[1]+0.5;
#if DEPTH_PACKING==3200
gl_FragColor=vec4(vec3(1.0-fragCoordZ),opacity);
#elif DEPTH_PACKING==3201
gl_FragColor=packDepthToRGBA(fragCoordZ);
#endif
}`,au=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main(){
#include <uv_vertex>
#include <skinbase_vertex>
#ifdef USE_DISPLACEMENTMAP
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinnormal_vertex>
#endif
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <displacementmap_vertex>
#include <project_vertex>
#include <worldpos_vertex>
#include <clipping_planes_vertex>
vWorldPosition=worldPosition.xyz;}`,ou=`#define DISTANCE
uniform vec3 referencePosition;uniform float nearDistance;uniform float farDistance;varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main(){
#include <clipping_planes_fragment>
vec4 diffuseColor=vec4(1.0);
#include <map_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
float dist=length(vWorldPosition-referencePosition);dist=(dist-nearDistance)/(farDistance-nearDistance);dist=saturate(dist);gl_FragColor=packDepthToRGBA(dist);}`,lu=`varying vec3 vWorldDirection;
#include <common>
void main(){vWorldDirection=transformDirection(position,modelMatrix);
#include <begin_vertex>
#include <project_vertex>
}`,cu=`uniform sampler2D tEquirect;varying vec3 vWorldDirection;
#include <common>
void main(){vec3 direction=normalize(vWorldDirection);vec2 sampleUV=equirectUv(direction);vec4 texColor=texture2D(tEquirect,sampleUV);gl_FragColor=mapTexelToLinear(texColor);
#include <tonemapping_fragment>
#include <encodings_fragment>
}`,uu=`uniform float scale;attribute float lineDistance;varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main(){vLineDistance=scale*lineDistance;
#include <color_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <project_vertex>
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
#include <fog_vertex>
}`,hu=`uniform vec3 diffuse;uniform float opacity;uniform float dashSize;uniform float totalSize;varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main(){
#include <clipping_planes_fragment>
if(mod(vLineDistance,totalSize)>dashSize){discard;}vec3 outgoingLight=vec3(0.0);vec4 diffuseColor=vec4(diffuse,opacity);
#include <logdepthbuf_fragment>
#include <color_fragment>
outgoingLight=diffuseColor.rgb;
#include <output_fragment>
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
}`,du=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main(){
#include <uv_vertex>
#include <uv2_vertex>
#include <color_vertex>
#if defined(USE_ENVMAP)||defined(USE_SKINNING)
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <defaultnormal_vertex>
#endif
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <project_vertex>
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
#include <worldpos_vertex>
#include <envmap_vertex>
#include <fog_vertex>
}`,fu=`uniform vec3 diffuse;uniform float opacity;
#ifndef FLAT_SHADED
varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main(){
#include <clipping_planes_fragment>
vec4 diffuseColor=vec4(diffuse,opacity);
#include <logdepthbuf_fragment>
#include <map_fragment>
#include <color_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
#include <specularmap_fragment>
ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));
#ifdef USE_LIGHTMAP
vec4 lightMapTexel=texture2D(lightMap,vUv2);reflectedLight.indirectDiffuse+=lightMapTexelToLinear(lightMapTexel).rgb*lightMapIntensity;
#else
reflectedLight.indirectDiffuse+=vec3(1.0);
#endif
#include <aomap_fragment>
reflectedLight.indirectDiffuse*=diffuseColor.rgb;vec3 outgoingLight=reflectedLight.indirectDiffuse;
#include <envmap_fragment>
#include <output_fragment>
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
#include <dithering_fragment>
}`,pu=`#define LAMBERT
varying vec3 vLightFront;varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
varying vec3 vLightBack;varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main(){
#include <uv_vertex>
#include <uv2_vertex>
#include <color_vertex>
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <defaultnormal_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <project_vertex>
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
#include <worldpos_vertex>
#include <envmap_vertex>
#include <lights_lambert_vertex>
#include <shadowmap_vertex>
#include <fog_vertex>
}`,mu=`uniform vec3 diffuse;uniform vec3 emissive;uniform float opacity;varying vec3 vLightFront;varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
varying vec3 vLightBack;varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main(){
#include <clipping_planes_fragment>
vec4 diffuseColor=vec4(diffuse,opacity);ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));vec3 totalEmissiveRadiance=emissive;
#include <logdepthbuf_fragment>
#include <map_fragment>
#include <color_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
#include <specularmap_fragment>
#include <emissivemap_fragment>
#ifdef DOUBLE_SIDED
reflectedLight.indirectDiffuse+=(gl_FrontFacing)?vIndirectFront:vIndirectBack;
#else
reflectedLight.indirectDiffuse+=vIndirectFront;
#endif
#include <lightmap_fragment>
reflectedLight.indirectDiffuse*=BRDF_Lambert(diffuseColor.rgb);
#ifdef DOUBLE_SIDED
reflectedLight.directDiffuse=(gl_FrontFacing)?vLightFront:vLightBack;
#else
reflectedLight.directDiffuse=vLightFront;
#endif
reflectedLight.directDiffuse*=BRDF_Lambert(diffuseColor.rgb)*getShadowMask();
#include <aomap_fragment>
vec3 outgoingLight=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+totalEmissiveRadiance;
#include <envmap_fragment>
#include <output_fragment>
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
#include <dithering_fragment>
}`,gu=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main(){
#include <uv_vertex>
#include <color_vertex>
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <defaultnormal_vertex>
#include <normal_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <displacementmap_vertex>
#include <project_vertex>
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
#include <fog_vertex>
vViewPosition=-mvPosition.xyz;}`,_u=`#define MATCAP
uniform vec3 diffuse;uniform float opacity;uniform sampler2D matcap;varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main(){
#include <clipping_planes_fragment>
vec4 diffuseColor=vec4(diffuse,opacity);
#include <logdepthbuf_fragment>
#include <map_fragment>
#include <color_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
#include <normal_fragment_begin>
#include <normal_fragment_maps>
vec3 viewDir=normalize(vViewPosition);vec3 x=normalize(vec3(viewDir.z,0.0,-viewDir.x));vec3 y=cross(viewDir,x);vec2 uv=vec2(dot(x,normal),dot(y,normal))*0.495+0.5;
#ifdef USE_MATCAP
vec4 matcapColor=texture2D(matcap,uv);matcapColor=matcapTexelToLinear(matcapColor);
#else
vec4 matcapColor=vec4(1.0);
#endif
vec3 outgoingLight=diffuseColor.rgb*matcapColor.rgb;
#include <output_fragment>
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
#include <dithering_fragment>
}`,xu=`#define NORMAL
#if defined(FLAT_SHADED)||defined(USE_BUMPMAP)||defined(TANGENTSPACE_NORMALMAP)
varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main(){
#include <uv_vertex>
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <defaultnormal_vertex>
#include <normal_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <displacementmap_vertex>
#include <project_vertex>
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
#if defined(FLAT_SHADED)||defined(USE_BUMPMAP)||defined(TANGENTSPACE_NORMALMAP)
vViewPosition=-mvPosition.xyz;
#endif
}`,vu=`#define NORMAL
uniform float opacity;
#if defined(FLAT_SHADED)||defined(USE_BUMPMAP)||defined(TANGENTSPACE_NORMALMAP)
varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main(){
#include <clipping_planes_fragment>
#include <logdepthbuf_fragment>
#include <normal_fragment_begin>
#include <normal_fragment_maps>
gl_FragColor=vec4(packNormalToRGB(normal),opacity);}`,Mu=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main(){
#include <uv_vertex>
#include <uv2_vertex>
#include <color_vertex>
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <defaultnormal_vertex>
#include <normal_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <displacementmap_vertex>
#include <project_vertex>
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
vViewPosition=-mvPosition.xyz;
#include <worldpos_vertex>
#include <envmap_vertex>
#include <shadowmap_vertex>
#include <fog_vertex>
}`,yu=`#define PHONG
uniform vec3 diffuse;uniform vec3 emissive;uniform vec3 specular;uniform float shininess;uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main(){
#include <clipping_planes_fragment>
vec4 diffuseColor=vec4(diffuse,opacity);ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));vec3 totalEmissiveRadiance=emissive;
#include <logdepthbuf_fragment>
#include <map_fragment>
#include <color_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
#include <specularmap_fragment>
#include <normal_fragment_begin>
#include <normal_fragment_maps>
#include <emissivemap_fragment>
#include <lights_phong_fragment>
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>
#include <aomap_fragment>
vec3 outgoingLight=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+reflectedLight.directSpecular+reflectedLight.indirectSpecular+totalEmissiveRadiance;
#include <envmap_fragment>
#include <output_fragment>
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
#include <dithering_fragment>
}`,Su=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main(){
#include <uv_vertex>
#include <uv2_vertex>
#include <color_vertex>
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <defaultnormal_vertex>
#include <normal_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <displacementmap_vertex>
#include <project_vertex>
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
vViewPosition=-mvPosition.xyz;
#include <worldpos_vertex>
#include <shadowmap_vertex>
#include <fog_vertex>
#ifdef USE_TRANSMISSION
vWorldPosition=worldPosition.xyz;
#endif
}`,bu=`#define STANDARD
#ifdef PHYSICAL
#define IOR
#define SPECULAR
#endif
uniform vec3 diffuse;uniform vec3 emissive;uniform float roughness;uniform float metalness;uniform float opacity;
#ifdef IOR
uniform float ior;
#endif
#ifdef SPECULAR
uniform float specularIntensity;uniform vec3 specularTint;
#ifdef USE_SPECULARINTENSITYMAP
uniform sampler2D specularIntensityMap;
#endif
#ifdef USE_SPECULARTINTMAP
uniform sampler2D specularTintMap;
#endif
#endif
#ifdef USE_CLEARCOAT
uniform float clearcoat;uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
uniform vec3 sheenTint;uniform float sheenRoughness;
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main(){
#include <clipping_planes_fragment>
vec4 diffuseColor=vec4(diffuse,opacity);ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));vec3 totalEmissiveRadiance=emissive;
#include <logdepthbuf_fragment>
#include <map_fragment>
#include <color_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
#include <roughnessmap_fragment>
#include <metalnessmap_fragment>
#include <normal_fragment_begin>
#include <normal_fragment_maps>
#include <clearcoat_normal_fragment_begin>
#include <clearcoat_normal_fragment_maps>
#include <emissivemap_fragment>
#include <lights_physical_fragment>
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>
#include <aomap_fragment>
vec3 totalDiffuse=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse;vec3 totalSpecular=reflectedLight.directSpecular+reflectedLight.indirectSpecular;
#include <transmission_fragment>
vec3 outgoingLight=totalDiffuse+totalSpecular+totalEmissiveRadiance;
#ifdef USE_CLEARCOAT
float dotNVcc=saturate(dot(geometry.clearcoatNormal,geometry.viewDir));vec3 Fcc=F_Schlick(material.clearcoatF0,material.clearcoatF90,dotNVcc);outgoingLight=outgoingLight*(1.0-clearcoat*Fcc)+clearcoatSpecular*clearcoat;
#endif
#include <output_fragment>
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
#include <dithering_fragment>
}`,wu=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main(){
#include <uv_vertex>
#include <uv2_vertex>
#include <color_vertex>
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <defaultnormal_vertex>
#include <normal_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <displacementmap_vertex>
#include <project_vertex>
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
vViewPosition=-mvPosition.xyz;
#include <worldpos_vertex>
#include <shadowmap_vertex>
#include <fog_vertex>
}`,Tu=`#define TOON
uniform vec3 diffuse;uniform vec3 emissive;uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main(){
#include <clipping_planes_fragment>
vec4 diffuseColor=vec4(diffuse,opacity);ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));vec3 totalEmissiveRadiance=emissive;
#include <logdepthbuf_fragment>
#include <map_fragment>
#include <color_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
#include <normal_fragment_begin>
#include <normal_fragment_maps>
#include <emissivemap_fragment>
#include <lights_toon_fragment>
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>
#include <aomap_fragment>
vec3 outgoingLight=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+totalEmissiveRadiance;
#include <output_fragment>
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
#include <dithering_fragment>
}`,Eu=`uniform float size;uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main(){
#include <color_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <project_vertex>
gl_PointSize=size;
#ifdef USE_SIZEATTENUATION
bool isPerspective=isPerspectiveMatrix(projectionMatrix);if(isPerspective)gl_PointSize*=(scale/-mvPosition.z);
#endif
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
#include <worldpos_vertex>
#include <fog_vertex>
}`,Au=`uniform vec3 diffuse;uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main(){
#include <clipping_planes_fragment>
vec3 outgoingLight=vec3(0.0);vec4 diffuseColor=vec4(diffuse,opacity);
#include <logdepthbuf_fragment>
#include <map_particle_fragment>
#include <color_fragment>
#include <alphatest_fragment>
outgoingLight=diffuseColor.rgb;
#include <output_fragment>
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
}`,Lu=`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main(){
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <defaultnormal_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <project_vertex>
#include <worldpos_vertex>
#include <shadowmap_vertex>
#include <fog_vertex>
}`,Cu=`uniform vec3 color;uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main(){gl_FragColor=vec4(color,opacity*(1.0-getShadowMask()));
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
}`,Du=`uniform float rotation;uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main(){
#include <uv_vertex>
vec4 mvPosition=modelViewMatrix*vec4(0.0,0.0,0.0,1.0);vec2 scale;scale.x=length(vec3(modelMatrix[0].x,modelMatrix[0].y,modelMatrix[0].z));scale.y=length(vec3(modelMatrix[1].x,modelMatrix[1].y,modelMatrix[1].z));
#ifndef USE_SIZEATTENUATION
bool isPerspective=isPerspectiveMatrix(projectionMatrix);if(isPerspective)scale*=-mvPosition.z;
#endif
vec2 alignedPosition=(position.xy-(center-vec2(0.5)))*scale;vec2 rotatedPosition;rotatedPosition.x=cos(rotation)*alignedPosition.x-sin(rotation)*alignedPosition.y;rotatedPosition.y=sin(rotation)*alignedPosition.x+cos(rotation)*alignedPosition.y;mvPosition.xy+=rotatedPosition;gl_Position=projectionMatrix*mvPosition;
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
#include <fog_vertex>
}`,Pu=`uniform vec3 diffuse;uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main(){
#include <clipping_planes_fragment>
vec3 outgoingLight=vec3(0.0);vec4 diffuseColor=vec4(diffuse,opacity);
#include <logdepthbuf_fragment>
#include <map_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
outgoingLight=diffuseColor.rgb;
#include <output_fragment>
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
}`,Me={alphamap_fragment:al,alphamap_pars_fragment:ol,alphatest_fragment:ll,alphatest_pars_fragment:cl,aomap_fragment:ul,aomap_pars_fragment:hl,begin_vertex:dl,beginnormal_vertex:fl,bsdfs:pl,bumpmap_pars_fragment:ml,clipping_planes_fragment:gl,clipping_planes_pars_fragment:_l,clipping_planes_pars_vertex:xl,clipping_planes_vertex:vl,color_fragment:Ml,color_pars_fragment:yl,color_pars_vertex:Sl,color_vertex:bl,common:wl,cube_uv_reflection_fragment:Tl,defaultnormal_vertex:El,displacementmap_pars_vertex:Al,displacementmap_vertex:Ll,emissivemap_fragment:Cl,emissivemap_pars_fragment:Dl,encodings_fragment:Pl,encodings_pars_fragment:Rl,envmap_fragment:Fl,envmap_common_pars_fragment:Il,envmap_pars_fragment:zl,envmap_pars_vertex:Nl,envmap_physical_pars_fragment:Yl,envmap_vertex:Ul,fog_vertex:Bl,fog_pars_vertex:Gl,fog_fragment:Ol,fog_pars_fragment:Vl,gradientmap_pars_fragment:kl,lightmap_fragment:Wl,lightmap_pars_fragment:Hl,lights_lambert_vertex:Xl,lights_pars_begin:ql,lights_toon_fragment:Zl,lights_toon_pars_fragment:jl,lights_phong_fragment:Jl,lights_phong_pars_fragment:$l,lights_physical_fragment:Ql,lights_physical_pars_fragment:Kl,lights_fragment_begin:ec,lights_fragment_maps:tc,lights_fragment_end:ic,logdepthbuf_fragment:nc,logdepthbuf_pars_fragment:rc,logdepthbuf_pars_vertex:sc,logdepthbuf_vertex:ac,map_fragment:oc,map_pars_fragment:lc,map_particle_fragment:cc,map_particle_pars_fragment:uc,metalnessmap_fragment:hc,metalnessmap_pars_fragment:dc,morphnormal_vertex:fc,morphtarget_pars_vertex:pc,morphtarget_vertex:mc,normal_fragment_begin:gc,normal_fragment_maps:_c,normal_pars_fragment:xc,normal_pars_vertex:vc,normal_vertex:Mc,normalmap_pars_fragment:yc,clearcoat_normal_fragment_begin:Sc,clearcoat_normal_fragment_maps:bc,clearcoat_pars_fragment:wc,output_fragment:Tc,packing:Ec,premultiplied_alpha_fragment:Ac,project_vertex:Lc,dithering_fragment:Cc,dithering_pars_fragment:Dc,roughnessmap_fragment:Pc,roughnessmap_pars_fragment:Rc,shadowmap_pars_fragment:Fc,shadowmap_pars_vertex:Ic,shadowmap_vertex:zc,shadowmask_pars_fragment:Nc,skinbase_vertex:Uc,skinning_pars_vertex:Bc,skinning_vertex:Gc,skinnormal_vertex:Oc,specularmap_fragment:Vc,specularmap_pars_fragment:kc,tonemapping_fragment:Wc,tonemapping_pars_fragment:Hc,transmission_fragment:Xc,transmission_pars_fragment:qc,uv_pars_fragment:Yc,uv_pars_vertex:Zc,uv_vertex:jc,uv2_pars_fragment:Jc,uv2_pars_vertex:$c,uv2_vertex:Qc,worldpos_vertex:Kc,background_vert:eu,background_frag:tu,cube_vert:iu,cube_frag:nu,depth_vert:ru,depth_frag:su,distanceRGBA_vert:au,distanceRGBA_frag:ou,equirect_vert:lu,equirect_frag:cu,linedashed_vert:uu,linedashed_frag:hu,meshbasic_vert:du,meshbasic_frag:fu,meshlambert_vert:pu,meshlambert_frag:mu,meshmatcap_vert:gu,meshmatcap_frag:_u,meshnormal_vert:xu,meshnormal_frag:vu,meshphong_vert:Mu,meshphong_frag:yu,meshphysical_vert:Su,meshphysical_frag:bu,meshtoon_vert:wu,meshtoon_frag:Tu,points_vert:Eu,points_frag:Au,shadow_vert:Lu,shadow_frag:Cu,sprite_vert:Du,sprite_frag:Pu},Z={common:{diffuse:{value:new Ae(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new lt},uv2Transform:{value:new lt},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new De(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Ae(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Ae(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new lt}},sprite:{diffuse:{value:new Ae(16777215)},opacity:{value:1},center:{value:new De(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new lt}}},dt={basic:{uniforms:Ve([Z.common,Z.specularmap,Z.envmap,Z.aomap,Z.lightmap,Z.fog]),vertexShader:Me.meshbasic_vert,fragmentShader:Me.meshbasic_frag},lambert:{uniforms:Ve([Z.common,Z.specularmap,Z.envmap,Z.aomap,Z.lightmap,Z.emissivemap,Z.fog,Z.lights,{emissive:{value:new Ae(0)}}]),vertexShader:Me.meshlambert_vert,fragmentShader:Me.meshlambert_frag},phong:{uniforms:Ve([Z.common,Z.specularmap,Z.envmap,Z.aomap,Z.lightmap,Z.emissivemap,Z.bumpmap,Z.normalmap,Z.displacementmap,Z.fog,Z.lights,{emissive:{value:new Ae(0)},specular:{value:new Ae(1118481)},shininess:{value:30}}]),vertexShader:Me.meshphong_vert,fragmentShader:Me.meshphong_frag},standard:{uniforms:Ve([Z.common,Z.envmap,Z.aomap,Z.lightmap,Z.emissivemap,Z.bumpmap,Z.normalmap,Z.displacementmap,Z.roughnessmap,Z.metalnessmap,Z.fog,Z.lights,{emissive:{value:new Ae(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Me.meshphysical_vert,fragmentShader:Me.meshphysical_frag},toon:{uniforms:Ve([Z.common,Z.aomap,Z.lightmap,Z.emissivemap,Z.bumpmap,Z.normalmap,Z.displacementmap,Z.gradientmap,Z.fog,Z.lights,{emissive:{value:new Ae(0)}}]),vertexShader:Me.meshtoon_vert,fragmentShader:Me.meshtoon_frag},matcap:{uniforms:Ve([Z.common,Z.bumpmap,Z.normalmap,Z.displacementmap,Z.fog,{matcap:{value:null}}]),vertexShader:Me.meshmatcap_vert,fragmentShader:Me.meshmatcap_frag},points:{uniforms:Ve([Z.points,Z.fog]),vertexShader:Me.points_vert,fragmentShader:Me.points_frag},dashed:{uniforms:Ve([Z.common,Z.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Me.linedashed_vert,fragmentShader:Me.linedashed_frag},depth:{uniforms:Ve([Z.common,Z.displacementmap]),vertexShader:Me.depth_vert,fragmentShader:Me.depth_frag},normal:{uniforms:Ve([Z.common,Z.bumpmap,Z.normalmap,Z.displacementmap,{opacity:{value:1}}]),vertexShader:Me.meshnormal_vert,fragmentShader:Me.meshnormal_frag},sprite:{uniforms:Ve([Z.sprite,Z.fog]),vertexShader:Me.sprite_vert,fragmentShader:Me.sprite_frag},background:{uniforms:{uvTransform:{value:new lt},t2D:{value:null}},vertexShader:Me.background_vert,fragmentShader:Me.background_frag},cube:{uniforms:Ve([Z.envmap,{opacity:{value:1}}]),vertexShader:Me.cube_vert,fragmentShader:Me.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Me.equirect_vert,fragmentShader:Me.equirect_frag},distanceRGBA:{uniforms:Ve([Z.common,Z.displacementmap,{referencePosition:{value:new C},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Me.distanceRGBA_vert,fragmentShader:Me.distanceRGBA_frag},shadow:{uniforms:Ve([Z.lights,Z.fog,{color:{value:new Ae(0)},opacity:{value:1}}]),vertexShader:Me.shadow_vert,fragmentShader:Me.shadow_frag}};dt.physical={uniforms:Ve([dt.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new De(1,1)},clearcoatNormalMap:{value:null},sheen:{value:0},sheenTint:{value:new Ae(0)},sheenRoughness:{value:0},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new De},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationTint:{value:new Ae(0)},specularIntensity:{value:0},specularIntensityMap:{value:null},specularTint:{value:new Ae(1,1,1)},specularTintMap:{value:null}}]),vertexShader:Me.meshphysical_vert,fragmentShader:Me.meshphysical_frag};function Ru(s,e,t,i,n){const r=new Ae(0);let a=0,o,c,l=null,h=0,p=null;function f(_,g){let b=!1,u=g.isScene===!0?g.background:null;u&&u.isTexture&&(u=e.get(u));const d=s.xr,T=d.getSession&&d.getSession();T&&T.environmentBlendMode==="additive"&&(u=null),u===null?m(r,a):u&&u.isColor&&(m(u,1),b=!0),(s.autoClear||b)&&s.clear(s.autoClearColor,s.autoClearDepth,s.autoClearStencil),u&&(u.isCubeTexture||u.mapping===dn)?(c===void 0&&(c=new pt(new wi(1,1,1),new xi({name:"BackgroundCubeMaterial",uniforms:_i(dt.cube.uniforms),vertexShader:dt.cube.vertexShader,fragmentShader:dt.cube.fragmentShader,side:ze,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),c.geometry.deleteAttribute("uv"),c.onBeforeRender=function(M,w,A){this.matrixWorld.copyPosition(A.matrixWorld)},Object.defineProperty(c.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(c)),c.material.uniforms.envMap.value=u,c.material.uniforms.flipEnvMap.value=u.isCubeTexture&&u.isRenderTargetTexture===!1?-1:1,(l!==u||h!==u.version||p!==s.toneMapping)&&(c.material.needsUpdate=!0,l=u,h=u.version,p=s.toneMapping),_.unshift(c,c.geometry,c.material,0,0,null)):u&&u.isTexture&&(o===void 0&&(o=new pt(new ur(2,2),new xi({name:"BackgroundMaterial",uniforms:_i(dt.background.uniforms),vertexShader:dt.background.vertexShader,fragmentShader:dt.background.fragmentShader,side:Bi,depthTest:!1,depthWrite:!1,fog:!1})),o.geometry.deleteAttribute("normal"),Object.defineProperty(o.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(o)),o.material.uniforms.t2D.value=u,u.matrixAutoUpdate===!0&&u.updateMatrix(),o.material.uniforms.uvTransform.value.copy(u.matrix),(l!==u||h!==u.version||p!==s.toneMapping)&&(o.material.needsUpdate=!0,l=u,h=u.version,p=s.toneMapping),_.unshift(o,o.geometry,o.material,0,0,null))}function m(_,g){t.buffers.color.setClear(_.r,_.g,_.b,g,n)}return{getClearColor:function(){return r},setClearColor:function(_,g=1){r.set(_),a=g,m(r,a)},getClearAlpha:function(){return a},setClearAlpha:function(_){a=_,m(r,a)},render:f}}function Fu(s,e,t,i){const n=s.getParameter(34921),r=i.isWebGL2?null:e.get("OES_vertex_array_object"),a=i.isWebGL2||r!==null,o={},c=g(null);let l=c;function h(I,U,G,z,N){let Y=!1;if(a){const ne=_(z,G,U);l!==ne&&(l=ne,f(l.object)),Y=b(z,N),Y&&u(z,N)}else{const ne=U.wireframe===!0;(l.geometry!==z.id||l.program!==G.id||l.wireframe!==ne)&&(l.geometry=z.id,l.program=G.id,l.wireframe=ne,Y=!0)}I.isInstancedMesh===!0&&(Y=!0),N!==null&&t.update(N,34963),Y&&(v(I,U,G,z),N!==null&&s.bindBuffer(34963,t.get(N).buffer))}function p(){return i.isWebGL2?s.createVertexArray():r.createVertexArrayOES()}function f(I){return i.isWebGL2?s.bindVertexArray(I):r.bindVertexArrayOES(I)}function m(I){return i.isWebGL2?s.deleteVertexArray(I):r.deleteVertexArrayOES(I)}function _(I,U,G){const z=G.wireframe===!0;let N=o[I.id];N===void 0&&(N={},o[I.id]=N);let Y=N[U.id];Y===void 0&&(Y={},N[U.id]=Y);let ne=Y[z];return ne===void 0&&(ne=g(p()),Y[z]=ne),ne}function g(I){const U=[],G=[],z=[];for(let N=0;N<n;N++)U[N]=0,G[N]=0,z[N]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:U,enabledAttributes:G,attributeDivisors:z,object:I,attributes:{},index:null}}function b(I,U){const G=l.attributes,z=I.attributes;let N=0;for(const Y in z){const ne=G[Y],oe=z[Y];if(ne===void 0||ne.attribute!==oe||ne.data!==oe.data)return!0;N++}return l.attributesNum!==N||l.index!==U}function u(I,U){const G={},z=I.attributes;let N=0;for(const Y in z){const ne=z[Y],oe={};oe.attribute=ne,ne.data&&(oe.data=ne.data),G[Y]=oe,N++}l.attributes=G,l.attributesNum=N,l.index=U}function d(){const I=l.newAttributes;for(let U=0,G=I.length;U<G;U++)I[U]=0}function T(I){M(I,0)}function M(I,U){const G=l.newAttributes,z=l.enabledAttributes,N=l.attributeDivisors;G[I]=1,z[I]===0&&(s.enableVertexAttribArray(I),z[I]=1),N[I]!==U&&((i.isWebGL2?s:e.get("ANGLE_instanced_arrays"))[i.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](I,U),N[I]=U)}function w(){const I=l.newAttributes,U=l.enabledAttributes;for(let G=0,z=U.length;G<z;G++)U[G]!==I[G]&&(s.disableVertexAttribArray(G),U[G]=0)}function A(I,U,G,z,N,Y){i.isWebGL2===!0&&(G===5124||G===5125)?s.vertexAttribIPointer(I,U,G,N,Y):s.vertexAttribPointer(I,U,G,z,N,Y)}function v(I,U,G,z){if(i.isWebGL2===!1&&(I.isInstancedMesh||z.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;d();const N=z.attributes,Y=G.getAttributes(),ne=U.defaultAttributeValues;for(const oe in Y){const te=Y[oe];if(te.location>=0){let xe=N[oe];if(xe===void 0&&(oe==="instanceMatrix"&&I.instanceMatrix&&(xe=I.instanceMatrix),oe==="instanceColor"&&I.instanceColor&&(xe=I.instanceColor)),xe!==void 0){const H=xe.normalized,q=xe.itemSize,re=t.get(xe);if(re===void 0)continue;const F=re.buffer,me=re.type,_e=re.bytesPerElement;if(xe.isInterleavedBufferAttribute){const K=xe.data,ue=K.stride,be=xe.offset;if(K&&K.isInstancedInterleavedBuffer){for(let he=0;he<te.locationSize;he++)M(te.location+he,K.meshPerAttribute);I.isInstancedMesh!==!0&&z._maxInstanceCount===void 0&&(z._maxInstanceCount=K.meshPerAttribute*K.count)}else for(let he=0;he<te.locationSize;he++)T(te.location+he);s.bindBuffer(34962,F);for(let he=0;he<te.locationSize;he++)A(te.location+he,q/te.locationSize,me,H,ue*_e,(be+q/te.locationSize*he)*_e)}else{if(xe.isInstancedBufferAttribute){for(let K=0;K<te.locationSize;K++)M(te.location+K,xe.meshPerAttribute);I.isInstancedMesh!==!0&&z._maxInstanceCount===void 0&&(z._maxInstanceCount=xe.meshPerAttribute*xe.count)}else for(let K=0;K<te.locationSize;K++)T(te.location+K);s.bindBuffer(34962,F);for(let K=0;K<te.locationSize;K++)A(te.location+K,q/te.locationSize,me,H,q*_e,q/te.locationSize*K*_e)}}else if(ne!==void 0){const H=ne[oe];if(H!==void 0)switch(H.length){case 2:s.vertexAttrib2fv(te.location,H);break;case 3:s.vertexAttrib3fv(te.location,H);break;case 4:s.vertexAttrib4fv(te.location,H);break;default:s.vertexAttrib1fv(te.location,H)}}}}w()}function B(){L();for(const I in o){const U=o[I];for(const G in U){const z=U[G];for(const N in z)m(z[N].object),delete z[N];delete U[G]}delete o[I]}}function X(I){if(o[I.id]===void 0)return;const U=o[I.id];for(const G in U){const z=U[G];for(const N in z)m(z[N].object),delete z[N];delete U[G]}delete o[I.id]}function O(I){for(const U in o){const G=o[U];if(G[I.id]===void 0)continue;const z=G[I.id];for(const N in z)m(z[N].object),delete z[N];delete G[I.id]}}function L(){j(),l!==c&&(l=c,f(l.object))}function j(){c.geometry=null,c.program=null,c.wireframe=!1}return{setup:h,reset:L,resetDefaultState:j,dispose:B,releaseStatesOfGeometry:X,releaseStatesOfProgram:O,initAttributes:d,enableAttribute:T,disableUnusedAttributes:w}}function Iu(s,e,t,i){const n=i.isWebGL2;let r;function a(l){r=l}function o(l,h){s.drawArrays(r,l,h),t.update(h,r,1)}function c(l,h,p){if(p===0)return;let f,m;if(n)f=s,m="drawArraysInstanced";else if(f=e.get("ANGLE_instanced_arrays"),m="drawArraysInstancedANGLE",f===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}f[m](r,l,h,p),t.update(h,r,p)}this.setMode=a,this.render=o,this.renderInstances=c}function zu(s,e,t){let i;function n(){if(i!==void 0)return i;if(e.has("EXT_texture_filter_anisotropic")===!0){const v=e.get("EXT_texture_filter_anisotropic");i=s.getParameter(v.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i}function r(v){if(v==="highp"){if(s.getShaderPrecisionFormat(35633,36338).precision>0&&s.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";v="mediump"}return v==="mediump"&&s.getShaderPrecisionFormat(35633,36337).precision>0&&s.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const a=typeof WebGL2RenderingContext!="undefined"&&s instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext!="undefined"&&s instanceof WebGL2ComputeRenderingContext;let o=t.precision!==void 0?t.precision:"highp";const c=r(o);c!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",c,"instead."),o=c);const l=a||e.has("WEBGL_draw_buffers"),h=t.logarithmicDepthBuffer===!0,p=s.getParameter(34930),f=s.getParameter(35660),m=s.getParameter(3379),_=s.getParameter(34076),g=s.getParameter(34921),b=s.getParameter(36347),u=s.getParameter(36348),d=s.getParameter(36349),T=f>0,M=a||e.has("OES_texture_float"),w=T&&M,A=a?s.getParameter(36183):0;return{isWebGL2:a,drawBuffers:l,getMaxAnisotropy:n,getMaxPrecision:r,precision:o,logarithmicDepthBuffer:h,maxTextures:p,maxVertexTextures:f,maxTextureSize:m,maxCubemapSize:_,maxAttributes:g,maxVertexUniforms:b,maxVaryings:u,maxFragmentUniforms:d,vertexTextures:T,floatFragmentTextures:M,floatVertexTextures:w,maxSamples:A}}function Nu(s){const e=this;let t=null,i=0,n=!1,r=!1;const a=new It,o=new lt,c={value:null,needsUpdate:!1};this.uniform=c,this.numPlanes=0,this.numIntersection=0,this.init=function(p,f,m){const _=p.length!==0||f||i!==0||n;return n=f,t=h(p,m,0),i=p.length,_},this.beginShadows=function(){r=!0,h(null)},this.endShadows=function(){r=!1,l()},this.setState=function(p,f,m){const _=p.clippingPlanes,g=p.clipIntersection,b=p.clipShadows,u=s.get(p);if(!n||_===null||_.length===0||r&&!b)r?h(null):l();else{const d=r?0:i,T=d*4;let M=u.clippingState||null;c.value=M,M=h(_,f,T,m);for(let w=0;w!==T;++w)M[w]=t[w];u.clippingState=M,this.numIntersection=g?this.numPlanes:0,this.numPlanes+=d}};function l(){c.value!==t&&(c.value=t,c.needsUpdate=i>0),e.numPlanes=i,e.numIntersection=0}function h(p,f,m,_){const g=p!==null?p.length:0;let b=null;if(g!==0){if(b=c.value,_!==!0||b===null){const u=m+g*4,d=f.matrixWorldInverse;o.getNormalMatrix(d),(b===null||b.length<u)&&(b=new Float32Array(u));for(let T=0,M=m;T!==g;++T,M+=4)a.copy(p[T]).applyMatrix4(d,o),a.normal.toArray(b,M),b[M+3]=a.constant}c.value=b,c.needsUpdate=!0}return e.numPlanes=g,e.numIntersection=0,b}}function Uu(s){let e=new WeakMap;function t(a,o){return o===jn?a.mapping=un:o===Jn&&(a.mapping=hn),a}function i(a){if(a&&a.isTexture&&a.isRenderTargetTexture===!1){const o=a.mapping;if(o===jn||o===Jn)if(e.has(a)){const c=e.get(a).texture;return t(c,a.mapping)}else{const c=a.image;if(c&&c.height>0){const l=s.getRenderTarget(),h=new Is(c.height/2);return h.fromEquirectangularTexture(s,a),e.set(a,h),s.setRenderTarget(l),a.addEventListener("dispose",n),t(h.texture,a.mapping)}else return null}}return a}function n(a){const o=a.target;o.removeEventListener("dispose",n);const c=e.get(o);c!==void 0&&(e.delete(o),c.dispose())}function r(){e=new WeakMap}return{get:i,dispose:r}}class Us extends lr{constructor(e=-1,t=1,i=1,n=-1,r=.1,a=2e3){super(),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=i,this.bottom=n,this.near=r,this.far=a,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,i,n,r,a){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=i,this.view.offsetY=n,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),i=(this.right+this.left)/2,n=(this.top+this.bottom)/2;let r=i-e,a=i+e,o=n+t,c=n-t;if(this.view!==null&&this.view.enabled){const l=(this.right-this.left)/this.view.fullWidth/this.zoom,h=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=l*this.view.offsetX,a=r+l*this.view.width,o-=h*this.view.offsetY,c=o-h*this.view.height}this.projectionMatrix.makeOrthographic(r,a,o,c,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}Us.prototype.isOrthographicCamera=!0;class mn extends xi{constructor(e){super(e),this.type="RawShaderMaterial"}}mn.prototype.isRawShaderMaterial=!0;const mi=4,Bt=8,ut=Math.pow(2,Bt),Bs=[.125,.215,.35,.446,.526,.582],Gs=Bt-mi+1+Bs.length,ui=20,Vt={[qe]:0,[vi]:1,[sr]:2,[Es]:3,[As]:4,[Ls]:5,[rr]:6},Hn=new Us,{_lodPlanes:Ri,_sizeLods:Kr,_sigmas:an}=Ou(),es=new Ae;let Xn=null;const jt=(1+Math.sqrt(5))/2,hi=1/jt,ts=[new C(1,1,1),new C(-1,1,1),new C(1,1,-1),new C(-1,1,-1),new C(0,jt,hi),new C(0,jt,-hi),new C(hi,0,jt),new C(-hi,0,jt),new C(jt,hi,0),new C(-jt,hi,0)];class Bu{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._blurMaterial=Vu(ui),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,i=.1,n=100){Xn=this._renderer.getRenderTarget();const r=this._allocateTargets();return this._sceneToCubeUV(e,i,n,r),t>0&&this._blur(r,0,0,t),this._applyPMREM(r),this._cleanup(r),r}fromEquirectangular(e){return this._fromTexture(e)}fromCubemap(e){return this._fromTexture(e)}compileCubemapShader(){this._cubemapShader===null&&(this._cubemapShader=rs(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){this._equirectShader===null&&(this._equirectShader=ns(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),this._cubemapShader!==null&&this._cubemapShader.dispose(),this._equirectShader!==null&&this._equirectShader.dispose();for(let e=0;e<Ri.length;e++)Ri[e].dispose()}_cleanup(e){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(Xn),e.scissorTest=!1,on(e,0,0,e.width,e.height)}_fromTexture(e){Xn=this._renderer.getRenderTarget();const t=this._allocateTargets(e);return this._textureToCubeUV(e,t),this._applyPMREM(t),this._cleanup(t),t}_allocateTargets(e){const t={magFilter:Ze,minFilter:Ze,generateMipmaps:!1,type:Ot,format:Ha,encoding:Gu(e)?e.encoding:sr,depthBuffer:!1},i=is(t);return i.depthBuffer=!e,this._pingPongRenderTarget=is(t),i}_compileMaterial(e){const t=new pt(Ri[0],e);this._renderer.compile(t,Hn)}_sceneToCubeUV(e,t,i,n){const o=new ot(90,1,t,i),c=[1,-1,1,1,1,1],l=[1,1,1,-1,-1,-1],h=this._renderer,p=h.autoClear,f=h.outputEncoding,m=h.toneMapping;h.getClearColor(es),h.toneMapping=Jt,h.outputEncoding=qe,h.autoClear=!1;const _=new pn({name:"PMREM.Background",side:ze,depthWrite:!1,depthTest:!1}),g=new pt(new wi,_);let b=!1;const u=e.background;u?u.isColor&&(_.color.copy(u),e.background=null,b=!0):(_.color.copy(es),b=!0);for(let d=0;d<6;d++){const T=d%3;T==0?(o.up.set(0,c[d],0),o.lookAt(l[d],0,0)):T==1?(o.up.set(0,0,c[d]),o.lookAt(0,l[d],0)):(o.up.set(0,c[d],0),o.lookAt(0,0,l[d])),on(n,T*ut,d>2?ut:0,ut,ut),h.setRenderTarget(n),b&&h.render(g,o),h.render(e,o)}g.geometry.dispose(),g.material.dispose(),h.toneMapping=m,h.outputEncoding=f,h.autoClear=p,e.background=u}_setEncoding(e,t){this._renderer.capabilities.isWebGL2===!0&&t.format===Xe&&t.type===Ot&&t.encoding===vi?e.value=Vt[qe]:e.value=Vt[t.encoding]}_textureToCubeUV(e,t){const i=this._renderer;e.isCubeTexture?this._cubemapShader==null&&(this._cubemapShader=rs()):this._equirectShader==null&&(this._equirectShader=ns());const n=e.isCubeTexture?this._cubemapShader:this._equirectShader,r=new pt(Ri[0],n),a=n.uniforms;a.envMap.value=e,e.isCubeTexture||a.texelSize.value.set(1/e.image.width,1/e.image.height),this._setEncoding(a.inputEncoding,e),this._setEncoding(a.outputEncoding,t.texture),on(t,0,0,3*ut,2*ut),i.setRenderTarget(t),i.render(r,Hn)}_applyPMREM(e){const t=this._renderer,i=t.autoClear;t.autoClear=!1;for(let n=1;n<Gs;n++){const r=Math.sqrt(an[n]*an[n]-an[n-1]*an[n-1]),a=ts[(n-1)%ts.length];this._blur(e,n-1,n,r,a)}t.autoClear=i}_blur(e,t,i,n,r){const a=this._pingPongRenderTarget;this._halfBlur(e,a,t,i,n,"latitudinal",r),this._halfBlur(a,e,i,i,n,"longitudinal",r)}_halfBlur(e,t,i,n,r,a,o){const c=this._renderer,l=this._blurMaterial;a!=="latitudinal"&&a!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const h=3,p=new pt(Ri[n],l),f=l.uniforms,m=Kr[i]-1,_=isFinite(r)?Math.PI/(2*m):2*Math.PI/(2*ui-1),g=r/_,b=isFinite(r)?1+Math.floor(h*g):ui;b>ui&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${b} samples when the maximum is set to ${ui}`);const u=[];let d=0;for(let A=0;A<ui;++A){const v=A/g,B=Math.exp(-v*v/2);u.push(B),A==0?d+=B:A<b&&(d+=2*B)}for(let A=0;A<u.length;A++)u[A]=u[A]/d;f.envMap.value=e.texture,f.samples.value=b,f.weights.value=u,f.latitudinal.value=a==="latitudinal",o&&(f.poleAxis.value=o),f.dTheta.value=_,f.mipInt.value=Bt-i,this._setEncoding(f.inputEncoding,e.texture),this._setEncoding(f.outputEncoding,e.texture);const T=Kr[n],M=3*Math.max(0,ut-2*T),w=(n===0?0:2*ut)+2*T*(n>Bt-mi?n-Bt+mi:0);on(t,M,w,3*T,2*T),c.setRenderTarget(t),c.render(p,Hn)}}function Gu(s){return s===void 0||s.type!==Ot?!1:s.encoding===qe||s.encoding===vi||s.encoding===rr}function Ou(){const s=[],e=[],t=[];let i=Bt;for(let n=0;n<Gs;n++){const r=Math.pow(2,i);e.push(r);let a=1/r;n>Bt-mi?a=Bs[n-Bt+mi-1]:n==0&&(a=0),t.push(a);const o=1/(r-1),c=-o/2,l=1+o/2,h=[c,c,l,c,l,l,c,c,l,l,c,l],p=6,f=6,m=3,_=2,g=1,b=new Float32Array(m*f*p),u=new Float32Array(_*f*p),d=new Float32Array(g*f*p);for(let M=0;M<p;M++){const w=M%3*2/3-1,A=M>2?0:-1,v=[w,A,0,w+2/3,A,0,w+2/3,A+1,0,w,A,0,w+2/3,A+1,0,w,A+1,0];b.set(v,m*f*M),u.set(h,_*f*M);const B=[M,M,M,M,M,M];d.set(B,g*f*M)}const T=new wt;T.setAttribute("position",new et(b,m)),T.setAttribute("uv",new et(u,_)),T.setAttribute("faceIndex",new et(d,g)),s.push(T),i>mi&&i--}return{_lodPlanes:s,_sizeLods:e,_sigmas:t}}function is(s){const e=new Ut(3*ut,3*ut,s);return e.texture.mapping=dn,e.texture.name="PMREM.cubeUv",e.scissorTest=!0,e}function on(s,e,t,i,n){s.viewport.set(e,t,i,n),s.scissor.set(e,t,i,n)}function Vu(s){const e=new Float32Array(s),t=new C(0,1,0);return new mn({name:"SphericalGaussianBlur",defines:{n:s},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:e},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:t},inputEncoding:{value:Vt[qe]},outputEncoding:{value:Vt[qe]}},vertexShader:hr(),fragmentShader:`precision mediump float;precision mediump int;varying vec3 vOutputDirection;uniform sampler2D envMap;uniform int samples;uniform float weights[n];uniform bool latitudinal;uniform float dTheta;uniform float mipInt;uniform vec3 poleAxis;
${dr()}
#define ENVMAP_TYPE_CUBE_UV
#include <cube_uv_reflection_fragment>
vec3 getSample(float theta,vec3 axis){float cosTheta=cos(theta);vec3 sampleDirection=vOutputDirection*cosTheta+cross(axis,vOutputDirection)*sin(theta)+axis*dot(axis,vOutputDirection)*(1.0-cosTheta);return bilinearCubeUV(envMap,sampleDirection,mipInt);}void main(){vec3 axis=latitudinal?poleAxis:cross(poleAxis,vOutputDirection);if(all(equal(axis,vec3(0.0)))){axis=vec3(vOutputDirection.z,0.0,-vOutputDirection.x);}axis=normalize(axis);gl_FragColor=vec4(0.0,0.0,0.0,1.0);gl_FragColor.rgb+=weights[0]*getSample(0.0,axis);for(int i=1;i<n;i++){if(i>=samples){break;}float theta=dTheta*float(i);gl_FragColor.rgb+=weights[i]*getSample(-1.0*theta,axis);gl_FragColor.rgb+=weights[i]*getSample(theta,axis);}gl_FragColor=linearToOutputTexel(gl_FragColor);}`,blending:Nt,depthTest:!1,depthWrite:!1})}function ns(){const s=new De(1,1);return new mn({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:s},inputEncoding:{value:Vt[qe]},outputEncoding:{value:Vt[qe]}},vertexShader:hr(),fragmentShader:`precision mediump float;precision mediump int;varying vec3 vOutputDirection;uniform sampler2D envMap;uniform vec2 texelSize;
${dr()}
#include <common>
void main(){gl_FragColor=vec4(0.0,0.0,0.0,1.0);vec3 outputDirection=normalize(vOutputDirection);vec2 uv=equirectUv(outputDirection);vec2 f=fract(uv/texelSize-0.5);uv-=f*texelSize;vec3 tl=envMapTexelToLinear(texture2D(envMap,uv)).rgb;uv.x+=texelSize.x;vec3 tr=envMapTexelToLinear(texture2D(envMap,uv)).rgb;uv.y+=texelSize.y;vec3 br=envMapTexelToLinear(texture2D(envMap,uv)).rgb;uv.x-=texelSize.x;vec3 bl=envMapTexelToLinear(texture2D(envMap,uv)).rgb;vec3 tm=mix(tl,tr,f.x);vec3 bm=mix(bl,br,f.x);gl_FragColor.rgb=mix(tm,bm,f.y);gl_FragColor=linearToOutputTexel(gl_FragColor);}`,blending:Nt,depthTest:!1,depthWrite:!1})}function rs(){return new mn({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:Vt[qe]},outputEncoding:{value:Vt[qe]}},vertexShader:hr(),fragmentShader:`precision mediump float;precision mediump int;varying vec3 vOutputDirection;uniform samplerCube envMap;
${dr()}
void main(){gl_FragColor=vec4(0.0,0.0,0.0,1.0);gl_FragColor.rgb=envMapTexelToLinear(textureCube(envMap,vec3(-vOutputDirection.x,vOutputDirection.yz))).rgb;gl_FragColor=linearToOutputTexel(gl_FragColor);}`,blending:Nt,depthTest:!1,depthWrite:!1})}function hr(){return"precision mediump float;precision mediump int;attribute vec3 position;attribute vec2 uv;attribute float faceIndex;varying vec3 vOutputDirection;vec3 getDirection(vec2 uv,float face){uv=2.0*uv-1.0;vec3 direction=vec3(uv,1.0);if(face==0.0){direction=direction.zyx;}else if(face==1.0){direction=direction.xzy;direction.xz*=-1.0;}else if(face==2.0){direction.x*=-1.0;}else if(face==3.0){direction=direction.zyx;direction.xz*=-1.0;}else if(face==4.0){direction=direction.xzy;direction.xy*=-1.0;}else if(face==5.0){direction.z*=-1.0;}return direction;}void main(){vOutputDirection=getDirection(uv,faceIndex);gl_Position=vec4(position,1.0);}"}function dr(){return`uniform int inputEncoding;uniform int outputEncoding;
#include <encodings_pars_fragment>
vec4 inputTexelToLinear(vec4 value){if(inputEncoding==0){return value;}else if(inputEncoding==1){return sRGBToLinear(value);}else if(inputEncoding==2){return RGBEToLinear(value);}else if(inputEncoding==3){return RGBMToLinear(value,7.0);}else if(inputEncoding==4){return RGBMToLinear(value,16.0);}else if(inputEncoding==5){return RGBDToLinear(value,256.0);}else{return GammaToLinear(value,2.2);}}vec4 linearToOutputTexel(vec4 value){if(outputEncoding==0){return value;}else if(outputEncoding==1){return LinearTosRGB(value);}else if(outputEncoding==2){return LinearToRGBE(value);}else if(outputEncoding==3){return LinearToRGBM(value,7.0);}else if(outputEncoding==4){return LinearToRGBM(value,16.0);}else if(outputEncoding==5){return LinearToRGBD(value,256.0);}else{return LinearToGamma(value,2.2);}}vec4 envMapTexelToLinear(vec4 color){return inputTexelToLinear(color);}`}function ku(s){let e=new WeakMap,t=null;function i(o){if(o&&o.isTexture&&o.isRenderTargetTexture===!1){const c=o.mapping,l=c===jn||c===Jn,h=c===un||c===hn;if(l||h){if(e.has(o))return e.get(o).texture;{const p=o.image;if(l&&p&&p.height>0||h&&p&&n(p)){const f=s.getRenderTarget();t===null&&(t=new Bu(s));const m=l?t.fromEquirectangular(o):t.fromCubemap(o);return e.set(o,m),s.setRenderTarget(f),o.addEventListener("dispose",r),m.texture}else return null}}}return o}function n(o){let c=0;const l=6;for(let h=0;h<l;h++)o[h]!==void 0&&c++;return c===l}function r(o){const c=o.target;c.removeEventListener("dispose",r);const l=e.get(c);l!==void 0&&(e.delete(c),l.dispose())}function a(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:i,dispose:a}}function Wu(s){const e={};function t(i){if(e[i]!==void 0)return e[i];let n;switch(i){case"WEBGL_depth_texture":n=s.getExtension("WEBGL_depth_texture")||s.getExtension("MOZ_WEBGL_depth_texture")||s.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":n=s.getExtension("EXT_texture_filter_anisotropic")||s.getExtension("MOZ_EXT_texture_filter_anisotropic")||s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":n=s.getExtension("WEBGL_compressed_texture_s3tc")||s.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":n=s.getExtension("WEBGL_compressed_texture_pvrtc")||s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:n=s.getExtension(i)}return e[i]=n,n}return{has:function(i){return t(i)!==null},init:function(i){i.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float")},get:function(i){const n=t(i);return n===null&&console.warn("THREE.WebGLRenderer: "+i+" extension not supported."),n}}}function Hu(s,e,t,i){const n={},r=new WeakMap;function a(p){const f=p.target;f.index!==null&&e.remove(f.index);for(const _ in f.attributes)e.remove(f.attributes[_]);f.removeEventListener("dispose",a),delete n[f.id];const m=r.get(f);m&&(e.remove(m),r.delete(f)),i.releaseStatesOfGeometry(f),f.isInstancedBufferGeometry===!0&&delete f._maxInstanceCount,t.memory.geometries--}function o(p,f){return n[f.id]===!0||(f.addEventListener("dispose",a),n[f.id]=!0,t.memory.geometries++),f}function c(p){const f=p.attributes;for(const _ in f)e.update(f[_],34962);const m=p.morphAttributes;for(const _ in m){const g=m[_];for(let b=0,u=g.length;b<u;b++)e.update(g[b],34962)}}function l(p){const f=[],m=p.index,_=p.attributes.position;let g=0;if(m!==null){const d=m.array;g=m.version;for(let T=0,M=d.length;T<M;T+=3){const w=d[T+0],A=d[T+1],v=d[T+2];f.push(w,A,A,v,v,w)}}else{const d=_.array;g=_.version;for(let T=0,M=d.length/3-1;T<M;T+=3){const w=T+0,A=T+1,v=T+2;f.push(w,A,A,v,v,w)}}const b=new(Cs(f)>65535?Fs:Rs)(f,1);b.version=g;const u=r.get(p);u&&e.remove(u),r.set(p,b)}function h(p){const f=r.get(p);if(f){const m=p.index;m!==null&&f.version<m.version&&l(p)}else l(p);return r.get(p)}return{get:o,update:c,getWireframeAttribute:h}}function Xu(s,e,t,i){const n=i.isWebGL2;let r;function a(f){r=f}let o,c;function l(f){o=f.type,c=f.bytesPerElement}function h(f,m){s.drawElements(r,m,o,f*c),t.update(m,r,1)}function p(f,m,_){if(_===0)return;let g,b;if(n)g=s,b="drawElementsInstanced";else if(g=e.get("ANGLE_instanced_arrays"),b="drawElementsInstancedANGLE",g===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}g[b](r,m,o,f*c,_),t.update(m,r,_)}this.setMode=a,this.setIndex=l,this.render=h,this.renderInstances=p}function qu(s){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function i(r,a,o){switch(t.calls++,a){case 4:t.triangles+=o*(r/3);break;case 1:t.lines+=o*(r/2);break;case 3:t.lines+=o*(r-1);break;case 2:t.lines+=o*r;break;case 0:t.points+=o*r;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",a);break}}function n(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:n,update:i}}class fr extends ct{constructor(e=null,t=1,i=1,n=1){super(null),this.image={data:e,width:t,height:i,depth:n},this.magFilter=Ze,this.minFilter=Ze,this.wrapR=$e,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}fr.prototype.isDataTexture2DArray=!0;function Yu(s,e){return s[0]-e[0]}function Zu(s,e){return Math.abs(e[1])-Math.abs(s[1])}function ss(s,e){let t=1;const i=e.isInterleavedBufferAttribute?e.data.array:e.array;i instanceof Int8Array?t=127:i instanceof Int16Array?t=32767:i instanceof Int32Array?t=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",i),s.divideScalar(t)}function ju(s,e,t){const i={},n=new Float32Array(8),r=new WeakMap,a=new C,o=[];for(let l=0;l<8;l++)o[l]=[l,0];function c(l,h,p,f){const m=l.morphTargetInfluences;if(e.isWebGL2===!0){const _=h.morphAttributes.position.length;let g=r.get(h);if(g===void 0||g.count!==_){g!==void 0&&g.texture.dispose();const d=h.morphAttributes.normal!==void 0,T=h.morphAttributes.position,M=h.morphAttributes.normal||[],w=h.attributes.position.count,A=d===!0?2:1;let v=w*A,B=1;v>e.maxTextureSize&&(B=Math.ceil(v/e.maxTextureSize),v=e.maxTextureSize);const X=new Float32Array(v*B*4*_),O=new fr(X,v,B,_);O.format=Xe,O.type=zt;const L=A*4;for(let j=0;j<_;j++){const I=T[j],U=M[j],G=v*B*4*j;for(let z=0;z<I.count;z++){a.fromBufferAttribute(I,z),I.normalized===!0&&ss(a,I);const N=z*L;X[G+N+0]=a.x,X[G+N+1]=a.y,X[G+N+2]=a.z,X[G+N+3]=0,d===!0&&(a.fromBufferAttribute(U,z),U.normalized===!0&&ss(a,U),X[G+N+4]=a.x,X[G+N+5]=a.y,X[G+N+6]=a.z,X[G+N+7]=0)}}g={count:_,texture:O,size:new De(v,B)},r.set(h,g)}let b=0;for(let d=0;d<m.length;d++)b+=m[d];const u=h.morphTargetsRelative?1:1-b;f.getUniforms().setValue(s,"morphTargetBaseInfluence",u),f.getUniforms().setValue(s,"morphTargetInfluences",m),f.getUniforms().setValue(s,"morphTargetsTexture",g.texture,t),f.getUniforms().setValue(s,"morphTargetsTextureSize",g.size)}else{const _=m===void 0?0:m.length;let g=i[h.id];if(g===void 0||g.length!==_){g=[];for(let M=0;M<_;M++)g[M]=[M,0];i[h.id]=g}for(let M=0;M<_;M++){const w=g[M];w[0]=M,w[1]=m[M]}g.sort(Zu);for(let M=0;M<8;M++)M<_&&g[M][1]?(o[M][0]=g[M][0],o[M][1]=g[M][1]):(o[M][0]=Number.MAX_SAFE_INTEGER,o[M][1]=0);o.sort(Yu);const b=h.morphAttributes.position,u=h.morphAttributes.normal;let d=0;for(let M=0;M<8;M++){const w=o[M],A=w[0],v=w[1];A!==Number.MAX_SAFE_INTEGER&&v?(b&&h.getAttribute("morphTarget"+M)!==b[A]&&h.setAttribute("morphTarget"+M,b[A]),u&&h.getAttribute("morphNormal"+M)!==u[A]&&h.setAttribute("morphNormal"+M,u[A]),n[M]=v,d+=v):(b&&h.hasAttribute("morphTarget"+M)===!0&&h.deleteAttribute("morphTarget"+M),u&&h.hasAttribute("morphNormal"+M)===!0&&h.deleteAttribute("morphNormal"+M),n[M]=0)}const T=h.morphTargetsRelative?1:1-d;f.getUniforms().setValue(s,"morphTargetBaseInfluence",T),f.getUniforms().setValue(s,"morphTargetInfluences",n)}}return{update:c}}function Ju(s,e,t,i){let n=new WeakMap;function r(c){const l=i.render.frame,h=c.geometry,p=e.get(c,h);return n.get(p)!==l&&(e.update(p),n.set(p,l)),c.isInstancedMesh&&(c.hasEventListener("dispose",o)===!1&&c.addEventListener("dispose",o),t.update(c.instanceMatrix,34962),c.instanceColor!==null&&t.update(c.instanceColor,34962)),p}function a(){n=new WeakMap}function o(c){const l=c.target;l.removeEventListener("dispose",o),t.remove(l.instanceMatrix),l.instanceColor!==null&&t.remove(l.instanceColor)}return{update:r,dispose:a}}class Os extends ct{constructor(e=null,t=1,i=1,n=1){super(null),this.image={data:e,width:t,height:i,depth:n},this.magFilter=Ze,this.minFilter=Ze,this.wrapR=$e,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Os.prototype.isDataTexture3D=!0;const Vs=new ct,$u=new fr,Qu=new Os,ks=new cr,as=[],os=[],ls=new Float32Array(16),cs=new Float32Array(9),us=new Float32Array(4);function Ti(s,e,t){const i=s[0];if(i<=0||i>0)return s;const n=e*t;let r=as[n];if(r===void 0&&(r=new Float32Array(n),as[n]=r),e!==0){i.toArray(r,0);for(let a=1,o=0;a!==e;++a)o+=t,s[a].toArray(r,o)}return r}function Ye(s,e){if(s.length!==e.length)return!1;for(let t=0,i=s.length;t<i;t++)if(s[t]!==e[t])return!1;return!0}function ke(s,e){for(let t=0,i=e.length;t<i;t++)s[t]=e[t]}function Ws(s,e){let t=os[e];t===void 0&&(t=new Int32Array(e),os[e]=t);for(let i=0;i!==e;++i)t[i]=s.allocateTextureUnit();return t}function Ku(s,e){const t=this.cache;t[0]!==e&&(s.uniform1f(this.addr,e),t[0]=e)}function eh(s,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(s.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Ye(t,e))return;s.uniform2fv(this.addr,e),ke(t,e)}}function th(s,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(s.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(s.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(Ye(t,e))return;s.uniform3fv(this.addr,e),ke(t,e)}}function ih(s,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(s.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Ye(t,e))return;s.uniform4fv(this.addr,e),ke(t,e)}}function nh(s,e){const t=this.cache,i=e.elements;if(i===void 0){if(Ye(t,e))return;s.uniformMatrix2fv(this.addr,!1,e),ke(t,e)}else{if(Ye(t,i))return;us.set(i),s.uniformMatrix2fv(this.addr,!1,us),ke(t,i)}}function rh(s,e){const t=this.cache,i=e.elements;if(i===void 0){if(Ye(t,e))return;s.uniformMatrix3fv(this.addr,!1,e),ke(t,e)}else{if(Ye(t,i))return;cs.set(i),s.uniformMatrix3fv(this.addr,!1,cs),ke(t,i)}}function sh(s,e){const t=this.cache,i=e.elements;if(i===void 0){if(Ye(t,e))return;s.uniformMatrix4fv(this.addr,!1,e),ke(t,e)}else{if(Ye(t,i))return;ls.set(i),s.uniformMatrix4fv(this.addr,!1,ls),ke(t,i)}}function ah(s,e){const t=this.cache;t[0]!==e&&(s.uniform1i(this.addr,e),t[0]=e)}function oh(s,e){const t=this.cache;Ye(t,e)||(s.uniform2iv(this.addr,e),ke(t,e))}function lh(s,e){const t=this.cache;Ye(t,e)||(s.uniform3iv(this.addr,e),ke(t,e))}function ch(s,e){const t=this.cache;Ye(t,e)||(s.uniform4iv(this.addr,e),ke(t,e))}function uh(s,e){const t=this.cache;t[0]!==e&&(s.uniform1ui(this.addr,e),t[0]=e)}function hh(s,e){const t=this.cache;Ye(t,e)||(s.uniform2uiv(this.addr,e),ke(t,e))}function dh(s,e){const t=this.cache;Ye(t,e)||(s.uniform3uiv(this.addr,e),ke(t,e))}function fh(s,e){const t=this.cache;Ye(t,e)||(s.uniform4uiv(this.addr,e),ke(t,e))}function ph(s,e,t){const i=this.cache,n=t.allocateTextureUnit();i[0]!==n&&(s.uniform1i(this.addr,n),i[0]=n),t.safeSetTexture2D(e||Vs,n)}function mh(s,e,t){const i=this.cache,n=t.allocateTextureUnit();i[0]!==n&&(s.uniform1i(this.addr,n),i[0]=n),t.setTexture3D(e||Qu,n)}function gh(s,e,t){const i=this.cache,n=t.allocateTextureUnit();i[0]!==n&&(s.uniform1i(this.addr,n),i[0]=n),t.safeSetTextureCube(e||ks,n)}function _h(s,e,t){const i=this.cache,n=t.allocateTextureUnit();i[0]!==n&&(s.uniform1i(this.addr,n),i[0]=n),t.setTexture2DArray(e||$u,n)}function xh(s){switch(s){case 5126:return Ku;case 35664:return eh;case 35665:return th;case 35666:return ih;case 35674:return nh;case 35675:return rh;case 35676:return sh;case 5124:case 35670:return ah;case 35667:case 35671:return oh;case 35668:case 35672:return lh;case 35669:case 35673:return ch;case 5125:return uh;case 36294:return hh;case 36295:return dh;case 36296:return fh;case 35678:case 36198:case 36298:case 36306:case 35682:return ph;case 35679:case 36299:case 36307:return mh;case 35680:case 36300:case 36308:case 36293:return gh;case 36289:case 36303:case 36311:case 36292:return _h}}function vh(s,e){s.uniform1fv(this.addr,e)}function Mh(s,e){const t=Ti(e,this.size,2);s.uniform2fv(this.addr,t)}function yh(s,e){const t=Ti(e,this.size,3);s.uniform3fv(this.addr,t)}function Sh(s,e){const t=Ti(e,this.size,4);s.uniform4fv(this.addr,t)}function bh(s,e){const t=Ti(e,this.size,4);s.uniformMatrix2fv(this.addr,!1,t)}function wh(s,e){const t=Ti(e,this.size,9);s.uniformMatrix3fv(this.addr,!1,t)}function Th(s,e){const t=Ti(e,this.size,16);s.uniformMatrix4fv(this.addr,!1,t)}function Eh(s,e){s.uniform1iv(this.addr,e)}function Ah(s,e){s.uniform2iv(this.addr,e)}function Lh(s,e){s.uniform3iv(this.addr,e)}function Ch(s,e){s.uniform4iv(this.addr,e)}function Dh(s,e){s.uniform1uiv(this.addr,e)}function Ph(s,e){s.uniform2uiv(this.addr,e)}function Rh(s,e){s.uniform3uiv(this.addr,e)}function Fh(s,e){s.uniform4uiv(this.addr,e)}function Ih(s,e,t){const i=e.length,n=Ws(t,i);s.uniform1iv(this.addr,n);for(let r=0;r!==i;++r)t.safeSetTexture2D(e[r]||Vs,n[r])}function zh(s,e,t){const i=e.length,n=Ws(t,i);s.uniform1iv(this.addr,n);for(let r=0;r!==i;++r)t.safeSetTextureCube(e[r]||ks,n[r])}function Nh(s){switch(s){case 5126:return vh;case 35664:return Mh;case 35665:return yh;case 35666:return Sh;case 35674:return bh;case 35675:return wh;case 35676:return Th;case 5124:case 35670:return Eh;case 35667:case 35671:return Ah;case 35668:case 35672:return Lh;case 35669:case 35673:return Ch;case 5125:return Dh;case 36294:return Ph;case 36295:return Rh;case 36296:return Fh;case 35678:case 36198:case 36298:case 36306:case 35682:return Ih;case 35680:case 36300:case 36308:case 36293:return zh}}function Uh(s,e,t){this.id=s,this.addr=t,this.cache=[],this.setValue=xh(e.type)}function Hs(s,e,t){this.id=s,this.addr=t,this.cache=[],this.size=e.size,this.setValue=Nh(e.type)}Hs.prototype.updateCache=function(s){const e=this.cache;s instanceof Float32Array&&e.length!==s.length&&(this.cache=new Float32Array(s.length)),ke(e,s)};function Xs(s){this.id=s,this.seq=[],this.map={}}Xs.prototype.setValue=function(s,e,t){const i=this.seq;for(let n=0,r=i.length;n!==r;++n){const a=i[n];a.setValue(s,e[a.id],t)}};const qn=/(\w+)(\])?(\[|\.)?/g;function hs(s,e){s.seq.push(e),s.map[e.id]=e}function Bh(s,e,t){const i=s.name,n=i.length;for(qn.lastIndex=0;;){const r=qn.exec(i),a=qn.lastIndex;let o=r[1];const c=r[2]==="]",l=r[3];if(c&&(o=o|0),l===void 0||l==="["&&a+2===n){hs(t,l===void 0?new Uh(o,s,e):new Hs(o,s,e));break}else{let p=t.map[o];p===void 0&&(p=new Xs(o),hs(t,p)),t=p}}}function Gt(s,e){this.seq=[],this.map={};const t=s.getProgramParameter(e,35718);for(let i=0;i<t;++i){const n=s.getActiveUniform(e,i),r=s.getUniformLocation(e,n.name);Bh(n,r,this)}}Gt.prototype.setValue=function(s,e,t,i){const n=this.map[e];n!==void 0&&n.setValue(s,t,i)};Gt.prototype.setOptional=function(s,e,t){const i=e[t];i!==void 0&&this.setValue(s,t,i)};Gt.upload=function(s,e,t,i){for(let n=0,r=e.length;n!==r;++n){const a=e[n],o=t[a.id];o.needsUpdate!==!1&&a.setValue(s,o.value,i)}};Gt.seqWithValue=function(s,e){const t=[];for(let i=0,n=s.length;i!==n;++i){const r=s[i];r.id in e&&t.push(r)}return t};function ds(s,e,t){const i=s.createShader(e);return s.shaderSource(i,t),s.compileShader(i),i}let Gh=0;function Oh(s){const e=s.split(`
`);for(let t=0;t<e.length;t++)e[t]=t+1+": "+e[t];return e.join(`
`)}function qs(s){switch(s){case qe:return["Linear","( value )"];case vi:return["sRGB","( value )"];case sr:return["RGBE","( value )"];case Es:return["RGBM","( value, 7.0 )"];case As:return["RGBM","( value, 16.0 )"];case Ls:return["RGBD","( value, 256.0 )"];case rr:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case Lo:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",s),["Linear","( value )"]}}function fs(s,e,t){const i=s.getShaderParameter(e,35713),n=s.getShaderInfoLog(e).trim();return i&&n===""?"":t.toUpperCase()+`

`+n+`

`+Oh(s.getShaderSource(e))}function di(s,e){const t=qs(e);return"vec4 "+s+"( vec4 value ) { return "+t[0]+"ToLinear"+t[1]+"; }"}function Vh(s,e){const t=qs(e);return"vec4 "+s+"( vec4 value ) { return LinearTo"+t[0]+t[1]+"; }"}function kh(s,e){let t;switch(e){case Ca:t="Linear";break;case Da:t="Reinhard";break;case Pa:t="OptimizedCineon";break;case Ra:t="ACESFilmic";break;case Fa:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+s+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function Wh(s){return[s.extensionDerivatives||s.envMapCubeUV||s.bumpMap||s.tangentSpaceNormalMap||s.clearcoatNormalMap||s.flatShading||s.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(s.extensionFragDepth||s.logarithmicDepthBuffer)&&s.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",s.extensionDrawBuffers&&s.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(s.extensionShaderTextureLOD||s.envMap||s.transmission)&&s.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Ii).join(`
`)}function Hh(s){const e=[];for(const t in s){const i=s[t];i!==!1&&e.push("#define "+t+" "+i)}return e.join(`
`)}function Xh(s,e){const t={},i=s.getProgramParameter(e,35721);for(let n=0;n<i;n++){const r=s.getActiveAttrib(e,n),a=r.name;let o=1;r.type===35674&&(o=2),r.type===35675&&(o=3),r.type===35676&&(o=4),t[a]={type:r.type,location:s.getAttribLocation(e,a),locationSize:o}}return t}function Ii(s){return s!==""}function ps(s,e){return s.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function ms(s,e){return s.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const qh=/^[ \t]*#include +<([\w\d./]+)>/gm;function ir(s){return s.replace(qh,Yh)}function Yh(s,e){const t=Me[e];if(t===void 0)throw new Error("Can not resolve #include <"+e+">");return ir(t)}const Zh=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,jh=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function gs(s){return s.replace(jh,Ys).replace(Zh,Jh)}function Jh(s,e,t,i){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),Ys(s,e,t,i)}function Ys(s,e,t,i){let n="";for(let r=parseInt(e);r<parseInt(t);r++)n+=i.replace(/\[\s*i\s*\]/g,"[ "+r+" ]").replace(/UNROLLED_LOOP_INDEX/g,r);return n}function _s(s){let e="precision "+s.precision+` float;
precision `+s.precision+" int;";return s.precision==="highp"?e+=`
#define HIGH_PRECISION`:s.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:s.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function $h(s){let e="SHADOWMAP_TYPE_BASIC";return s.shadowMapType===ys?e="SHADOWMAP_TYPE_PCF":s.shadowMapType===aa?e="SHADOWMAP_TYPE_PCF_SOFT":s.shadowMapType===Fi&&(e="SHADOWMAP_TYPE_VSM"),e}function Qh(s){let e="ENVMAP_TYPE_CUBE";if(s.envMap)switch(s.envMapMode){case un:case hn:e="ENVMAP_TYPE_CUBE";break;case dn:case nr:e="ENVMAP_TYPE_CUBE_UV";break}return e}function Kh(s){let e="ENVMAP_MODE_REFLECTION";if(s.envMap)switch(s.envMapMode){case hn:case nr:e="ENVMAP_MODE_REFRACTION";break}return e}function ed(s){let e="ENVMAP_BLENDING_NONE";if(s.envMap)switch(s.combine){case ws:e="ENVMAP_BLENDING_MULTIPLY";break;case Aa:e="ENVMAP_BLENDING_MIX";break;case La:e="ENVMAP_BLENDING_ADD";break}return e}function td(s,e,t,i){const n=s.getContext(),r=t.defines;let a=t.vertexShader,o=t.fragmentShader;const c=$h(t),l=Qh(t),h=Kh(t),p=ed(t),f=s.gammaFactor>0?s.gammaFactor:1,m=t.isWebGL2?"":Wh(t),_=Hh(r),g=n.createProgram();let b,u,d=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(b=[_].filter(Ii).join(`
`),b.length>0&&(b+=`
`),u=[m,_].filter(Ii).join(`
`),u.length>0&&(u+=`
`)):(b=[_s(t),"#define SHADER_NAME "+t.shaderName,_,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+f,"#define MAX_BONES "+t.maxBones,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+h:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.displacementMap&&t.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularTintMap?"#define USE_SPECULARTINTMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.useVertexTexture?"#define BONE_TEXTURE":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphTargets&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",t.morphTargets&&t.isWebGL2?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+c:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Ii).join(`
`),u=[m,_s(t),"#define SHADER_NAME "+t.shaderName,_,"#define GAMMA_FACTOR "+f,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+l:"",t.envMap?"#define "+h:"",t.envMap?"#define "+p:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularTintMap?"#define USE_SPECULARTINTMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.sheen?"#define USE_SHEEN":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+c:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(t.extensionShaderTextureLOD||t.envMap)&&t.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==Jt?"#define TONE_MAPPING":"",t.toneMapping!==Jt?Me.tonemapping_pars_fragment:"",t.toneMapping!==Jt?kh("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.format===Ui?"#define OPAQUE":"",Me.encodings_pars_fragment,t.map?di("mapTexelToLinear",t.mapEncoding):"",t.matcap?di("matcapTexelToLinear",t.matcapEncoding):"",t.envMap?di("envMapTexelToLinear",t.envMapEncoding):"",t.emissiveMap?di("emissiveMapTexelToLinear",t.emissiveMapEncoding):"",t.specularTintMap?di("specularTintMapTexelToLinear",t.specularTintMapEncoding):"",t.lightMap?di("lightMapTexelToLinear",t.lightMapEncoding):"",Vh("linearToOutputTexel",t.outputEncoding),t.depthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(Ii).join(`
`)),a=ir(a),a=ps(a,t),a=ms(a,t),o=ir(o),o=ps(o,t),o=ms(o,t),a=gs(a),o=gs(o),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(d=`#version 300 es
`,b=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+b,u=["#define varying in",t.glslVersion===Gr?"":"out highp vec4 pc_fragColor;",t.glslVersion===Gr?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+u);const T=d+b+a,M=d+u+o,w=ds(n,35633,T),A=ds(n,35632,M);if(n.attachShader(g,w),n.attachShader(g,A),t.index0AttributeName!==void 0?n.bindAttribLocation(g,0,t.index0AttributeName):t.morphTargets===!0&&n.bindAttribLocation(g,0,"position"),n.linkProgram(g),s.debug.checkShaderErrors){const X=n.getProgramInfoLog(g).trim(),O=n.getShaderInfoLog(w).trim(),L=n.getShaderInfoLog(A).trim();let j=!0,I=!0;if(n.getProgramParameter(g,35714)===!1){j=!1;const U=fs(n,w,"vertex"),G=fs(n,A,"fragment");console.error("THREE.WebGLProgram: Shader Error "+n.getError()+" - VALIDATE_STATUS "+n.getProgramParameter(g,35715)+`

Program Info Log: `+X+`
`+U+`
`+G)}else X!==""?console.warn("THREE.WebGLProgram: Program Info Log:",X):(O===""||L==="")&&(I=!1);I&&(this.diagnostics={runnable:j,programLog:X,vertexShader:{log:O,prefix:b},fragmentShader:{log:L,prefix:u}})}n.deleteShader(w),n.deleteShader(A);let v;this.getUniforms=function(){return v===void 0&&(v=new Gt(n,g)),v};let B;return this.getAttributes=function(){return B===void 0&&(B=Xh(n,g)),B},this.destroy=function(){i.releaseStatesOfProgram(this),n.deleteProgram(g),this.program=void 0},this.name=t.shaderName,this.id=Gh++,this.cacheKey=e,this.usedTimes=1,this.program=g,this.vertexShader=w,this.fragmentShader=A,this}function id(s,e,t,i,n,r,a){const o=[],c=n.isWebGL2,l=n.logarithmicDepthBuffer,h=n.floatVertexTextures,p=n.maxVertexUniforms,f=n.vertexTextures;let m=n.precision;const _={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},g=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoat","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","specularIntensityMap","specularTintMap","specularTintMapEncoding","roughnessMap","metalnessMap","gradientMap","alphaMap","alphaTest","combine","vertexColors","vertexAlphas","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","morphTargetsCount","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","format","sheen","transmission","transmissionMap","thicknessMap"];function b(v){const X=v.skeleton.bones;if(h)return 1024;{const L=Math.floor((p-20)/4),j=Math.min(L,X.length);return j<X.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+X.length+" bones. This GPU supports "+j+"."),0):j}}function u(v){let B;return v&&v.isTexture?B=v.encoding:v&&v.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),B=v.texture.encoding):B=qe,c&&v&&v.isTexture&&v.format===Xe&&v.type===Ot&&v.encoding===vi&&(B=qe),B}function d(v,B,X,O,L){const j=O.fog,I=v.isMeshStandardMaterial?O.environment:null,U=(v.isMeshStandardMaterial?t:e).get(v.envMap||I),G=_[v.type],z=L.isSkinnedMesh?b(L):0;v.precision!==null&&(m=n.getMaxPrecision(v.precision),m!==v.precision&&console.warn("THREE.WebGLProgram.getParameters:",v.precision,"not supported, using",m,"instead."));let N,Y;if(G){const H=dt[G];N=H.vertexShader,Y=H.fragmentShader}else N=v.vertexShader,Y=v.fragmentShader;const ne=s.getRenderTarget(),oe=v.alphaTest>0,te=v.clearcoat>0;return{isWebGL2:c,shaderID:G,shaderName:v.type,vertexShader:N,fragmentShader:Y,defines:v.defines,isRawShaderMaterial:v.isRawShaderMaterial===!0,glslVersion:v.glslVersion,precision:m,instancing:L.isInstancedMesh===!0,instancingColor:L.isInstancedMesh===!0&&L.instanceColor!==null,supportsVertexTextures:f,outputEncoding:ne!==null?u(ne.texture):s.outputEncoding,map:!!v.map,mapEncoding:u(v.map),matcap:!!v.matcap,matcapEncoding:u(v.matcap),envMap:!!U,envMapMode:U&&U.mapping,envMapEncoding:u(U),envMapCubeUV:!!U&&(U.mapping===dn||U.mapping===nr),lightMap:!!v.lightMap,lightMapEncoding:u(v.lightMap),aoMap:!!v.aoMap,emissiveMap:!!v.emissiveMap,emissiveMapEncoding:u(v.emissiveMap),bumpMap:!!v.bumpMap,normalMap:!!v.normalMap,objectSpaceNormalMap:v.normalMapType===Ro,tangentSpaceNormalMap:v.normalMapType===Po,clearcoat:te,clearcoatMap:te&&!!v.clearcoatMap,clearcoatRoughnessMap:te&&!!v.clearcoatRoughnessMap,clearcoatNormalMap:te&&!!v.clearcoatNormalMap,displacementMap:!!v.displacementMap,roughnessMap:!!v.roughnessMap,metalnessMap:!!v.metalnessMap,specularMap:!!v.specularMap,specularIntensityMap:!!v.specularIntensityMap,specularTintMap:!!v.specularTintMap,specularTintMapEncoding:u(v.specularTintMap),alphaMap:!!v.alphaMap,alphaTest:oe,gradientMap:!!v.gradientMap,sheen:v.sheen>0,transmission:v.transmission>0,transmissionMap:!!v.transmissionMap,thicknessMap:!!v.thicknessMap,combine:v.combine,vertexTangents:!!v.normalMap&&!!L.geometry&&!!L.geometry.attributes.tangent,vertexColors:v.vertexColors,vertexAlphas:v.vertexColors===!0&&!!L.geometry&&!!L.geometry.attributes.color&&L.geometry.attributes.color.itemSize===4,vertexUvs:!!v.map||!!v.bumpMap||!!v.normalMap||!!v.specularMap||!!v.alphaMap||!!v.emissiveMap||!!v.roughnessMap||!!v.metalnessMap||!!v.clearcoatMap||!!v.clearcoatRoughnessMap||!!v.clearcoatNormalMap||!!v.displacementMap||!!v.transmissionMap||!!v.thicknessMap||!!v.specularIntensityMap||!!v.specularTintMap,uvsVertexOnly:!(!!v.map||!!v.bumpMap||!!v.normalMap||!!v.specularMap||!!v.alphaMap||!!v.emissiveMap||!!v.roughnessMap||!!v.metalnessMap||!!v.clearcoatNormalMap||v.transmission>0||!!v.transmissionMap||!!v.thicknessMap||!!v.specularIntensityMap||!!v.specularTintMap)&&!!v.displacementMap,fog:!!j,useFog:v.fog,fogExp2:j&&j.isFogExp2,flatShading:!!v.flatShading,sizeAttenuation:v.sizeAttenuation,logarithmicDepthBuffer:l,skinning:L.isSkinnedMesh===!0&&z>0,maxBones:z,useVertexTexture:h,morphTargets:!!L.geometry&&!!L.geometry.morphAttributes.position,morphNormals:!!L.geometry&&!!L.geometry.morphAttributes.normal,morphTargetsCount:!!L.geometry&&!!L.geometry.morphAttributes.position?L.geometry.morphAttributes.position.length:0,numDirLights:B.directional.length,numPointLights:B.point.length,numSpotLights:B.spot.length,numRectAreaLights:B.rectArea.length,numHemiLights:B.hemi.length,numDirLightShadows:B.directionalShadowMap.length,numPointLightShadows:B.pointShadowMap.length,numSpotLightShadows:B.spotShadowMap.length,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,format:v.format,dithering:v.dithering,shadowMapEnabled:s.shadowMap.enabled&&X.length>0,shadowMapType:s.shadowMap.type,toneMapping:v.toneMapped?s.toneMapping:Jt,physicallyCorrectLights:s.physicallyCorrectLights,premultipliedAlpha:v.premultipliedAlpha,doubleSided:v.side===gi,flipSided:v.side===ze,depthPacking:v.depthPacking!==void 0?v.depthPacking:!1,index0AttributeName:v.index0AttributeName,extensionDerivatives:v.extensions&&v.extensions.derivatives,extensionFragDepth:v.extensions&&v.extensions.fragDepth,extensionDrawBuffers:v.extensions&&v.extensions.drawBuffers,extensionShaderTextureLOD:v.extensions&&v.extensions.shaderTextureLOD,rendererExtensionFragDepth:c||i.has("EXT_frag_depth"),rendererExtensionDrawBuffers:c||i.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:c||i.has("EXT_shader_texture_lod"),customProgramCacheKey:v.customProgramCacheKey()}}function T(v){const B=[];if(v.shaderID?B.push(v.shaderID):(B.push(v.fragmentShader),B.push(v.vertexShader)),v.defines!==void 0)for(const X in v.defines)B.push(X),B.push(v.defines[X]);if(v.isRawShaderMaterial===!1){for(let X=0;X<g.length;X++)B.push(v[g[X]]);B.push(s.outputEncoding),B.push(s.gammaFactor)}return B.push(v.customProgramCacheKey),B.join()}function M(v){const B=_[v.type];let X;if(B){const O=dt[B];X=Ko.clone(O.uniforms)}else X=v.uniforms;return X}function w(v,B){let X;for(let O=0,L=o.length;O<L;O++){const j=o[O];if(j.cacheKey===B){X=j,++X.usedTimes;break}}return X===void 0&&(X=new td(s,B,v,r),o.push(X)),X}function A(v){if(--v.usedTimes===0){const B=o.indexOf(v);o[B]=o[o.length-1],o.pop(),v.destroy()}}return{getParameters:d,getProgramCacheKey:T,getUniforms:M,acquireProgram:w,releaseProgram:A,programs:o}}function nd(){let s=new WeakMap;function e(r){let a=s.get(r);return a===void 0&&(a={},s.set(r,a)),a}function t(r){s.delete(r)}function i(r,a,o){s.get(r)[a]=o}function n(){s=new WeakMap}return{get:e,remove:t,update:i,dispose:n}}function rd(s,e){return s.groupOrder!==e.groupOrder?s.groupOrder-e.groupOrder:s.renderOrder!==e.renderOrder?s.renderOrder-e.renderOrder:s.program!==e.program?s.program.id-e.program.id:s.material.id!==e.material.id?s.material.id-e.material.id:s.z!==e.z?s.z-e.z:s.id-e.id}function xs(s,e){return s.groupOrder!==e.groupOrder?s.groupOrder-e.groupOrder:s.renderOrder!==e.renderOrder?s.renderOrder-e.renderOrder:s.z!==e.z?e.z-s.z:s.id-e.id}function vs(s){const e=[];let t=0;const i=[],n=[],r=[],a={id:-1};function o(){t=0,i.length=0,n.length=0,r.length=0}function c(m,_,g,b,u,d){let T=e[t];const M=s.get(g);return T===void 0?(T={id:m.id,object:m,geometry:_,material:g,program:M.program||a,groupOrder:b,renderOrder:m.renderOrder,z:u,group:d},e[t]=T):(T.id=m.id,T.object=m,T.geometry=_,T.material=g,T.program=M.program||a,T.groupOrder=b,T.renderOrder=m.renderOrder,T.z=u,T.group=d),t++,T}function l(m,_,g,b,u,d){const T=c(m,_,g,b,u,d);g.transmission>0?n.push(T):g.transparent===!0?r.push(T):i.push(T)}function h(m,_,g,b,u,d){const T=c(m,_,g,b,u,d);g.transmission>0?n.unshift(T):g.transparent===!0?r.unshift(T):i.unshift(T)}function p(m,_){i.length>1&&i.sort(m||rd),n.length>1&&n.sort(_||xs),r.length>1&&r.sort(_||xs)}function f(){for(let m=t,_=e.length;m<_;m++){const g=e[m];if(g.id===null)break;g.id=null,g.object=null,g.geometry=null,g.material=null,g.program=null,g.group=null}}return{opaque:i,transmissive:n,transparent:r,init:o,push:l,unshift:h,finish:f,sort:p}}function sd(s){let e=new WeakMap;function t(n,r){let a;return e.has(n)===!1?(a=new vs(s),e.set(n,[a])):r>=e.get(n).length?(a=new vs(s),e.get(n).push(a)):a=e.get(n)[r],a}function i(){e=new WeakMap}return{get:t,dispose:i}}function ad(){const s={};return{get:function(e){if(s[e.id]!==void 0)return s[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new C,color:new Ae};break;case"SpotLight":t={position:new C,direction:new C,color:new Ae,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new C,color:new Ae,distance:0,decay:0};break;case"HemisphereLight":t={direction:new C,skyColor:new Ae,groundColor:new Ae};break;case"RectAreaLight":t={color:new Ae,position:new C,halfWidth:new C,halfHeight:new C};break}return s[e.id]=t,t}}}function od(){const s={};return{get:function(e){if(s[e.id]!==void 0)return s[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new De};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new De};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new De,shadowCameraNear:1,shadowCameraFar:1e3};break}return s[e.id]=t,t}}}let ld=0;function cd(s,e){return(e.castShadow?1:0)-(s.castShadow?1:0)}function ud(s,e){const t=new ad,i=od(),n={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let h=0;h<9;h++)n.probe.push(new C);const r=new C,a=new Be,o=new Be;function c(h,p){let f=0,m=0,_=0;for(let X=0;X<9;X++)n.probe[X].set(0,0,0);let g=0,b=0,u=0,d=0,T=0,M=0,w=0,A=0;h.sort(cd);const v=p!==!0?Math.PI:1;for(let X=0,O=h.length;X<O;X++){const L=h[X],j=L.color,I=L.intensity,U=L.distance,G=L.shadow&&L.shadow.map?L.shadow.map.texture:null;if(L.isAmbientLight)f+=j.r*I*v,m+=j.g*I*v,_+=j.b*I*v;else if(L.isLightProbe)for(let z=0;z<9;z++)n.probe[z].addScaledVector(L.sh.coefficients[z],I);else if(L.isDirectionalLight){const z=t.get(L);if(z.color.copy(L.color).multiplyScalar(L.intensity*v),L.castShadow){const N=L.shadow,Y=i.get(L);Y.shadowBias=N.bias,Y.shadowNormalBias=N.normalBias,Y.shadowRadius=N.radius,Y.shadowMapSize=N.mapSize,n.directionalShadow[g]=Y,n.directionalShadowMap[g]=G,n.directionalShadowMatrix[g]=L.shadow.matrix,M++}n.directional[g]=z,g++}else if(L.isSpotLight){const z=t.get(L);if(z.position.setFromMatrixPosition(L.matrixWorld),z.color.copy(j).multiplyScalar(I*v),z.distance=U,z.coneCos=Math.cos(L.angle),z.penumbraCos=Math.cos(L.angle*(1-L.penumbra)),z.decay=L.decay,L.castShadow){const N=L.shadow,Y=i.get(L);Y.shadowBias=N.bias,Y.shadowNormalBias=N.normalBias,Y.shadowRadius=N.radius,Y.shadowMapSize=N.mapSize,n.spotShadow[u]=Y,n.spotShadowMap[u]=G,n.spotShadowMatrix[u]=L.shadow.matrix,A++}n.spot[u]=z,u++}else if(L.isRectAreaLight){const z=t.get(L);z.color.copy(j).multiplyScalar(I),z.halfWidth.set(L.width*.5,0,0),z.halfHeight.set(0,L.height*.5,0),n.rectArea[d]=z,d++}else if(L.isPointLight){const z=t.get(L);if(z.color.copy(L.color).multiplyScalar(L.intensity*v),z.distance=L.distance,z.decay=L.decay,L.castShadow){const N=L.shadow,Y=i.get(L);Y.shadowBias=N.bias,Y.shadowNormalBias=N.normalBias,Y.shadowRadius=N.radius,Y.shadowMapSize=N.mapSize,Y.shadowCameraNear=N.camera.near,Y.shadowCameraFar=N.camera.far,n.pointShadow[b]=Y,n.pointShadowMap[b]=G,n.pointShadowMatrix[b]=L.shadow.matrix,w++}n.point[b]=z,b++}else if(L.isHemisphereLight){const z=t.get(L);z.skyColor.copy(L.color).multiplyScalar(I*v),z.groundColor.copy(L.groundColor).multiplyScalar(I*v),n.hemi[T]=z,T++}}d>0&&(e.isWebGL2||s.has("OES_texture_float_linear")===!0?(n.rectAreaLTC1=Z.LTC_FLOAT_1,n.rectAreaLTC2=Z.LTC_FLOAT_2):s.has("OES_texture_half_float_linear")===!0?(n.rectAreaLTC1=Z.LTC_HALF_1,n.rectAreaLTC2=Z.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),n.ambient[0]=f,n.ambient[1]=m,n.ambient[2]=_;const B=n.hash;(B.directionalLength!==g||B.pointLength!==b||B.spotLength!==u||B.rectAreaLength!==d||B.hemiLength!==T||B.numDirectionalShadows!==M||B.numPointShadows!==w||B.numSpotShadows!==A)&&(n.directional.length=g,n.spot.length=u,n.rectArea.length=d,n.point.length=b,n.hemi.length=T,n.directionalShadow.length=M,n.directionalShadowMap.length=M,n.pointShadow.length=w,n.pointShadowMap.length=w,n.spotShadow.length=A,n.spotShadowMap.length=A,n.directionalShadowMatrix.length=M,n.pointShadowMatrix.length=w,n.spotShadowMatrix.length=A,B.directionalLength=g,B.pointLength=b,B.spotLength=u,B.rectAreaLength=d,B.hemiLength=T,B.numDirectionalShadows=M,B.numPointShadows=w,B.numSpotShadows=A,n.version=ld++)}function l(h,p){let f=0,m=0,_=0,g=0,b=0;const u=p.matrixWorldInverse;for(let d=0,T=h.length;d<T;d++){const M=h[d];if(M.isDirectionalLight){const w=n.directional[f];w.direction.setFromMatrixPosition(M.matrixWorld),r.setFromMatrixPosition(M.target.matrixWorld),w.direction.sub(r),w.direction.transformDirection(u),f++}else if(M.isSpotLight){const w=n.spot[_];w.position.setFromMatrixPosition(M.matrixWorld),w.position.applyMatrix4(u),w.direction.setFromMatrixPosition(M.matrixWorld),r.setFromMatrixPosition(M.target.matrixWorld),w.direction.sub(r),w.direction.transformDirection(u),_++}else if(M.isRectAreaLight){const w=n.rectArea[g];w.position.setFromMatrixPosition(M.matrixWorld),w.position.applyMatrix4(u),o.identity(),a.copy(M.matrixWorld),a.premultiply(u),o.extractRotation(a),w.halfWidth.set(M.width*.5,0,0),w.halfHeight.set(0,M.height*.5,0),w.halfWidth.applyMatrix4(o),w.halfHeight.applyMatrix4(o),g++}else if(M.isPointLight){const w=n.point[m];w.position.setFromMatrixPosition(M.matrixWorld),w.position.applyMatrix4(u),m++}else if(M.isHemisphereLight){const w=n.hemi[b];w.direction.setFromMatrixPosition(M.matrixWorld),w.direction.transformDirection(u),w.direction.normalize(),b++}}}return{setup:c,setupView:l,state:n}}function Ms(s,e){const t=new ud(s,e),i=[],n=[];function r(){i.length=0,n.length=0}function a(p){i.push(p)}function o(p){n.push(p)}function c(p){t.setup(i,p)}function l(p){t.setupView(i,p)}return{init:r,state:{lightsArray:i,shadowsArray:n,lights:t},setupLights:c,setupLightsView:l,pushLight:a,pushShadow:o}}function hd(s,e){let t=new WeakMap;function i(r,a=0){let o;return t.has(r)===!1?(o=new Ms(s,e),t.set(r,[o])):a>=t.get(r).length?(o=new Ms(s,e),t.get(r).push(o)):o=t.get(r)[a],o}function n(){t=new WeakMap}return{get:i,dispose:n}}class Zs extends Oi{constructor(e){super(),this.type="MeshDepthMaterial",this.depthPacking=Co,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}Zs.prototype.isMeshDepthMaterial=!0;class js extends Oi{constructor(e){super(),this.type="MeshDistanceMaterial",this.referencePosition=new C,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(e)}copy(e){return super.copy(e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}js.prototype.isMeshDistanceMaterial=!0;const dd="void main(){gl_Position=vec4(position,1.0);}",fd=`uniform sampler2D shadow_pass;uniform vec2 resolution;uniform float radius;uniform float samples;
#include <packing>
void main(){float mean=0.0;float squared_mean=0.0;float uvStride=samples<=1.0?0.0:2.0/(samples-1.0);float uvStart=samples<=1.0?0.0:-1.0;for(float i=0.0;i<samples;i++){float uvOffset=uvStart+i*uvStride;
#ifdef HORIZONTAL_PASS
vec2 distribution=unpackRGBATo2Half(texture2D(shadow_pass,(gl_FragCoord.xy+vec2(uvOffset,0.0)*radius)/resolution));mean+=distribution.x;squared_mean+=distribution.y*distribution.y+distribution.x*distribution.x;
#else
float depth=unpackRGBAToDepth(texture2D(shadow_pass,(gl_FragCoord.xy+vec2(0.0,uvOffset)*radius)/resolution));mean+=depth;squared_mean+=depth*depth;
#endif
}mean=mean/samples;squared_mean=squared_mean/samples;float std_dev=sqrt(squared_mean-mean*mean);gl_FragColor=pack2HalfToRGBA(vec2(mean,std_dev));}`;function pd(s,e,t){let i=new zs;const n=new De,r=new De,a=new He,o=new Zs({depthPacking:Do}),c=new js,l={},h=t.maxTextureSize,p={0:ze,1:Bi,2:gi},f=new xi({uniforms:{shadow_pass:{value:null},resolution:{value:new De},radius:{value:4},samples:{value:8}},vertexShader:dd,fragmentShader:fd}),m=f.clone();m.defines.HORIZONTAL_PASS=1;const _=new wt;_.setAttribute("position",new et(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const g=new pt(_,f),b=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=ys,this.render=function(M,w,A){if(b.enabled===!1||b.autoUpdate===!1&&b.needsUpdate===!1||M.length===0)return;const v=s.getRenderTarget(),B=s.getActiveCubeFace(),X=s.getActiveMipmapLevel(),O=s.state;O.setBlending(Nt),O.buffers.color.setClear(1,1,1,1),O.buffers.depth.setTest(!0),O.setScissorTest(!1);for(let L=0,j=M.length;L<j;L++){const I=M[L],U=I.shadow;if(U===void 0){console.warn("THREE.WebGLShadowMap:",I,"has no shadow.");continue}if(U.autoUpdate===!1&&U.needsUpdate===!1)continue;n.copy(U.mapSize);const G=U.getFrameExtents();if(n.multiply(G),r.copy(U.mapSize),(n.x>h||n.y>h)&&(n.x>h&&(r.x=Math.floor(h/G.x),n.x=r.x*G.x,U.mapSize.x=r.x),n.y>h&&(r.y=Math.floor(h/G.y),n.y=r.y*G.y,U.mapSize.y=r.y)),U.map===null&&!U.isPointLightShadow&&this.type===Fi){const N={minFilter:ft,magFilter:ft,format:Xe};U.map=new Ut(n.x,n.y,N),U.map.texture.name=I.name+".shadowMap",U.mapPass=new Ut(n.x,n.y,N),U.camera.updateProjectionMatrix()}if(U.map===null){const N={minFilter:Ze,magFilter:Ze,format:Xe};U.map=new Ut(n.x,n.y,N),U.map.texture.name=I.name+".shadowMap",U.camera.updateProjectionMatrix()}s.setRenderTarget(U.map),s.clear();const z=U.getViewportCount();for(let N=0;N<z;N++){const Y=U.getViewport(N);a.set(r.x*Y.x,r.y*Y.y,r.x*Y.z,r.y*Y.w),O.viewport(a),U.updateMatrices(I,N),i=U.getFrustum(),T(w,A,U.camera,I,this.type)}!U.isPointLightShadow&&this.type===Fi&&u(U,A),U.needsUpdate=!1}b.needsUpdate=!1,s.setRenderTarget(v,B,X)};function u(M,w){const A=e.update(g);f.uniforms.shadow_pass.value=M.map.texture,f.uniforms.resolution.value=M.mapSize,f.uniforms.radius.value=M.radius,f.uniforms.samples.value=M.blurSamples,s.setRenderTarget(M.mapPass),s.clear(),s.renderBufferDirect(w,null,A,f,g,null),m.uniforms.shadow_pass.value=M.mapPass.texture,m.uniforms.resolution.value=M.mapSize,m.uniforms.radius.value=M.radius,m.uniforms.samples.value=M.blurSamples,s.setRenderTarget(M.map),s.clear(),s.renderBufferDirect(w,null,A,m,g,null)}function d(M,w,A,v,B,X,O){let L=null;const j=v.isPointLight===!0?M.customDistanceMaterial:M.customDepthMaterial;if(j!==void 0?L=j:L=v.isPointLight===!0?c:o,s.localClippingEnabled&&A.clipShadows===!0&&A.clippingPlanes.length!==0||A.displacementMap&&A.displacementScale!==0||A.alphaMap&&A.alphaTest>0){const I=L.uuid,U=A.uuid;let G=l[I];G===void 0&&(G={},l[I]=G);let z=G[U];z===void 0&&(z=L.clone(),G[U]=z),L=z}return L.visible=A.visible,L.wireframe=A.wireframe,O===Fi?L.side=A.shadowSide!==null?A.shadowSide:A.side:L.side=A.shadowSide!==null?A.shadowSide:p[A.side],L.alphaMap=A.alphaMap,L.alphaTest=A.alphaTest,L.clipShadows=A.clipShadows,L.clippingPlanes=A.clippingPlanes,L.clipIntersection=A.clipIntersection,L.displacementMap=A.displacementMap,L.displacementScale=A.displacementScale,L.displacementBias=A.displacementBias,L.wireframeLinewidth=A.wireframeLinewidth,L.linewidth=A.linewidth,v.isPointLight===!0&&L.isMeshDistanceMaterial===!0&&(L.referencePosition.setFromMatrixPosition(v.matrixWorld),L.nearDistance=B,L.farDistance=X),L}function T(M,w,A,v,B){if(M.visible===!1)return;if(M.layers.test(w.layers)&&(M.isMesh||M.isLine||M.isPoints)&&(M.castShadow||M.receiveShadow&&B===Fi)&&(!M.frustumCulled||i.intersectsObject(M))){M.modelViewMatrix.multiplyMatrices(A.matrixWorldInverse,M.matrixWorld);const L=e.update(M),j=M.material;if(Array.isArray(j)){const I=L.groups;for(let U=0,G=I.length;U<G;U++){const z=I[U],N=j[z.materialIndex];if(N&&N.visible){const Y=d(M,L,N,v,A.near,A.far,B);s.renderBufferDirect(A,null,L,Y,M,z)}}}else if(j.visible){const I=d(M,L,j,v,A.near,A.far,B);s.renderBufferDirect(A,null,L,I,M,null)}}const O=M.children;for(let L=0,j=O.length;L<j;L++)T(O[L],w,A,v,B)}}function md(s,e,t){const i=t.isWebGL2;function n(){let E=!1;const Q=new He;let k=null;const ee=new He(0,0,0,0);return{setMask:function(se){k!==se&&!E&&(s.colorMask(se,se,se,se),k=se)},setLocked:function(se){E=se},setClear:function(se,ye,Ge,Oe,Tt){Tt===!0&&(se*=Oe,ye*=Oe,Ge*=Oe),Q.set(se,ye,Ge,Oe),ee.equals(Q)===!1&&(s.clearColor(se,ye,Ge,Oe),ee.copy(Q))},reset:function(){E=!1,k=null,ee.set(-1,0,0,0)}}}function r(){let E=!1,Q=null,k=null,ee=null;return{setTest:function(se){se?q(2929):re(2929)},setMask:function(se){Q!==se&&!E&&(s.depthMask(se),Q=se)},setFunc:function(se){if(k!==se){if(se)switch(se){case Ma:s.depthFunc(512);break;case ya:s.depthFunc(519);break;case Sa:s.depthFunc(513);break;case Zn:s.depthFunc(515);break;case ba:s.depthFunc(514);break;case wa:s.depthFunc(518);break;case Ta:s.depthFunc(516);break;case Ea:s.depthFunc(517);break;default:s.depthFunc(515)}else s.depthFunc(515);k=se}},setLocked:function(se){E=se},setClear:function(se){ee!==se&&(s.clearDepth(se),ee=se)},reset:function(){E=!1,Q=null,k=null,ee=null}}}function a(){let E=!1,Q=null,k=null,ee=null,se=null,ye=null,Ge=null,Oe=null,Tt=null;return{setTest:function(Ie){E||(Ie?q(2960):re(2960))},setMask:function(Ie){Q!==Ie&&!E&&(s.stencilMask(Ie),Q=Ie)},setFunc:function(Ie,gt,_t){(k!==Ie||ee!==gt||se!==_t)&&(s.stencilFunc(Ie,gt,_t),k=Ie,ee=gt,se=_t)},setOp:function(Ie,gt,_t){(ye!==Ie||Ge!==gt||Oe!==_t)&&(s.stencilOp(Ie,gt,_t),ye=Ie,Ge=gt,Oe=_t)},setLocked:function(Ie){E=Ie},setClear:function(Ie){Tt!==Ie&&(s.clearStencil(Ie),Tt=Ie)},reset:function(){E=!1,Q=null,k=null,ee=null,se=null,ye=null,Ge=null,Oe=null,Tt=null}}}const o=new n,c=new r,l=new a;let h={},p=null,f={},m=null,_=!1,g=null,b=null,u=null,d=null,T=null,M=null,w=null,A=!1,v=null,B=null,X=null,O=null,L=null;const j=s.getParameter(35661);let I=!1,U=0;const G=s.getParameter(7938);G.indexOf("WebGL")!==-1?(U=parseFloat(/^WebGL (\d)/.exec(G)[1]),I=U>=1):G.indexOf("OpenGL ES")!==-1&&(U=parseFloat(/^OpenGL ES (\d)/.exec(G)[1]),I=U>=2);let z=null,N={};const Y=s.getParameter(3088),ne=s.getParameter(2978),oe=new He().fromArray(Y),te=new He().fromArray(ne);function xe(E,Q,k){const ee=new Uint8Array(4),se=s.createTexture();s.bindTexture(E,se),s.texParameteri(E,10241,9728),s.texParameteri(E,10240,9728);for(let ye=0;ye<k;ye++)s.texImage2D(Q+ye,0,6408,1,1,0,6408,5121,ee);return se}const H={};H[3553]=xe(3553,3553,1),H[34067]=xe(34067,34069,6),o.setClear(0,0,0,1),c.setClear(1),l.setClear(0),q(2929),c.setFunc(Zn),Le(!1),We(Mr),q(2884),be(Nt);function q(E){h[E]!==!0&&(s.enable(E),h[E]=!0)}function re(E){h[E]!==!1&&(s.disable(E),h[E]=!1)}function F(E){E!==p&&(s.bindFramebuffer(36160,E),p=E)}function me(E,Q){return Q===null&&p!==null&&(Q=p),f[E]!==Q?(s.bindFramebuffer(E,Q),f[E]=Q,i&&(E===36009&&(f[36160]=Q),E===36160&&(f[36009]=Q)),!0):!1}function _e(E){return m!==E?(s.useProgram(E),m=E,!0):!1}const K={[fi]:32774,[ca]:32778,[ua]:32779};if(i)K[wr]=32775,K[Tr]=32776;else{const E=e.get("EXT_blend_minmax");E!==null&&(K[wr]=E.MIN_EXT,K[Tr]=E.MAX_EXT)}const ue={[ha]:0,[da]:1,[fa]:768,[Ss]:770,[va]:776,[_a]:774,[ma]:772,[pa]:769,[bs]:771,[xa]:775,[ga]:773};function be(E,Q,k,ee,se,ye,Ge,Oe){if(E===Nt){_===!0&&(re(3042),_=!1);return}if(_===!1&&(q(3042),_=!0),E!==la){if(E!==g||Oe!==A){if((b!==fi||T!==fi)&&(s.blendEquation(32774),b=fi,T=fi),Oe)switch(E){case Ni:s.blendFuncSeparate(1,771,1,771);break;case yr:s.blendFunc(1,1);break;case Sr:s.blendFuncSeparate(0,0,769,771);break;case br:s.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",E);break}else switch(E){case Ni:s.blendFuncSeparate(770,771,1,771);break;case yr:s.blendFunc(770,1);break;case Sr:s.blendFunc(0,769);break;case br:s.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",E);break}u=null,d=null,M=null,w=null,g=E,A=Oe}return}se=se||Q,ye=ye||k,Ge=Ge||ee,(Q!==b||se!==T)&&(s.blendEquationSeparate(K[Q],K[se]),b=Q,T=se),(k!==u||ee!==d||ye!==M||Ge!==w)&&(s.blendFuncSeparate(ue[k],ue[ee],ue[ye],ue[Ge]),u=k,d=ee,M=ye,w=Ge),g=E,A=null}function he(E,Q){E.side===gi?re(2884):q(2884);let k=E.side===ze;Q&&(k=!k),Le(k),E.blending===Ni&&E.transparent===!1?be(Nt):be(E.blending,E.blendEquation,E.blendSrc,E.blendDst,E.blendEquationAlpha,E.blendSrcAlpha,E.blendDstAlpha,E.premultipliedAlpha),c.setFunc(E.depthFunc),c.setTest(E.depthTest),c.setMask(E.depthWrite),o.setMask(E.colorWrite);const ee=E.stencilWrite;l.setTest(ee),ee&&(l.setMask(E.stencilWriteMask),l.setFunc(E.stencilFunc,E.stencilRef,E.stencilFuncMask),l.setOp(E.stencilFail,E.stencilZFail,E.stencilZPass)),Qe(E.polygonOffset,E.polygonOffsetFactor,E.polygonOffsetUnits),E.alphaToCoverage===!0?q(32926):re(32926)}function Le(E){v!==E&&(E?s.frontFace(2304):s.frontFace(2305),v=E)}function We(E){E!==ra?(q(2884),E!==B&&(E===Mr?s.cullFace(1029):E===sa?s.cullFace(1028):s.cullFace(1032))):re(2884),B=E}function it(E){E!==X&&(I&&s.lineWidth(E),X=E)}function Qe(E,Q,k){E?(q(32823),(O!==Q||L!==k)&&(s.polygonOffset(Q,k),O=Q,L=k)):re(32823)}function S(E){E?q(3089):re(3089)}function y(E){E===void 0&&(E=33984+j-1),z!==E&&(s.activeTexture(E),z=E)}function W(E,Q){z===null&&y();let k=N[z];k===void 0&&(k={type:void 0,texture:void 0},N[z]=k),(k.type!==E||k.texture!==Q)&&(s.bindTexture(E,Q||H[E]),k.type=E,k.texture=Q)}function J(){const E=N[z];E!==void 0&&E.type!==void 0&&(s.bindTexture(E.type,null),E.type=void 0,E.texture=void 0)}function $(){try{s.compressedTexImage2D.apply(s,arguments)}catch(E){console.error("THREE.WebGLState:",E)}}function ie(){try{s.texImage2D.apply(s,arguments)}catch(E){console.error("THREE.WebGLState:",E)}}function pe(){try{s.texImage3D.apply(s,arguments)}catch(E){console.error("THREE.WebGLState:",E)}}function de(E){oe.equals(E)===!1&&(s.scissor(E.x,E.y,E.z,E.w),oe.copy(E))}function ge(E){te.equals(E)===!1&&(s.viewport(E.x,E.y,E.z,E.w),te.copy(E))}function ae(){s.disable(3042),s.disable(2884),s.disable(2929),s.disable(32823),s.disable(3089),s.disable(2960),s.disable(32926),s.blendEquation(32774),s.blendFunc(1,0),s.blendFuncSeparate(1,0,1,0),s.colorMask(!0,!0,!0,!0),s.clearColor(0,0,0,0),s.depthMask(!0),s.depthFunc(513),s.clearDepth(1),s.stencilMask(4294967295),s.stencilFunc(519,0,4294967295),s.stencilOp(7680,7680,7680),s.clearStencil(0),s.cullFace(1029),s.frontFace(2305),s.polygonOffset(0,0),s.activeTexture(33984),s.bindFramebuffer(36160,null),i===!0&&(s.bindFramebuffer(36009,null),s.bindFramebuffer(36008,null)),s.useProgram(null),s.lineWidth(1),s.scissor(0,0,s.canvas.width,s.canvas.height),s.viewport(0,0,s.canvas.width,s.canvas.height),h={},z=null,N={},p=null,f={},m=null,_=!1,g=null,b=null,u=null,d=null,T=null,M=null,w=null,A=!1,v=null,B=null,X=null,O=null,L=null,oe.set(0,0,s.canvas.width,s.canvas.height),te.set(0,0,s.canvas.width,s.canvas.height),o.reset(),c.reset(),l.reset()}return{buffers:{color:o,depth:c,stencil:l},enable:q,disable:re,bindFramebuffer:me,bindXRFramebuffer:F,useProgram:_e,setBlending:be,setMaterial:he,setFlipSided:Le,setCullFace:We,setLineWidth:it,setPolygonOffset:Qe,setScissorTest:S,activeTexture:y,bindTexture:W,unbindTexture:J,compressedTexImage2D:$,texImage2D:ie,texImage3D:pe,scissor:de,viewport:ge,reset:ae}}function gd(s,e,t,i,n,r,a){const o=n.isWebGL2,c=n.maxTextures,l=n.maxCubemapSize,h=n.maxTextureSize,p=n.maxSamples,f=new WeakMap;let m,_=!1;try{_=typeof OffscreenCanvas!="undefined"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function g(S,y){return _?new OffscreenCanvas(S,y):ar("canvas")}function b(S,y,W,J){let $=1;if((S.width>J||S.height>J)&&($=J/Math.max(S.width,S.height)),$<1||y===!0)if(typeof HTMLImageElement!="undefined"&&S instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&S instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&S instanceof ImageBitmap){const ie=y?Uo:Math.floor,pe=ie($*S.width),de=ie($*S.height);m===void 0&&(m=g(pe,de));const ge=W?g(pe,de):m;return ge.width=pe,ge.height=de,ge.getContext("2d").drawImage(S,0,0,pe,de),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+S.width+"x"+S.height+") to ("+pe+"x"+de+")."),ge}else return"data"in S&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+S.width+"x"+S.height+")."),S;return S}function u(S){return Vr(S.width)&&Vr(S.height)}function d(S){return o?!1:S.wrapS!==$e||S.wrapT!==$e||S.minFilter!==Ze&&S.minFilter!==ft}function T(S,y){return S.generateMipmaps&&y&&S.minFilter!==Ze&&S.minFilter!==ft}function M(S,y,W,J,$=1){s.generateMipmap(S);const ie=i.get(y);ie.__maxMipLevel=Math.log2(Math.max(W,J,$))}function w(S,y,W,J){if(o===!1)return y;if(S!==null){if(s[S]!==void 0)return s[S];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+S+"'")}let $=y;return y===6403&&(W===5126&&($=33326),W===5131&&($=33325),W===5121&&($=33321)),y===6407&&(W===5126&&($=34837),W===5131&&($=34843),W===5121&&($=32849)),y===6408&&(W===5126&&($=34836),W===5131&&($=34842),W===5121&&($=J===vi?35907:32856)),($===33325||$===33326||$===34842||$===34836)&&e.get("EXT_color_buffer_float"),$}function A(S){return S===Ze||S===Er||S===Ar?9728:9729}function v(S){const y=S.target;y.removeEventListener("dispose",v),X(y),y.isVideoTexture&&f.delete(y),a.memory.textures--}function B(S){const y=S.target;y.removeEventListener("dispose",B),O(y)}function X(S){const y=i.get(S);y.__webglInit!==void 0&&(s.deleteTexture(y.__webglTexture),i.remove(S))}function O(S){const y=S.texture,W=i.get(S),J=i.get(y);if(!!S){if(J.__webglTexture!==void 0&&(s.deleteTexture(J.__webglTexture),a.memory.textures--),S.depthTexture&&S.depthTexture.dispose(),S.isWebGLCubeRenderTarget)for(let $=0;$<6;$++)s.deleteFramebuffer(W.__webglFramebuffer[$]),W.__webglDepthbuffer&&s.deleteRenderbuffer(W.__webglDepthbuffer[$]);else s.deleteFramebuffer(W.__webglFramebuffer),W.__webglDepthbuffer&&s.deleteRenderbuffer(W.__webglDepthbuffer),W.__webglMultisampledFramebuffer&&s.deleteFramebuffer(W.__webglMultisampledFramebuffer),W.__webglColorRenderbuffer&&s.deleteRenderbuffer(W.__webglColorRenderbuffer),W.__webglDepthRenderbuffer&&s.deleteRenderbuffer(W.__webglDepthRenderbuffer);if(S.isWebGLMultipleRenderTargets)for(let $=0,ie=y.length;$<ie;$++){const pe=i.get(y[$]);pe.__webglTexture&&(s.deleteTexture(pe.__webglTexture),a.memory.textures--),i.remove(y[$])}i.remove(y),i.remove(S)}}let L=0;function j(){L=0}function I(){const S=L;return S>=c&&console.warn("THREE.WebGLTextures: Trying to use "+S+" texture units while this GPU supports only "+c),L+=1,S}function U(S,y){const W=i.get(S);if(S.isVideoTexture&&he(S),S.version>0&&W.__version!==S.version){const J=S.image;if(J===void 0)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else if(J.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{xe(W,S,y);return}}t.activeTexture(33984+y),t.bindTexture(3553,W.__webglTexture)}function G(S,y){const W=i.get(S);if(S.version>0&&W.__version!==S.version){xe(W,S,y);return}t.activeTexture(33984+y),t.bindTexture(35866,W.__webglTexture)}function z(S,y){const W=i.get(S);if(S.version>0&&W.__version!==S.version){xe(W,S,y);return}t.activeTexture(33984+y),t.bindTexture(32879,W.__webglTexture)}function N(S,y){const W=i.get(S);if(S.version>0&&W.__version!==S.version){H(W,S,y);return}t.activeTexture(33984+y),t.bindTexture(34067,W.__webglTexture)}const Y={[$n]:10497,[$e]:33071,[Qn]:33648},ne={[Ze]:9728,[Er]:9984,[Ar]:9986,[ft]:9729,[Ia]:9985,[fn]:9987};function oe(S,y,W){if(W?(s.texParameteri(S,10242,Y[y.wrapS]),s.texParameteri(S,10243,Y[y.wrapT]),(S===32879||S===35866)&&s.texParameteri(S,32882,Y[y.wrapR]),s.texParameteri(S,10240,ne[y.magFilter]),s.texParameteri(S,10241,ne[y.minFilter])):(s.texParameteri(S,10242,33071),s.texParameteri(S,10243,33071),(S===32879||S===35866)&&s.texParameteri(S,32882,33071),(y.wrapS!==$e||y.wrapT!==$e)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),s.texParameteri(S,10240,A(y.magFilter)),s.texParameteri(S,10241,A(y.minFilter)),y.minFilter!==Ze&&y.minFilter!==ft&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),e.has("EXT_texture_filter_anisotropic")===!0){const J=e.get("EXT_texture_filter_anisotropic");if(y.type===zt&&e.has("OES_texture_float_linear")===!1||o===!1&&y.type===pi&&e.has("OES_texture_half_float_linear")===!1)return;(y.anisotropy>1||i.get(y).__currentAnisotropy)&&(s.texParameterf(S,J.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(y.anisotropy,n.getMaxAnisotropy())),i.get(y).__currentAnisotropy=y.anisotropy)}}function te(S,y){S.__webglInit===void 0&&(S.__webglInit=!0,y.addEventListener("dispose",v),S.__webglTexture=s.createTexture(),a.memory.textures++)}function xe(S,y,W){let J=3553;y.isDataTexture2DArray&&(J=35866),y.isDataTexture3D&&(J=32879),te(S,y),t.activeTexture(33984+W),t.bindTexture(J,S.__webglTexture),s.pixelStorei(37440,y.flipY),s.pixelStorei(37441,y.premultiplyAlpha),s.pixelStorei(3317,y.unpackAlignment),s.pixelStorei(37443,0);const $=d(y)&&u(y.image)===!1,ie=b(y.image,$,!1,h),pe=u(ie)||o,de=r.convert(y.format);let ge=r.convert(y.type),ae=w(y.internalFormat,de,ge,y.encoding);oe(J,y,pe);let E;const Q=y.mipmaps;if(y.isDepthTexture)ae=6402,o?y.type===zt?ae=36012:y.type===ln?ae=33190:y.type===cn?ae=35056:ae=33189:y.type===zt&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),y.format===er&&ae===6402&&y.type!==Kn&&y.type!==ln&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),y.type=Kn,ge=r.convert(y.type)),y.format===tr&&ae===6402&&(ae=34041,y.type!==cn&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),y.type=cn,ge=r.convert(y.type))),t.texImage2D(3553,0,ae,ie.width,ie.height,0,de,ge,null);else if(y.isDataTexture)if(Q.length>0&&pe){for(let k=0,ee=Q.length;k<ee;k++)E=Q[k],t.texImage2D(3553,k,ae,E.width,E.height,0,de,ge,E.data);y.generateMipmaps=!1,S.__maxMipLevel=Q.length-1}else t.texImage2D(3553,0,ae,ie.width,ie.height,0,de,ge,ie.data),S.__maxMipLevel=0;else if(y.isCompressedTexture){for(let k=0,ee=Q.length;k<ee;k++)E=Q[k],y.format!==Xe&&y.format!==Ui?de!==null?t.compressedTexImage2D(3553,k,ae,E.width,E.height,0,E.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):t.texImage2D(3553,k,ae,E.width,E.height,0,de,ge,E.data);S.__maxMipLevel=Q.length-1}else if(y.isDataTexture2DArray)t.texImage3D(35866,0,ae,ie.width,ie.height,ie.depth,0,de,ge,ie.data),S.__maxMipLevel=0;else if(y.isDataTexture3D)t.texImage3D(32879,0,ae,ie.width,ie.height,ie.depth,0,de,ge,ie.data),S.__maxMipLevel=0;else if(Q.length>0&&pe){for(let k=0,ee=Q.length;k<ee;k++)E=Q[k],t.texImage2D(3553,k,ae,de,ge,E);y.generateMipmaps=!1,S.__maxMipLevel=Q.length-1}else t.texImage2D(3553,0,ae,de,ge,ie),S.__maxMipLevel=0;T(y,pe)&&M(J,y,ie.width,ie.height),S.__version=y.version,y.onUpdate&&y.onUpdate(y)}function H(S,y,W){if(y.image.length!==6)return;te(S,y),t.activeTexture(33984+W),t.bindTexture(34067,S.__webglTexture),s.pixelStorei(37440,y.flipY),s.pixelStorei(37441,y.premultiplyAlpha),s.pixelStorei(3317,y.unpackAlignment),s.pixelStorei(37443,0);const J=y&&(y.isCompressedTexture||y.image[0].isCompressedTexture),$=y.image[0]&&y.image[0].isDataTexture,ie=[];for(let k=0;k<6;k++)!J&&!$?ie[k]=b(y.image[k],!1,!0,l):ie[k]=$?y.image[k].image:y.image[k];const pe=ie[0],de=u(pe)||o,ge=r.convert(y.format),ae=r.convert(y.type),E=w(y.internalFormat,ge,ae,y.encoding);oe(34067,y,de);let Q;if(J){for(let k=0;k<6;k++){Q=ie[k].mipmaps;for(let ee=0;ee<Q.length;ee++){const se=Q[ee];y.format!==Xe&&y.format!==Ui?ge!==null?t.compressedTexImage2D(34069+k,ee,E,se.width,se.height,0,se.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):t.texImage2D(34069+k,ee,E,se.width,se.height,0,ge,ae,se.data)}}S.__maxMipLevel=Q.length-1}else{Q=y.mipmaps;for(let k=0;k<6;k++)if($){t.texImage2D(34069+k,0,E,ie[k].width,ie[k].height,0,ge,ae,ie[k].data);for(let ee=0;ee<Q.length;ee++){const ye=Q[ee].image[k].image;t.texImage2D(34069+k,ee+1,E,ye.width,ye.height,0,ge,ae,ye.data)}}else{t.texImage2D(34069+k,0,E,ge,ae,ie[k]);for(let ee=0;ee<Q.length;ee++){const se=Q[ee];t.texImage2D(34069+k,ee+1,E,ge,ae,se.image[k])}}S.__maxMipLevel=Q.length}T(y,de)&&M(34067,y,pe.width,pe.height),S.__version=y.version,y.onUpdate&&y.onUpdate(y)}function q(S,y,W,J,$){const ie=r.convert(W.format),pe=r.convert(W.type),de=w(W.internalFormat,ie,pe,W.encoding);$===32879||$===35866?t.texImage3D($,0,de,y.width,y.height,y.depth,0,ie,pe,null):t.texImage2D($,0,de,y.width,y.height,0,ie,pe,null),t.bindFramebuffer(36160,S),s.framebufferTexture2D(36160,J,$,i.get(W).__webglTexture,0),t.bindFramebuffer(36160,null)}function re(S,y,W){if(s.bindRenderbuffer(36161,S),y.depthBuffer&&!y.stencilBuffer){let J=33189;if(W){const $=y.depthTexture;$&&$.isDepthTexture&&($.type===zt?J=36012:$.type===ln&&(J=33190));const ie=be(y);s.renderbufferStorageMultisample(36161,ie,J,y.width,y.height)}else s.renderbufferStorage(36161,J,y.width,y.height);s.framebufferRenderbuffer(36160,36096,36161,S)}else if(y.depthBuffer&&y.stencilBuffer){if(W){const J=be(y);s.renderbufferStorageMultisample(36161,J,35056,y.width,y.height)}else s.renderbufferStorage(36161,34041,y.width,y.height);s.framebufferRenderbuffer(36160,33306,36161,S)}else{const J=y.isWebGLMultipleRenderTargets===!0?y.texture[0]:y.texture,$=r.convert(J.format),ie=r.convert(J.type),pe=w(J.internalFormat,$,ie,J.encoding);if(W){const de=be(y);s.renderbufferStorageMultisample(36161,de,pe,y.width,y.height)}else s.renderbufferStorage(36161,pe,y.width,y.height)}s.bindRenderbuffer(36161,null)}function F(S,y){if(y&&y.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(36160,S),!(y.depthTexture&&y.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!i.get(y.depthTexture).__webglTexture||y.depthTexture.image.width!==y.width||y.depthTexture.image.height!==y.height)&&(y.depthTexture.image.width=y.width,y.depthTexture.image.height=y.height,y.depthTexture.needsUpdate=!0),U(y.depthTexture,0);const J=i.get(y.depthTexture).__webglTexture;if(y.depthTexture.format===er)s.framebufferTexture2D(36160,36096,3553,J,0);else if(y.depthTexture.format===tr)s.framebufferTexture2D(36160,33306,3553,J,0);else throw new Error("Unknown depthTexture format")}function me(S){const y=i.get(S),W=S.isWebGLCubeRenderTarget===!0;if(S.depthTexture){if(W)throw new Error("target.depthTexture not supported in Cube render targets");F(y.__webglFramebuffer,S)}else if(W){y.__webglDepthbuffer=[];for(let J=0;J<6;J++)t.bindFramebuffer(36160,y.__webglFramebuffer[J]),y.__webglDepthbuffer[J]=s.createRenderbuffer(),re(y.__webglDepthbuffer[J],S,!1)}else t.bindFramebuffer(36160,y.__webglFramebuffer),y.__webglDepthbuffer=s.createRenderbuffer(),re(y.__webglDepthbuffer,S,!1);t.bindFramebuffer(36160,null)}function _e(S){const y=S.texture,W=i.get(S),J=i.get(y);S.addEventListener("dispose",B),S.isWebGLMultipleRenderTargets!==!0&&(J.__webglTexture=s.createTexture(),J.__version=y.version,a.memory.textures++);const $=S.isWebGLCubeRenderTarget===!0,ie=S.isWebGLMultipleRenderTargets===!0,pe=S.isWebGLMultisampleRenderTarget===!0,de=y.isDataTexture3D||y.isDataTexture2DArray,ge=u(S)||o;if(o&&y.format===Ui&&(y.type===zt||y.type===pi)&&(y.format=Xe,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),$){W.__webglFramebuffer=[];for(let ae=0;ae<6;ae++)W.__webglFramebuffer[ae]=s.createFramebuffer()}else if(W.__webglFramebuffer=s.createFramebuffer(),ie)if(n.drawBuffers){const ae=S.texture;for(let E=0,Q=ae.length;E<Q;E++){const k=i.get(ae[E]);k.__webglTexture===void 0&&(k.__webglTexture=s.createTexture(),a.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");else if(pe)if(o){W.__webglMultisampledFramebuffer=s.createFramebuffer(),W.__webglColorRenderbuffer=s.createRenderbuffer(),s.bindRenderbuffer(36161,W.__webglColorRenderbuffer);const ae=r.convert(y.format),E=r.convert(y.type),Q=w(y.internalFormat,ae,E,y.encoding),k=be(S);s.renderbufferStorageMultisample(36161,k,Q,S.width,S.height),t.bindFramebuffer(36160,W.__webglMultisampledFramebuffer),s.framebufferRenderbuffer(36160,36064,36161,W.__webglColorRenderbuffer),s.bindRenderbuffer(36161,null),S.depthBuffer&&(W.__webglDepthRenderbuffer=s.createRenderbuffer(),re(W.__webglDepthRenderbuffer,S,!0)),t.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if($){t.bindTexture(34067,J.__webglTexture),oe(34067,y,ge);for(let ae=0;ae<6;ae++)q(W.__webglFramebuffer[ae],S,y,36064,34069+ae);T(y,ge)&&M(34067,y,S.width,S.height),t.unbindTexture()}else if(ie){const ae=S.texture;for(let E=0,Q=ae.length;E<Q;E++){const k=ae[E],ee=i.get(k);t.bindTexture(3553,ee.__webglTexture),oe(3553,k,ge),q(W.__webglFramebuffer,S,k,36064+E,3553),T(k,ge)&&M(3553,k,S.width,S.height)}t.unbindTexture()}else{let ae=3553;de&&(o?ae=y.isDataTexture3D?32879:35866:console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")),t.bindTexture(ae,J.__webglTexture),oe(ae,y,ge),q(W.__webglFramebuffer,S,y,36064,ae),T(y,ge)&&M(ae,y,S.width,S.height,S.depth),t.unbindTexture()}S.depthBuffer&&me(S)}function K(S){const y=u(S)||o,W=S.isWebGLMultipleRenderTargets===!0?S.texture:[S.texture];for(let J=0,$=W.length;J<$;J++){const ie=W[J];if(T(ie,y)){const pe=S.isWebGLCubeRenderTarget?34067:3553,de=i.get(ie).__webglTexture;t.bindTexture(pe,de),M(pe,ie,S.width,S.height),t.unbindTexture()}}}function ue(S){if(S.isWebGLMultisampleRenderTarget)if(o){const y=S.width,W=S.height;let J=16384;S.depthBuffer&&(J|=256),S.stencilBuffer&&(J|=1024);const $=i.get(S);t.bindFramebuffer(36008,$.__webglMultisampledFramebuffer),t.bindFramebuffer(36009,$.__webglFramebuffer),s.blitFramebuffer(0,0,y,W,0,0,y,W,J,9728),t.bindFramebuffer(36008,null),t.bindFramebuffer(36009,$.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}function be(S){return o&&S.isWebGLMultisampleRenderTarget?Math.min(p,S.samples):0}function he(S){const y=a.render.frame;f.get(S)!==y&&(f.set(S,y),S.update())}let Le=!1,We=!1;function it(S,y){S&&S.isWebGLRenderTarget&&(Le===!1&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),Le=!0),S=S.texture),U(S,y)}function Qe(S,y){S&&S.isWebGLCubeRenderTarget&&(We===!1&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),We=!0),S=S.texture),N(S,y)}this.allocateTextureUnit=I,this.resetTextureUnits=j,this.setTexture2D=U,this.setTexture2DArray=G,this.setTexture3D=z,this.setTextureCube=N,this.setupRenderTarget=_e,this.updateRenderTargetMipmap=K,this.updateMultisampleRenderTarget=ue,this.safeSetTexture2D=it,this.safeSetTextureCube=Qe}function _d(s,e,t){const i=t.isWebGL2;function n(r){let a;if(r===Ot)return 5121;if(r===Ba)return 32819;if(r===Ga)return 32820;if(r===Oa)return 33635;if(r===za)return 5120;if(r===Na)return 5122;if(r===Kn)return 5123;if(r===Ua)return 5124;if(r===ln)return 5125;if(r===zt)return 5126;if(r===pi)return i?5131:(a=e.get("OES_texture_half_float"),a!==null?a.HALF_FLOAT_OES:null);if(r===Va)return 6406;if(r===Ui)return 6407;if(r===Xe)return 6408;if(r===ka)return 6409;if(r===Wa)return 6410;if(r===er)return 6402;if(r===tr)return 34041;if(r===Xa)return 6403;if(r===qa)return 36244;if(r===Ya)return 33319;if(r===Za)return 33320;if(r===ja)return 36248;if(r===Ja)return 36249;if(r===Lr||r===Cr||r===Dr||r===Pr)if(a=e.get("WEBGL_compressed_texture_s3tc"),a!==null){if(r===Lr)return a.COMPRESSED_RGB_S3TC_DXT1_EXT;if(r===Cr)return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(r===Dr)return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(r===Pr)return a.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(r===Rr||r===Fr||r===Ir||r===zr)if(a=e.get("WEBGL_compressed_texture_pvrtc"),a!==null){if(r===Rr)return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(r===Fr)return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(r===Ir)return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(r===zr)return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(r===$a)return a=e.get("WEBGL_compressed_texture_etc1"),a!==null?a.COMPRESSED_RGB_ETC1_WEBGL:null;if((r===Nr||r===Ur)&&(a=e.get("WEBGL_compressed_texture_etc"),a!==null)){if(r===Nr)return a.COMPRESSED_RGB8_ETC2;if(r===Ur)return a.COMPRESSED_RGBA8_ETC2_EAC}if(r===Qa||r===Ka||r===eo||r===to||r===io||r===no||r===ro||r===so||r===ao||r===oo||r===lo||r===co||r===uo||r===ho||r===po||r===mo||r===go||r===_o||r===xo||r===vo||r===Mo||r===yo||r===So||r===bo||r===wo||r===To||r===Eo||r===Ao)return a=e.get("WEBGL_compressed_texture_astc"),a!==null?r:null;if(r===fo)return a=e.get("EXT_texture_compression_bptc"),a!==null?r:null;if(r===cn)return i?34042:(a=e.get("WEBGL_depth_texture"),a!==null?a.UNSIGNED_INT_24_8_WEBGL:null)}return{convert:n}}class Js extends ot{constructor(e=[]){super(),this.cameras=e}}Js.prototype.isArrayCamera=!0;class zi extends tt{constructor(){super(),this.type="Group"}}zi.prototype.isGroup=!0;const xd={type:"move"};class Yn{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new zi,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new zi,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new C,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new C),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new zi,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new C,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new C),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,i){let n=null,r=null,a=null;const o=this._targetRay,c=this._grip,l=this._hand;if(e&&t.session.visibilityState!=="visible-blurred")if(o!==null&&(n=t.getPose(e.targetRaySpace,i),n!==null&&(o.matrix.fromArray(n.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),n.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(n.linearVelocity)):o.hasLinearVelocity=!1,n.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(n.angularVelocity)):o.hasAngularVelocity=!1,this.dispatchEvent(xd))),l&&e.hand){a=!0;for(const g of e.hand.values()){const b=t.getJointPose(g,i);if(l.joints[g.jointName]===void 0){const d=new zi;d.matrixAutoUpdate=!1,d.visible=!1,l.joints[g.jointName]=d,l.add(d)}const u=l.joints[g.jointName];b!==null&&(u.matrix.fromArray(b.transform.matrix),u.matrix.decompose(u.position,u.rotation,u.scale),u.jointRadius=b.radius),u.visible=b!==null}const h=l.joints["index-finger-tip"],p=l.joints["thumb-tip"],f=h.position.distanceTo(p.position),m=.02,_=.005;l.inputState.pinching&&f>m+_?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!l.inputState.pinching&&f<=m-_&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else c!==null&&e.gripSpace&&(r=t.getPose(e.gripSpace,i),r!==null&&(c.matrix.fromArray(r.transform.matrix),c.matrix.decompose(c.position,c.rotation,c.scale),r.linearVelocity?(c.hasLinearVelocity=!0,c.linearVelocity.copy(r.linearVelocity)):c.hasLinearVelocity=!1,r.angularVelocity?(c.hasAngularVelocity=!0,c.angularVelocity.copy(r.angularVelocity)):c.hasAngularVelocity=!1));return o!==null&&(o.visible=n!==null),c!==null&&(c.visible=r!==null),l!==null&&(l.visible=a!==null),this}}class vd extends Mi{constructor(e,t){super();const i=this,n=e.state;let r=null,a=1,o=null,c="local-floor",l=null,h=null,p=null,f=null,m=null,_=!1,g=null,b=null,u=null,d=null,T=null,M=null;const w=[],A=new Map,v=new ot;v.layers.enable(1),v.viewport=new He;const B=new ot;B.layers.enable(2),B.viewport=new He;const X=[v,B],O=new Js;O.layers.enable(1),O.layers.enable(2);let L=null,j=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(H){let q=w[H];return q===void 0&&(q=new Yn,w[H]=q),q.getTargetRaySpace()},this.getControllerGrip=function(H){let q=w[H];return q===void 0&&(q=new Yn,w[H]=q),q.getGripSpace()},this.getHand=function(H){let q=w[H];return q===void 0&&(q=new Yn,w[H]=q),q.getHandSpace()};function I(H){const q=A.get(H.inputSource);q&&q.dispatchEvent({type:H.type,data:H.inputSource})}function U(){A.forEach(function(H,q){H.disconnect(q)}),A.clear(),L=null,j=null,n.bindXRFramebuffer(null),e.setRenderTarget(e.getRenderTarget()),p&&t.deleteFramebuffer(p),g&&t.deleteFramebuffer(g),b&&t.deleteRenderbuffer(b),u&&t.deleteRenderbuffer(u),p=null,g=null,b=null,u=null,m=null,f=null,h=null,r=null,xe.stop(),i.isPresenting=!1,i.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(H){a=H,i.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(H){c=H,i.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return o},this.getBaseLayer=function(){return f!==null?f:m},this.getBinding=function(){return h},this.getFrame=function(){return d},this.getSession=function(){return r},this.setSession=async function(H){if(r=H,r!==null){r.addEventListener("select",I),r.addEventListener("selectstart",I),r.addEventListener("selectend",I),r.addEventListener("squeeze",I),r.addEventListener("squeezestart",I),r.addEventListener("squeezeend",I),r.addEventListener("end",U),r.addEventListener("inputsourceschange",G);const q=t.getContextAttributes();if(q.xrCompatible!==!0&&await t.makeXRCompatible(),r.renderState.layers===void 0){const re={antialias:q.antialias,alpha:q.alpha,depth:q.depth,stencil:q.stencil,framebufferScaleFactor:a};m=new XRWebGLLayer(r,t,re),r.updateRenderState({baseLayer:m})}else if(t instanceof WebGLRenderingContext){const re={antialias:!0,alpha:q.alpha,depth:q.depth,stencil:q.stencil,framebufferScaleFactor:a};m=new XRWebGLLayer(r,t,re),r.updateRenderState({layers:[m]})}else{_=q.antialias;let re=null;q.depth&&(M=256,q.stencil&&(M|=1024),T=q.stencil?33306:36096,re=q.stencil?35056:33190);const F={colorFormat:q.alpha?32856:32849,depthFormat:re,scaleFactor:a};h=new XRWebGLBinding(r,t),f=h.createProjectionLayer(F),p=t.createFramebuffer(),r.updateRenderState({layers:[f]}),_&&(g=t.createFramebuffer(),b=t.createRenderbuffer(),t.bindRenderbuffer(36161,b),t.renderbufferStorageMultisample(36161,4,32856,f.textureWidth,f.textureHeight),n.bindFramebuffer(36160,g),t.framebufferRenderbuffer(36160,36064,36161,b),t.bindRenderbuffer(36161,null),re!==null&&(u=t.createRenderbuffer(),t.bindRenderbuffer(36161,u),t.renderbufferStorageMultisample(36161,4,re,f.textureWidth,f.textureHeight),t.framebufferRenderbuffer(36160,T,36161,u),t.bindRenderbuffer(36161,null)),n.bindFramebuffer(36160,null))}o=await r.requestReferenceSpace(c),xe.setContext(r),xe.start(),i.isPresenting=!0,i.dispatchEvent({type:"sessionstart"})}};function G(H){const q=r.inputSources;for(let re=0;re<w.length;re++)A.set(q[re],w[re]);for(let re=0;re<H.removed.length;re++){const F=H.removed[re],me=A.get(F);me&&(me.dispatchEvent({type:"disconnected",data:F}),A.delete(F))}for(let re=0;re<H.added.length;re++){const F=H.added[re],me=A.get(F);me&&me.dispatchEvent({type:"connected",data:F})}}const z=new C,N=new C;function Y(H,q,re){z.setFromMatrixPosition(q.matrixWorld),N.setFromMatrixPosition(re.matrixWorld);const F=z.distanceTo(N),me=q.projectionMatrix.elements,_e=re.projectionMatrix.elements,K=me[14]/(me[10]-1),ue=me[14]/(me[10]+1),be=(me[9]+1)/me[5],he=(me[9]-1)/me[5],Le=(me[8]-1)/me[0],We=(_e[8]+1)/_e[0],it=K*Le,Qe=K*We,S=F/(-Le+We),y=S*-Le;q.matrixWorld.decompose(H.position,H.quaternion,H.scale),H.translateX(y),H.translateZ(S),H.matrixWorld.compose(H.position,H.quaternion,H.scale),H.matrixWorldInverse.copy(H.matrixWorld).invert();const W=K+S,J=ue+S,$=it-y,ie=Qe+(F-y),pe=be*ue/J*W,de=he*ue/J*W;H.projectionMatrix.makePerspective($,ie,pe,de,W,J)}function ne(H,q){q===null?H.matrixWorld.copy(H.matrix):H.matrixWorld.multiplyMatrices(q.matrixWorld,H.matrix),H.matrixWorldInverse.copy(H.matrixWorld).invert()}this.updateCamera=function(H){if(r===null)return;O.near=B.near=v.near=H.near,O.far=B.far=v.far=H.far,(L!==O.near||j!==O.far)&&(r.updateRenderState({depthNear:O.near,depthFar:O.far}),L=O.near,j=O.far);const q=H.parent,re=O.cameras;ne(O,q);for(let me=0;me<re.length;me++)ne(re[me],q);O.matrixWorld.decompose(O.position,O.quaternion,O.scale),H.position.copy(O.position),H.quaternion.copy(O.quaternion),H.scale.copy(O.scale),H.matrix.copy(O.matrix),H.matrixWorld.copy(O.matrixWorld);const F=H.children;for(let me=0,_e=F.length;me<_e;me++)F[me].updateMatrixWorld(!0);re.length===2?Y(O,v,B):O.projectionMatrix.copy(v.projectionMatrix)},this.getCamera=function(){return O},this.getFoveation=function(){if(f!==null)return f.fixedFoveation;if(m!==null)return m.fixedFoveation},this.setFoveation=function(H){f!==null&&(f.fixedFoveation=H),m!==null&&m.fixedFoveation!==void 0&&(m.fixedFoveation=H)};let oe=null;function te(H,q){if(l=q.getViewerPose(o),d=q,l!==null){const F=l.views;m!==null&&n.bindXRFramebuffer(m.framebuffer);let me=!1;F.length!==O.cameras.length&&(O.cameras.length=0,me=!0);for(let _e=0;_e<F.length;_e++){const K=F[_e];let ue=null;if(m!==null)ue=m.getViewport(K);else{const he=h.getViewSubImage(f,K);n.bindXRFramebuffer(p),he.depthStencilTexture!==void 0&&t.framebufferTexture2D(36160,T,3553,he.depthStencilTexture,0),t.framebufferTexture2D(36160,36064,3553,he.colorTexture,0),ue=he.viewport}const be=X[_e];be.matrix.fromArray(K.transform.matrix),be.projectionMatrix.fromArray(K.projectionMatrix),be.viewport.set(ue.x,ue.y,ue.width,ue.height),_e===0&&O.matrix.copy(be.matrix),me===!0&&O.cameras.push(be)}_&&(n.bindXRFramebuffer(g),M!==null&&t.clear(M))}const re=r.inputSources;for(let F=0;F<w.length;F++){const me=w[F],_e=re[F];me.update(_e,q,o)}if(oe&&oe(H,q),_){const F=f.textureWidth,me=f.textureHeight;n.bindFramebuffer(36008,g),n.bindFramebuffer(36009,p),t.invalidateFramebuffer(36008,[T]),t.invalidateFramebuffer(36009,[T]),t.blitFramebuffer(0,0,F,me,0,0,F,me,16384,9728),t.invalidateFramebuffer(36008,[36064]),n.bindFramebuffer(36008,null),n.bindFramebuffer(36009,null),n.bindFramebuffer(36160,g)}d=null}const xe=new Ns;xe.setAnimationLoop(te),this.setAnimationLoop=function(H){oe=H},this.dispose=function(){}}}function Md(s){function e(u,d){u.fogColor.value.copy(d.color),d.isFog?(u.fogNear.value=d.near,u.fogFar.value=d.far):d.isFogExp2&&(u.fogDensity.value=d.density)}function t(u,d,T,M,w){d.isMeshBasicMaterial?i(u,d):d.isMeshLambertMaterial?(i(u,d),c(u,d)):d.isMeshToonMaterial?(i(u,d),h(u,d)):d.isMeshPhongMaterial?(i(u,d),l(u,d)):d.isMeshStandardMaterial?(i(u,d),d.isMeshPhysicalMaterial?f(u,d,w):p(u,d)):d.isMeshMatcapMaterial?(i(u,d),m(u,d)):d.isMeshDepthMaterial?(i(u,d),_(u,d)):d.isMeshDistanceMaterial?(i(u,d),g(u,d)):d.isMeshNormalMaterial?(i(u,d),b(u,d)):d.isLineBasicMaterial?(n(u,d),d.isLineDashedMaterial&&r(u,d)):d.isPointsMaterial?a(u,d,T,M):d.isSpriteMaterial?o(u,d):d.isShadowMaterial?(u.color.value.copy(d.color),u.opacity.value=d.opacity):d.isShaderMaterial&&(d.uniformsNeedUpdate=!1)}function i(u,d){u.opacity.value=d.opacity,d.color&&u.diffuse.value.copy(d.color),d.emissive&&u.emissive.value.copy(d.emissive).multiplyScalar(d.emissiveIntensity),d.map&&(u.map.value=d.map),d.alphaMap&&(u.alphaMap.value=d.alphaMap),d.specularMap&&(u.specularMap.value=d.specularMap),d.alphaTest>0&&(u.alphaTest.value=d.alphaTest);const T=s.get(d).envMap;if(T){u.envMap.value=T,u.flipEnvMap.value=T.isCubeTexture&&T.isRenderTargetTexture===!1?-1:1,u.reflectivity.value=d.reflectivity,u.ior.value=d.ior,u.refractionRatio.value=d.refractionRatio;const A=s.get(T).__maxMipLevel;A!==void 0&&(u.maxMipLevel.value=A)}d.lightMap&&(u.lightMap.value=d.lightMap,u.lightMapIntensity.value=d.lightMapIntensity),d.aoMap&&(u.aoMap.value=d.aoMap,u.aoMapIntensity.value=d.aoMapIntensity);let M;d.map?M=d.map:d.specularMap?M=d.specularMap:d.displacementMap?M=d.displacementMap:d.normalMap?M=d.normalMap:d.bumpMap?M=d.bumpMap:d.roughnessMap?M=d.roughnessMap:d.metalnessMap?M=d.metalnessMap:d.alphaMap?M=d.alphaMap:d.emissiveMap?M=d.emissiveMap:d.clearcoatMap?M=d.clearcoatMap:d.clearcoatNormalMap?M=d.clearcoatNormalMap:d.clearcoatRoughnessMap?M=d.clearcoatRoughnessMap:d.specularIntensityMap?M=d.specularIntensityMap:d.specularTintMap?M=d.specularTintMap:d.transmissionMap?M=d.transmissionMap:d.thicknessMap&&(M=d.thicknessMap),M!==void 0&&(M.isWebGLRenderTarget&&(M=M.texture),M.matrixAutoUpdate===!0&&M.updateMatrix(),u.uvTransform.value.copy(M.matrix));let w;d.aoMap?w=d.aoMap:d.lightMap&&(w=d.lightMap),w!==void 0&&(w.isWebGLRenderTarget&&(w=w.texture),w.matrixAutoUpdate===!0&&w.updateMatrix(),u.uv2Transform.value.copy(w.matrix))}function n(u,d){u.diffuse.value.copy(d.color),u.opacity.value=d.opacity}function r(u,d){u.dashSize.value=d.dashSize,u.totalSize.value=d.dashSize+d.gapSize,u.scale.value=d.scale}function a(u,d,T,M){u.diffuse.value.copy(d.color),u.opacity.value=d.opacity,u.size.value=d.size*T,u.scale.value=M*.5,d.map&&(u.map.value=d.map),d.alphaMap&&(u.alphaMap.value=d.alphaMap),d.alphaTest>0&&(u.alphaTest.value=d.alphaTest);let w;d.map?w=d.map:d.alphaMap&&(w=d.alphaMap),w!==void 0&&(w.matrixAutoUpdate===!0&&w.updateMatrix(),u.uvTransform.value.copy(w.matrix))}function o(u,d){u.diffuse.value.copy(d.color),u.opacity.value=d.opacity,u.rotation.value=d.rotation,d.map&&(u.map.value=d.map),d.alphaMap&&(u.alphaMap.value=d.alphaMap),d.alphaTest>0&&(u.alphaTest.value=d.alphaTest);let T;d.map?T=d.map:d.alphaMap&&(T=d.alphaMap),T!==void 0&&(T.matrixAutoUpdate===!0&&T.updateMatrix(),u.uvTransform.value.copy(T.matrix))}function c(u,d){d.emissiveMap&&(u.emissiveMap.value=d.emissiveMap)}function l(u,d){u.specular.value.copy(d.specular),u.shininess.value=Math.max(d.shininess,1e-4),d.emissiveMap&&(u.emissiveMap.value=d.emissiveMap),d.bumpMap&&(u.bumpMap.value=d.bumpMap,u.bumpScale.value=d.bumpScale,d.side===ze&&(u.bumpScale.value*=-1)),d.normalMap&&(u.normalMap.value=d.normalMap,u.normalScale.value.copy(d.normalScale),d.side===ze&&u.normalScale.value.negate()),d.displacementMap&&(u.displacementMap.value=d.displacementMap,u.displacementScale.value=d.displacementScale,u.displacementBias.value=d.displacementBias)}function h(u,d){d.gradientMap&&(u.gradientMap.value=d.gradientMap),d.emissiveMap&&(u.emissiveMap.value=d.emissiveMap),d.bumpMap&&(u.bumpMap.value=d.bumpMap,u.bumpScale.value=d.bumpScale,d.side===ze&&(u.bumpScale.value*=-1)),d.normalMap&&(u.normalMap.value=d.normalMap,u.normalScale.value.copy(d.normalScale),d.side===ze&&u.normalScale.value.negate()),d.displacementMap&&(u.displacementMap.value=d.displacementMap,u.displacementScale.value=d.displacementScale,u.displacementBias.value=d.displacementBias)}function p(u,d){u.roughness.value=d.roughness,u.metalness.value=d.metalness,d.roughnessMap&&(u.roughnessMap.value=d.roughnessMap),d.metalnessMap&&(u.metalnessMap.value=d.metalnessMap),d.emissiveMap&&(u.emissiveMap.value=d.emissiveMap),d.bumpMap&&(u.bumpMap.value=d.bumpMap,u.bumpScale.value=d.bumpScale,d.side===ze&&(u.bumpScale.value*=-1)),d.normalMap&&(u.normalMap.value=d.normalMap,u.normalScale.value.copy(d.normalScale),d.side===ze&&u.normalScale.value.negate()),d.displacementMap&&(u.displacementMap.value=d.displacementMap,u.displacementScale.value=d.displacementScale,u.displacementBias.value=d.displacementBias),s.get(d).envMap&&(u.envMapIntensity.value=d.envMapIntensity)}function f(u,d,T){p(u,d),u.ior.value=d.ior,d.sheen>0&&(u.sheenTint.value.copy(d.sheenTint).multiplyScalar(d.sheen),u.sheenRoughness.value=d.sheenRoughness),d.clearcoat>0&&(u.clearcoat.value=d.clearcoat,u.clearcoatRoughness.value=d.clearcoatRoughness,d.clearcoatMap&&(u.clearcoatMap.value=d.clearcoatMap),d.clearcoatRoughnessMap&&(u.clearcoatRoughnessMap.value=d.clearcoatRoughnessMap),d.clearcoatNormalMap&&(u.clearcoatNormalScale.value.copy(d.clearcoatNormalScale),u.clearcoatNormalMap.value=d.clearcoatNormalMap,d.side===ze&&u.clearcoatNormalScale.value.negate())),d.transmission>0&&(u.transmission.value=d.transmission,u.transmissionSamplerMap.value=T.texture,u.transmissionSamplerSize.value.set(T.width,T.height),d.transmissionMap&&(u.transmissionMap.value=d.transmissionMap),u.thickness.value=d.thickness,d.thicknessMap&&(u.thicknessMap.value=d.thicknessMap),u.attenuationDistance.value=d.attenuationDistance,u.attenuationTint.value.copy(d.attenuationTint)),u.specularIntensity.value=d.specularIntensity,u.specularTint.value.copy(d.specularTint),d.specularIntensityMap&&(u.specularIntensityMap.value=d.specularIntensityMap),d.specularTintMap&&(u.specularTintMap.value=d.specularTintMap)}function m(u,d){d.matcap&&(u.matcap.value=d.matcap),d.bumpMap&&(u.bumpMap.value=d.bumpMap,u.bumpScale.value=d.bumpScale,d.side===ze&&(u.bumpScale.value*=-1)),d.normalMap&&(u.normalMap.value=d.normalMap,u.normalScale.value.copy(d.normalScale),d.side===ze&&u.normalScale.value.negate()),d.displacementMap&&(u.displacementMap.value=d.displacementMap,u.displacementScale.value=d.displacementScale,u.displacementBias.value=d.displacementBias)}function _(u,d){d.displacementMap&&(u.displacementMap.value=d.displacementMap,u.displacementScale.value=d.displacementScale,u.displacementBias.value=d.displacementBias)}function g(u,d){d.displacementMap&&(u.displacementMap.value=d.displacementMap,u.displacementScale.value=d.displacementScale,u.displacementBias.value=d.displacementBias),u.referencePosition.value.copy(d.referencePosition),u.nearDistance.value=d.nearDistance,u.farDistance.value=d.farDistance}function b(u,d){d.bumpMap&&(u.bumpMap.value=d.bumpMap,u.bumpScale.value=d.bumpScale,d.side===ze&&(u.bumpScale.value*=-1)),d.normalMap&&(u.normalMap.value=d.normalMap,u.normalScale.value.copy(d.normalScale),d.side===ze&&u.normalScale.value.negate()),d.displacementMap&&(u.displacementMap.value=d.displacementMap,u.displacementScale.value=d.displacementScale,u.displacementBias.value=d.displacementBias)}return{refreshFogUniforms:e,refreshMaterialUniforms:t}}function yd(){const s=ar("canvas");return s.style.display="block",s}function bd(s={}){const e=s.canvas!==void 0?s.canvas:yd(),t=s.context!==void 0?s.context:null,i=s.alpha!==void 0?s.alpha:!1,n=s.depth!==void 0?s.depth:!0,r=s.stencil!==void 0?s.stencil:!0,a=s.antialias!==void 0?s.antialias:!1,o=s.premultipliedAlpha!==void 0?s.premultipliedAlpha:!0,c=s.preserveDrawingBuffer!==void 0?s.preserveDrawingBuffer:!1,l=s.powerPreference!==void 0?s.powerPreference:"default",h=s.failIfMajorPerformanceCaveat!==void 0?s.failIfMajorPerformanceCaveat:!1;let p=null,f=null;const m=[],_=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=qe,this.physicallyCorrectLights=!1,this.toneMapping=Jt,this.toneMappingExposure=1;const g=this;let b=!1,u=0,d=0,T=null,M=-1,w=null;const A=new He,v=new He;let B=null,X=e.width,O=e.height,L=1,j=null,I=null;const U=new He(0,0,X,O),G=new He(0,0,X,O);let z=!1;const N=[],Y=new zs;let ne=!1,oe=!1,te=null;const xe=new Be,H=new C,q={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function re(){return T===null?L:1}let F=t;function me(x,D){for(let R=0;R<x.length;R++){const P=x[R],V=e.getContext(P,D);if(V!==null)return V}return null}try{const x={alpha:i,depth:n,stencil:r,antialias:a,premultipliedAlpha:o,preserveDrawingBuffer:c,powerPreference:l,failIfMajorPerformanceCaveat:h};if(e.addEventListener("webglcontextlost",Ge,!1),e.addEventListener("webglcontextrestored",Oe,!1),F===null){const D=["webgl2","webgl","experimental-webgl"];if(g.isWebGL1Renderer===!0&&D.shift(),F=me(D,x),F===null)throw me(D)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}F.getShaderPrecisionFormat===void 0&&(F.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(x){throw console.error("THREE.WebGLRenderer: "+x.message),x}let _e,K,ue,be,he,Le,We,it,Qe,S,y,W,J,$,ie,pe,de,ge,ae,E,Q,k,ee;function se(){_e=new Wu(F),K=new zu(F,_e,s),_e.init(K),k=new _d(F,_e,K),ue=new md(F,_e,K),N[0]=1029,be=new qu,he=new nd,Le=new gd(F,_e,ue,he,K,k,be),We=new Uu(g),it=new ku(g),Qe=new sl(F,K),ee=new Fu(F,_e,Qe,K),S=new Hu(F,Qe,be,ee),y=new Ju(F,S,Qe,be),ae=new ju(F,K,Le),pe=new Nu(he),W=new id(g,We,it,_e,K,ee,pe),J=new Md(he),$=new sd(he),ie=new hd(_e,K),ge=new Ru(g,We,ue,y,o),de=new pd(g,y,K),E=new Iu(F,_e,be,K),Q=new Xu(F,_e,be,K),be.programs=W.programs,g.capabilities=K,g.extensions=_e,g.properties=he,g.renderLists=$,g.shadowMap=de,g.state=ue,g.info=be}se();const ye=new vd(g,F);this.xr=ye,this.getContext=function(){return F},this.getContextAttributes=function(){return F.getContextAttributes()},this.forceContextLoss=function(){const x=_e.get("WEBGL_lose_context");x&&x.loseContext()},this.forceContextRestore=function(){const x=_e.get("WEBGL_lose_context");x&&x.restoreContext()},this.getPixelRatio=function(){return L},this.setPixelRatio=function(x){x!==void 0&&(L=x,this.setSize(X,O,!1))},this.getSize=function(x){return x.set(X,O)},this.setSize=function(x,D,R){if(ye.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}X=x,O=D,e.width=Math.floor(x*L),e.height=Math.floor(D*L),R!==!1&&(e.style.width=x+"px",e.style.height=D+"px"),this.setViewport(0,0,x,D)},this.getDrawingBufferSize=function(x){return x.set(X*L,O*L).floor()},this.setDrawingBufferSize=function(x,D,R){X=x,O=D,L=R,e.width=Math.floor(x*R),e.height=Math.floor(D*R),this.setViewport(0,0,x,D)},this.getCurrentViewport=function(x){return x.copy(A)},this.getViewport=function(x){return x.copy(U)},this.setViewport=function(x,D,R,P){x.isVector4?U.set(x.x,x.y,x.z,x.w):U.set(x,D,R,P),ue.viewport(A.copy(U).multiplyScalar(L).floor())},this.getScissor=function(x){return x.copy(G)},this.setScissor=function(x,D,R,P){x.isVector4?G.set(x.x,x.y,x.z,x.w):G.set(x,D,R,P),ue.scissor(v.copy(G).multiplyScalar(L).floor())},this.getScissorTest=function(){return z},this.setScissorTest=function(x){ue.setScissorTest(z=x)},this.setOpaqueSort=function(x){j=x},this.setTransparentSort=function(x){I=x},this.getClearColor=function(x){return x.copy(ge.getClearColor())},this.setClearColor=function(){ge.setClearColor.apply(ge,arguments)},this.getClearAlpha=function(){return ge.getClearAlpha()},this.setClearAlpha=function(){ge.setClearAlpha.apply(ge,arguments)},this.clear=function(x,D,R){let P=0;(x===void 0||x)&&(P|=16384),(D===void 0||D)&&(P|=256),(R===void 0||R)&&(P|=1024),F.clear(P)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",Ge,!1),e.removeEventListener("webglcontextrestored",Oe,!1),$.dispose(),ie.dispose(),he.dispose(),We.dispose(),it.dispose(),y.dispose(),ee.dispose(),ye.dispose(),ye.removeEventListener("sessionstart",pr),ye.removeEventListener("sessionend",mr),te&&(te.dispose(),te=null),kt.stop()};function Ge(x){x.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),b=!0}function Oe(){console.log("THREE.WebGLRenderer: Context Restored."),b=!1;const x=be.autoReset,D=de.enabled,R=de.autoUpdate,P=de.needsUpdate,V=de.type;se(),be.autoReset=x,de.enabled=D,de.autoUpdate=R,de.needsUpdate=P,de.type=V}function Tt(x){const D=x.target;D.removeEventListener("dispose",Tt),Ie(D)}function Ie(x){gt(x),he.remove(x)}function gt(x){const D=he.get(x).programs;D!==void 0&&D.forEach(function(R){W.releaseProgram(R)})}function _t(x,D){x.render(function(R){g.renderBufferImmediate(R,D)})}this.renderBufferImmediate=function(x,D){ee.initAttributes();const R=he.get(x);x.hasPositions&&!R.position&&(R.position=F.createBuffer()),x.hasNormals&&!R.normal&&(R.normal=F.createBuffer()),x.hasUvs&&!R.uv&&(R.uv=F.createBuffer()),x.hasColors&&!R.color&&(R.color=F.createBuffer());const P=D.getAttributes();x.hasPositions&&(F.bindBuffer(34962,R.position),F.bufferData(34962,x.positionArray,35048),ee.enableAttribute(P.position.location),F.vertexAttribPointer(P.position.location,3,5126,!1,0,0)),x.hasNormals&&(F.bindBuffer(34962,R.normal),F.bufferData(34962,x.normalArray,35048),ee.enableAttribute(P.normal.location),F.vertexAttribPointer(P.normal.location,3,5126,!1,0,0)),x.hasUvs&&(F.bindBuffer(34962,R.uv),F.bufferData(34962,x.uvArray,35048),ee.enableAttribute(P.uv.location),F.vertexAttribPointer(P.uv.location,2,5126,!1,0,0)),x.hasColors&&(F.bindBuffer(34962,R.color),F.bufferData(34962,x.colorArray,35048),ee.enableAttribute(P.color.location),F.vertexAttribPointer(P.color.location,3,5126,!1,0,0)),ee.disableUnusedAttributes(),F.drawArrays(4,0,x.count),x.count=0},this.renderBufferDirect=function(x,D,R,P,V,fe){D===null&&(D=q);const le=V.isMesh&&V.matrixWorld.determinant()<0,ce=vr(x,D,R,P,V);ue.setMaterial(P,le);let ve=R.index;const Ee=R.attributes.position;if(ve===null){if(Ee===void 0||Ee.count===0)return}else if(ve.count===0)return;let Se=1;P.wireframe===!0&&(ve=S.getWireframeAttribute(R),Se=2),ee.setup(V,P,ce,R,ve);let we,Re=E;ve!==null&&(we=Qe.get(ve),Re=Q,Re.setIndex(we));const Wt=ve!==null?ve.count:Ee.count,Te=R.drawRange.start*Se,Ei=R.drawRange.count*Se,Pe=fe!==null?fe.start*Se:0,Ht=fe!==null?fe.count*Se:1/0,Xt=Math.max(Te,Pe),qt=Math.min(Wt,Te+Ei,Pe+Ht)-1,Et=Math.max(0,qt-Xt+1);if(Et!==0){if(V.isMesh)P.wireframe===!0?(ue.setLineWidth(P.wireframeLinewidth*re()),Re.setMode(1)):Re.setMode(4);else if(V.isLine){let Fe=P.linewidth;Fe===void 0&&(Fe=1),ue.setLineWidth(Fe*re()),V.isLineSegments?Re.setMode(1):V.isLineLoop?Re.setMode(2):Re.setMode(3)}else V.isPoints?Re.setMode(0):V.isSprite&&Re.setMode(4);if(V.isInstancedMesh)Re.renderInstances(Xt,Et,V.count);else if(R.isInstancedBufferGeometry){const Fe=Math.min(R.instanceCount,R._maxInstanceCount);Re.renderInstances(Xt,Et,Fe)}else Re.render(Xt,Et)}},this.compile=function(x,D){f=ie.get(x),f.init(),_.push(f),x.traverseVisible(function(R){R.isLight&&R.layers.test(D.layers)&&(f.pushLight(R),R.castShadow&&f.pushShadow(R))}),f.setupLights(g.physicallyCorrectLights),x.traverse(function(R){const P=R.material;if(P)if(Array.isArray(P))for(let V=0;V<P.length;V++){const fe=P[V];_n(fe,x,R)}else _n(P,x,R)}),_.pop(),f=null};let gn=null;function Qs(x){gn&&gn(x)}function pr(){kt.stop()}function mr(){kt.start()}const kt=new Ns;kt.setAnimationLoop(Qs),typeof window!="undefined"&&kt.setContext(window),this.setAnimationLoop=function(x){gn=x,ye.setAnimationLoop(x),x===null?kt.stop():kt.start()},ye.addEventListener("sessionstart",pr),ye.addEventListener("sessionend",mr),this.render=function(x,D){if(D!==void 0&&D.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(b===!0)return;x.autoUpdate===!0&&x.updateMatrixWorld(),D.parent===null&&D.updateMatrixWorld(),ye.enabled===!0&&ye.isPresenting===!0&&(ye.cameraAutoUpdate===!0&&ye.updateCamera(D),D=ye.getCamera()),x.isScene===!0&&x.onBeforeRender(g,x,D,T),f=ie.get(x,_.length),f.init(),_.push(f),xe.multiplyMatrices(D.projectionMatrix,D.matrixWorldInverse),Y.setFromProjectionMatrix(xe),oe=this.localClippingEnabled,ne=pe.init(this.clippingPlanes,oe,D),p=$.get(x,m.length),p.init(),m.push(p),gr(x,D,0,g.sortObjects),p.finish(),g.sortObjects===!0&&p.sort(j,I),ne===!0&&pe.beginShadows();const R=f.state.shadowsArray;if(de.render(R,x,D),ne===!0&&pe.endShadows(),this.info.autoReset===!0&&this.info.reset(),ge.render(p,x),f.setupLights(g.physicallyCorrectLights),D.isArrayCamera){const P=D.cameras;for(let V=0,fe=P.length;V<fe;V++){const le=P[V];_r(p,x,le,le.viewport)}}else _r(p,x,D);T!==null&&(Le.updateMultisampleRenderTarget(T),Le.updateRenderTargetMipmap(T)),x.isScene===!0&&x.onAfterRender(g,x,D),ue.buffers.depth.setTest(!0),ue.buffers.depth.setMask(!0),ue.buffers.color.setMask(!0),ue.setPolygonOffset(!1),ee.resetDefaultState(),M=-1,w=null,_.pop(),_.length>0?f=_[_.length-1]:f=null,m.pop(),m.length>0?p=m[m.length-1]:p=null};function gr(x,D,R,P){if(x.visible===!1)return;if(x.layers.test(D.layers)){if(x.isGroup)R=x.renderOrder;else if(x.isLOD)x.autoUpdate===!0&&x.update(D);else if(x.isLight)f.pushLight(x),x.castShadow&&f.pushShadow(x);else if(x.isSprite){if(!x.frustumCulled||Y.intersectsSprite(x)){P&&H.setFromMatrixPosition(x.matrixWorld).applyMatrix4(xe);const le=y.update(x),ce=x.material;ce.visible&&p.push(x,le,ce,R,H.z,null)}}else if(x.isImmediateRenderObject)P&&H.setFromMatrixPosition(x.matrixWorld).applyMatrix4(xe),p.push(x,null,x.material,R,H.z,null);else if((x.isMesh||x.isLine||x.isPoints)&&(x.isSkinnedMesh&&x.skeleton.frame!==be.render.frame&&(x.skeleton.update(),x.skeleton.frame=be.render.frame),!x.frustumCulled||Y.intersectsObject(x))){P&&H.setFromMatrixPosition(x.matrixWorld).applyMatrix4(xe);const le=y.update(x),ce=x.material;if(Array.isArray(ce)){const ve=le.groups;for(let Ee=0,Se=ve.length;Ee<Se;Ee++){const we=ve[Ee],Re=ce[we.materialIndex];Re&&Re.visible&&p.push(x,le,Re,R,H.z,we)}}else ce.visible&&p.push(x,le,ce,R,H.z,null)}}const fe=x.children;for(let le=0,ce=fe.length;le<ce;le++)gr(fe[le],D,R,P)}function _r(x,D,R,P){const V=x.opaque,fe=x.transmissive,le=x.transparent;f.setupLightsView(R),fe.length>0&&Ks(V,D,R),P&&ue.viewport(A.copy(P)),V.length>0&&Vi(V,D,R),fe.length>0&&Vi(fe,D,R),le.length>0&&Vi(le,D,R)}function Ks(x,D,R){if(te===null){const le=a===!0&&K.isWebGL2===!0?Ds:Ut;te=new le(1024,1024,{generateMipmaps:!0,type:k.convert(pi)!==null?pi:Ot,minFilter:fn,magFilter:Ze,wrapS:$e,wrapT:$e})}const P=g.getRenderTarget();g.setRenderTarget(te),g.clear();const V=g.toneMapping;g.toneMapping=Jt,Vi(x,D,R),g.toneMapping=V,Le.updateMultisampleRenderTarget(te),Le.updateRenderTargetMipmap(te),g.setRenderTarget(P)}function Vi(x,D,R){const P=D.isScene===!0?D.overrideMaterial:null;for(let V=0,fe=x.length;V<fe;V++){const le=x[V],ce=le.object,ve=le.geometry,Ee=P===null?le.material:P,Se=le.group;ce.layers.test(R.layers)&&ea(ce,D,R,ve,Ee,Se)}}function ea(x,D,R,P,V,fe){if(x.onBeforeRender(g,D,R,P,V,fe),x.modelViewMatrix.multiplyMatrices(R.matrixWorldInverse,x.matrixWorld),x.normalMatrix.getNormalMatrix(x.modelViewMatrix),V.onBeforeRender(g,D,R,P,x,fe),x.isImmediateRenderObject){const le=vr(R,D,P,V,x);ue.setMaterial(V),ee.reset(),_t(x,le)}else V.transparent===!0&&V.side===gi?(V.side=ze,V.needsUpdate=!0,g.renderBufferDirect(R,D,P,V,x,fe),V.side=Bi,V.needsUpdate=!0,g.renderBufferDirect(R,D,P,V,x,fe),V.side=gi):g.renderBufferDirect(R,D,P,V,x,fe);x.onAfterRender(g,D,R,P,V,fe)}function _n(x,D,R){D.isScene!==!0&&(D=q);const P=he.get(x),V=f.state.lights,fe=f.state.shadowsArray,le=V.state.version,ce=W.getParameters(x,V.state,fe,D,R),ve=W.getProgramCacheKey(ce);let Ee=P.programs;P.environment=x.isMeshStandardMaterial?D.environment:null,P.fog=D.fog,P.envMap=(x.isMeshStandardMaterial?it:We).get(x.envMap||P.environment),Ee===void 0&&(x.addEventListener("dispose",Tt),Ee=new Map,P.programs=Ee);let Se=Ee.get(ve);if(Se!==void 0){if(P.currentProgram===Se&&P.lightsStateVersion===le)return xr(x,ce),Se}else ce.uniforms=W.getUniforms(x),x.onBuild(ce,g),x.onBeforeCompile(ce,g),Se=W.acquireProgram(ce,ve),Ee.set(ve,Se),P.uniforms=ce.uniforms;const we=P.uniforms;(!x.isShaderMaterial&&!x.isRawShaderMaterial||x.clipping===!0)&&(we.clippingPlanes=pe.uniform),xr(x,ce),P.needsLights=ia(x),P.lightsStateVersion=le,P.needsLights&&(we.ambientLightColor.value=V.state.ambient,we.lightProbe.value=V.state.probe,we.directionalLights.value=V.state.directional,we.directionalLightShadows.value=V.state.directionalShadow,we.spotLights.value=V.state.spot,we.spotLightShadows.value=V.state.spotShadow,we.rectAreaLights.value=V.state.rectArea,we.ltc_1.value=V.state.rectAreaLTC1,we.ltc_2.value=V.state.rectAreaLTC2,we.pointLights.value=V.state.point,we.pointLightShadows.value=V.state.pointShadow,we.hemisphereLights.value=V.state.hemi,we.directionalShadowMap.value=V.state.directionalShadowMap,we.directionalShadowMatrix.value=V.state.directionalShadowMatrix,we.spotShadowMap.value=V.state.spotShadowMap,we.spotShadowMatrix.value=V.state.spotShadowMatrix,we.pointShadowMap.value=V.state.pointShadowMap,we.pointShadowMatrix.value=V.state.pointShadowMatrix);const Re=Se.getUniforms(),Wt=Gt.seqWithValue(Re.seq,we);return P.currentProgram=Se,P.uniformsList=Wt,Se}function xr(x,D){const R=he.get(x);R.outputEncoding=D.outputEncoding,R.instancing=D.instancing,R.skinning=D.skinning,R.morphTargets=D.morphTargets,R.morphNormals=D.morphNormals,R.morphTargetsCount=D.morphTargetsCount,R.numClippingPlanes=D.numClippingPlanes,R.numIntersection=D.numClipIntersection,R.vertexAlphas=D.vertexAlphas,R.vertexTangents=D.vertexTangents}function vr(x,D,R,P,V){D.isScene!==!0&&(D=q),Le.resetTextureUnits();const fe=D.fog,le=P.isMeshStandardMaterial?D.environment:null,ce=T===null?g.outputEncoding:T.texture.encoding,ve=(P.isMeshStandardMaterial?it:We).get(P.envMap||le),Ee=P.vertexColors===!0&&!!R&&!!R.attributes.color&&R.attributes.color.itemSize===4,Se=!!P.normalMap&&!!R&&!!R.attributes.tangent,we=!!R&&!!R.morphAttributes.position,Re=!!R&&!!R.morphAttributes.normal,Wt=!!R&&!!R.morphAttributes.position?R.morphAttributes.position.length:0,Te=he.get(P),Ei=f.state.lights;if(ne===!0&&(oe===!0||x!==w)){const nt=x===w&&P.id===M;pe.setState(P,x,nt)}let Pe=!1;P.version===Te.__version?(Te.needsLights&&Te.lightsStateVersion!==Ei.state.version||Te.outputEncoding!==ce||V.isInstancedMesh&&Te.instancing===!1||!V.isInstancedMesh&&Te.instancing===!0||V.isSkinnedMesh&&Te.skinning===!1||!V.isSkinnedMesh&&Te.skinning===!0||Te.envMap!==ve||P.fog&&Te.fog!==fe||Te.numClippingPlanes!==void 0&&(Te.numClippingPlanes!==pe.numPlanes||Te.numIntersection!==pe.numIntersection)||Te.vertexAlphas!==Ee||Te.vertexTangents!==Se||Te.morphTargets!==we||Te.morphNormals!==Re||K.isWebGL2===!0&&Te.morphTargetsCount!==Wt)&&(Pe=!0):(Pe=!0,Te.__version=P.version);let Ht=Te.currentProgram;Pe===!0&&(Ht=_n(P,D,V));let Xt=!1,qt=!1,Et=!1;const Fe=Ht.getUniforms(),Ai=Te.uniforms;if(ue.useProgram(Ht.program)&&(Xt=!0,qt=!0,Et=!0),P.id!==M&&(M=P.id,qt=!0),Xt||w!==x){if(Fe.setValue(F,"projectionMatrix",x.projectionMatrix),K.logarithmicDepthBuffer&&Fe.setValue(F,"logDepthBufFC",2/(Math.log(x.far+1)/Math.LN2)),w!==x&&(w=x,qt=!0,Et=!0),P.isShaderMaterial||P.isMeshPhongMaterial||P.isMeshToonMaterial||P.isMeshStandardMaterial||P.envMap){const nt=Fe.map.cameraPosition;nt!==void 0&&nt.setValue(F,H.setFromMatrixPosition(x.matrixWorld))}(P.isMeshPhongMaterial||P.isMeshToonMaterial||P.isMeshLambertMaterial||P.isMeshBasicMaterial||P.isMeshStandardMaterial||P.isShaderMaterial)&&Fe.setValue(F,"isOrthographic",x.isOrthographicCamera===!0),(P.isMeshPhongMaterial||P.isMeshToonMaterial||P.isMeshLambertMaterial||P.isMeshBasicMaterial||P.isMeshStandardMaterial||P.isShaderMaterial||P.isShadowMaterial||V.isSkinnedMesh)&&Fe.setValue(F,"viewMatrix",x.matrixWorldInverse)}if(V.isSkinnedMesh){Fe.setOptional(F,V,"bindMatrix"),Fe.setOptional(F,V,"bindMatrixInverse");const nt=V.skeleton;nt&&(K.floatVertexTextures?(nt.boneTexture===null&&nt.computeBoneTexture(),Fe.setValue(F,"boneTexture",nt.boneTexture,Le),Fe.setValue(F,"boneTextureSize",nt.boneTextureSize)):Fe.setOptional(F,nt,"boneMatrices"))}return!!R&&(R.morphAttributes.position!==void 0||R.morphAttributes.normal!==void 0)&&ae.update(V,R,P,Ht),(qt||Te.receiveShadow!==V.receiveShadow)&&(Te.receiveShadow=V.receiveShadow,Fe.setValue(F,"receiveShadow",V.receiveShadow)),qt&&(Fe.setValue(F,"toneMappingExposure",g.toneMappingExposure),Te.needsLights&&ta(Ai,Et),fe&&P.fog&&J.refreshFogUniforms(Ai,fe),J.refreshMaterialUniforms(Ai,P,L,O,te),Gt.upload(F,Te.uniformsList,Ai,Le)),P.isShaderMaterial&&P.uniformsNeedUpdate===!0&&(Gt.upload(F,Te.uniformsList,Ai,Le),P.uniformsNeedUpdate=!1),P.isSpriteMaterial&&Fe.setValue(F,"center",V.center),Fe.setValue(F,"modelViewMatrix",V.modelViewMatrix),Fe.setValue(F,"normalMatrix",V.normalMatrix),Fe.setValue(F,"modelMatrix",V.matrixWorld),Ht}function ta(x,D){x.ambientLightColor.needsUpdate=D,x.lightProbe.needsUpdate=D,x.directionalLights.needsUpdate=D,x.directionalLightShadows.needsUpdate=D,x.pointLights.needsUpdate=D,x.pointLightShadows.needsUpdate=D,x.spotLights.needsUpdate=D,x.spotLightShadows.needsUpdate=D,x.rectAreaLights.needsUpdate=D,x.hemisphereLights.needsUpdate=D}function ia(x){return x.isMeshLambertMaterial||x.isMeshToonMaterial||x.isMeshPhongMaterial||x.isMeshStandardMaterial||x.isShadowMaterial||x.isShaderMaterial&&x.lights===!0}this.getActiveCubeFace=function(){return u},this.getActiveMipmapLevel=function(){return d},this.getRenderTarget=function(){return T},this.setRenderTarget=function(x,D=0,R=0){T=x,u=D,d=R,x&&he.get(x).__webglFramebuffer===void 0&&Le.setupRenderTarget(x);let P=null,V=!1,fe=!1;if(x){const ce=x.texture;(ce.isDataTexture3D||ce.isDataTexture2DArray)&&(fe=!0);const ve=he.get(x).__webglFramebuffer;x.isWebGLCubeRenderTarget?(P=ve[D],V=!0):x.isWebGLMultisampleRenderTarget?P=he.get(x).__webglMultisampledFramebuffer:P=ve,A.copy(x.viewport),v.copy(x.scissor),B=x.scissorTest}else A.copy(U).multiplyScalar(L).floor(),v.copy(G).multiplyScalar(L).floor(),B=z;if(ue.bindFramebuffer(36160,P)&&K.drawBuffers){let ce=!1;if(x)if(x.isWebGLMultipleRenderTargets){const ve=x.texture;if(N.length!==ve.length||N[0]!==36064){for(let Ee=0,Se=ve.length;Ee<Se;Ee++)N[Ee]=36064+Ee;N.length=ve.length,ce=!0}}else(N.length!==1||N[0]!==36064)&&(N[0]=36064,N.length=1,ce=!0);else(N.length!==1||N[0]!==1029)&&(N[0]=1029,N.length=1,ce=!0);ce&&(K.isWebGL2?F.drawBuffers(N):_e.get("WEBGL_draw_buffers").drawBuffersWEBGL(N))}if(ue.viewport(A),ue.scissor(v),ue.setScissorTest(B),V){const ce=he.get(x.texture);F.framebufferTexture2D(36160,36064,34069+D,ce.__webglTexture,R)}else if(fe){const ce=he.get(x.texture),ve=D||0;F.framebufferTextureLayer(36160,36064,ce.__webglTexture,R||0,ve)}M=-1},this.readRenderTargetPixels=function(x,D,R,P,V,fe,le){if(!(x&&x.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let ce=he.get(x).__webglFramebuffer;if(x.isWebGLCubeRenderTarget&&le!==void 0&&(ce=ce[le]),ce){ue.bindFramebuffer(36160,ce);try{const ve=x.texture,Ee=ve.format,Se=ve.type;if(Ee!==Xe&&k.convert(Ee)!==F.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const we=Se===pi&&(_e.has("EXT_color_buffer_half_float")||K.isWebGL2&&_e.has("EXT_color_buffer_float"));if(Se!==Ot&&k.convert(Se)!==F.getParameter(35738)&&!(Se===zt&&(K.isWebGL2||_e.has("OES_texture_float")||_e.has("WEBGL_color_buffer_float")))&&!we){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}F.checkFramebufferStatus(36160)===36053?D>=0&&D<=x.width-P&&R>=0&&R<=x.height-V&&F.readPixels(D,R,P,V,k.convert(Ee),k.convert(Se),fe):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{const ve=T!==null?he.get(T).__webglFramebuffer:null;ue.bindFramebuffer(36160,ve)}}},this.copyFramebufferToTexture=function(x,D,R=0){const P=Math.pow(2,-R),V=Math.floor(D.image.width*P),fe=Math.floor(D.image.height*P);let le=k.convert(D.format);K.isWebGL2&&(le===6407&&(le=32849),le===6408&&(le=32856)),Le.setTexture2D(D,0),F.copyTexImage2D(3553,R,le,x.x,x.y,V,fe,0),ue.unbindTexture()},this.copyTextureToTexture=function(x,D,R,P=0){const V=D.image.width,fe=D.image.height,le=k.convert(R.format),ce=k.convert(R.type);Le.setTexture2D(R,0),F.pixelStorei(37440,R.flipY),F.pixelStorei(37441,R.premultiplyAlpha),F.pixelStorei(3317,R.unpackAlignment),D.isDataTexture?F.texSubImage2D(3553,P,x.x,x.y,V,fe,le,ce,D.image.data):D.isCompressedTexture?F.compressedTexSubImage2D(3553,P,x.x,x.y,D.mipmaps[0].width,D.mipmaps[0].height,le,D.mipmaps[0].data):F.texSubImage2D(3553,P,x.x,x.y,le,ce,D.image),P===0&&R.generateMipmaps&&F.generateMipmap(3553),ue.unbindTexture()},this.copyTextureToTexture3D=function(x,D,R,P,V=0){if(g.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const fe=x.max.x-x.min.x+1,le=x.max.y-x.min.y+1,ce=x.max.z-x.min.z+1,ve=k.convert(P.format),Ee=k.convert(P.type);let Se;if(P.isDataTexture3D)Le.setTexture3D(P,0),Se=32879;else if(P.isDataTexture2DArray)Le.setTexture2DArray(P,0),Se=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}F.pixelStorei(37440,P.flipY),F.pixelStorei(37441,P.premultiplyAlpha),F.pixelStorei(3317,P.unpackAlignment);const we=F.getParameter(3314),Re=F.getParameter(32878),Wt=F.getParameter(3316),Te=F.getParameter(3315),Ei=F.getParameter(32877),Pe=R.isCompressedTexture?R.mipmaps[0]:R.image;F.pixelStorei(3314,Pe.width),F.pixelStorei(32878,Pe.height),F.pixelStorei(3316,x.min.x),F.pixelStorei(3315,x.min.y),F.pixelStorei(32877,x.min.z),R.isDataTexture||R.isDataTexture3D?F.texSubImage3D(Se,V,D.x,D.y,D.z,fe,le,ce,ve,Ee,Pe.data):R.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),F.compressedTexSubImage3D(Se,V,D.x,D.y,D.z,fe,le,ce,ve,Pe.data)):F.texSubImage3D(Se,V,D.x,D.y,D.z,fe,le,ce,ve,Ee,Pe),F.pixelStorei(3314,we),F.pixelStorei(32878,Re),F.pixelStorei(3316,Wt),F.pixelStorei(3315,Te),F.pixelStorei(32877,Ei),V===0&&P.generateMipmaps&&F.generateMipmap(Se),ue.unbindTexture()},this.initTexture=function(x){Le.setTexture2D(x,0),ue.unbindTexture()},this.resetState=function(){u=0,d=0,T=null,ue.reset(),ee.reset()},typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}class Sd extends tt{constructor(){super(),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.autoUpdate=e.autoUpdate,this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),t}}Sd.prototype.isScene=!0;class $s extends wt{constructor(e=1,t=32,i=16,n=0,r=Math.PI*2,a=0,o=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:i,phiStart:n,phiLength:r,thetaStart:a,thetaLength:o},t=Math.max(3,Math.floor(t)),i=Math.max(2,Math.floor(i));const c=Math.min(a+o,Math.PI);let l=0;const h=[],p=new C,f=new C,m=[],_=[],g=[],b=[];for(let u=0;u<=i;u++){const d=[],T=u/i;let M=0;u==0&&a==0?M=.5/t:u==i&&c==Math.PI&&(M=-.5/t);for(let w=0;w<=t;w++){const A=w/t;p.x=-e*Math.cos(n+A*r)*Math.sin(a+T*o),p.y=e*Math.cos(a+T*o),p.z=e*Math.sin(n+A*r)*Math.sin(a+T*o),_.push(p.x,p.y,p.z),f.copy(p).normalize(),g.push(f.x,f.y,f.z),b.push(A+M,1-T),d.push(l++)}h.push(d)}for(let u=0;u<i;u++)for(let d=0;d<t;d++){const T=h[u][d+1],M=h[u][d],w=h[u+1][d],A=h[u+1][d+1];(u!==0||a>0)&&m.push(T,M,A),(u!==i-1||c<Math.PI)&&m.push(M,w,A)}this.setIndex(m),this.setAttribute("position",new mt(_,3)),this.setAttribute("normal",new mt(g,3)),this.setAttribute("uv",new mt(b,2))}static fromJSON(e){return new $s(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}function wd(s){const e=new wi(1,1,1),t=new pn({color:16777215,wireframe:!0}),i=new pt(e,t),[n,r,a]=Array(3).fill().map(()=>No(500));i.position.set(n,r,a),i.userData.rx=Math.random()*.01-.005,i.userData.ry=Math.random()*.01-.005,i.userData.rz=Math.random()*.01-.005,s.add(i)}function Td(s,e){window.addEventListener("resize",function(){s.setSize(window.innerWidth,window.innerHeight),e.aspect=window.innerWidth/window.innerHeight,e.updateProjectionMatrix()})}export{wt as B,mt as F,zi as G,pn as M,ot as P,Sd as S,C as V,bd as W,pt as a,$s as b,Td as c,De as d,wd as r};
